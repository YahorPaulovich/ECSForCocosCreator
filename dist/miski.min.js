/*! Miski v0.9.0. MIT license. (C) 2021-2022 P. Hughes<github@phugh.es>(https://www.phugh.es). All rights reserved. **/
const e=1e6,t=Object.freeze(["component","id","isTag","name","schema","size","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","prototype","toLocaleString","toString","valueOf","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupGetter__","__proto__"]),n=/^(?![0-9])[a-zA-Z0-9$_]+$/,r=Object.freeze([]),o=Symbol("EMPTY");function i(e){return!isNaN(e)&&e>=0&&e<=4294967295}function c(e){return Boolean("function"==typeof e&&Object.prototype.hasOwnProperty.call(e,"BYTES_PER_ELEMENT"))}function a(e){return Boolean("string"==typeof e&&e.length>0&&!0===n.test(e)||!t.includes(e))}function s(e){return Boolean("object"==typeof e&&!Array.isArray(e))}function u(e){const t=e-1;return Array.from({length:e},((e,n)=>t-n))}function f(e){return s(e)&&Object.entries(e).every((([e,t])=>a(e)&&(e=>{if(!Array.isArray(e))return c(e);{const[t,n]=e;if(!isNaN(n)&&c(t))return!0}return!1})(t)))}function y(e,t){return e+(Array.isArray(t)?t[0].BYTES_PER_ELEMENT:t.BYTES_PER_ELEMENT)}function p(e){return Object.values(e).reduce(y,0)}function d(e){if(!e)throw new SyntaxError("Component creation requires a specification object.");const{maxEntities:t,name:n,schema:r}=e;if(t&&(!i(t)||0===t))throw new SyntaxError("Component maxEntities must be a Uint32.");if(!a(n))throw new SyntaxError("Component name is invalid.");if(r&&!f(r))throw new SyntaxError("Component schema is invalid.");return Object.freeze({maxEntities:t??null,isTag:Boolean(r),name:n,schema:r?Object.freeze({...r}):null,size:r?p(r):0})}function l(e){if(!e)throw new SyntaxError("createQuery: specification object is required.");const{all:t=r,any:n=r,none:o=r}=e;if(![...t,...n,...o].every((e=>Object.prototype.hasOwnProperty.call(e,"name"))))throw new SyntaxError("Query specification object is invalid.");return Object.freeze({all:Object.freeze([...t]),any:Object.freeze([...n]),none:Object.freeze([...o])})}function h(e,...t){return function(n){const[r,o]=1===t.length?n.getQueryResult(t[0]):n.getQueryResults(...t);return function(...t){return e(o,r(),...t)}}}function E(e){return function(t){const{entities:n,exited:r}=t;return n.delete(e),r.add(e),t.isDirty=!0,t}}function m(e){const{bitfield:t,id:n}=function(e){if(!e)throw new SyntaxError("Archetype: specification object required.");const{bitfield:t,id:n}=e;if(!t)throw new SyntaxError("Archetype: spec.bitfield is required.");return{bitfield:t,id:n||t.toString()}}(e);return{isDirty:!0,bitfield:t,candidateCache:new Map,cloneCache:new Map,entered:new Set,entities:new Set,exited:new Set,id:n}}function g(e){const t=new Map,n=u(e.length);return new Proxy(e,{get:(n,r)=>{return i=r,e[t.get(i)??o];var i},set:(r,o,i)=>((r,o)=>{const i=t.get(r)??n.pop();return void 0!==i&&(e[i]=o,t.set(r,i),!0)})(o,i),deleteProperty:(r,o)=>(r=>{const o=t.get(r);return void 0!==o&&(e[o]=0,t.delete(r),n.push(o),!0)})(o)})}function w(e){const{components:t,partitioner:n}=e;return[...new Set(t)].reduce(((e,t,r)=>{const{name:o}=t;if(Object.prototype.hasOwnProperty.call(e,o))throw new Error(`ComponentInstance with name "${o}" already exists.`);const c=n(t);return e[o]=function(e){const{component:t,id:n,storage:r}=e;if(!t)throw new Error("Component instantiation requires as component!");if(!i(n))throw new SyntaxError("Component ID is invalid.");if(r&&!s(r))throw new TypeError("Component storage is malformed.");let o=0;const c=Object.create(t,{count:{get:()=>o,set(e){o=e},configurable:!1,enumerable:!0},id:{value:n,configurable:!1,enumerable:!0,writable:!1}});return Object.freeze(Object.assign(c,r))}({component:t,id:r,storage:c}),e}),{})}function b(e){const{capacity:t,components:n,getEntityArchetype:r,isBitOn:o,isValidEntity:i,updateArchetype:c}=e,a=function(e){const{capacity:t,components:n}=e,r=function(e,t){return t.reduce((function(t,n){const{size:r=0}=n;return!r||r<=0?t:t+r*e}),0)}(t,n);return new ArrayBuffer(8*Math.ceil(r/8))}({capacity:t,components:n}),s=function(e){const{buffer:t,capacity:n}=e;let r=0,o=!1;return function(e){if(!0===o)throw new Error("ArrayBuffer is full!");const{maxEntities:i,schema:c,size:a=0}=e;if(!a||a<=0)return;const s=i??n;if(r+a*s>t.byteLength)throw new Error("Component will not fit inside the buffer!");let u=0;const f=Object.entries(c).reduce((function(e,[n,o]){let c=o,a=0;Array.isArray(o)&&([c,a]=o);const f=new c(t,r+u,s);return e[n]=null===i?f:g(f),0!==a&&e[n].fill(a),u+=c.BYTES_PER_ELEMENT*s,e}),{});return r+=u,r>t.byteLength&&(o=!0),f}}({buffer:a,capacity:t}),u=w({components:n,partitioner:s}),f=new Map;Object.values(u).forEach((e=>{f.set(Object.getPrototypeOf(e),e)}));return{componentMap:f,addComponentToEntity:(e,t,n)=>{if(!i(t))return!1;const a=f.get(e);if(!a)return!1;const s=r(t);if(s&&o(a.id,s.bitfield))return!0;const{maxEntities:u}=e;return!(u&&a.count>=u)&&(a.count=a.count+1,c(t,a),e.schema&&Object.entries(e.schema).forEach((([e,n])=>{Array.isArray(n)&&(a[e][t]=n[1]??0)})),n&&Object.entries(n).forEach((([e,n])=>{a[e][t]=n})),!0)},entityHasComponent:(e,t)=>{const n=f.get(t);if(!n)return!1;const i=r(e);if(!i)return!1;const{bitfield:c}=i,{id:a}=n;return o(a,c)},getBuffer:()=>a.slice(0),removeComponentFromEntity:(e,t)=>{if(!i(t))return!1;const n=f.get(e);if(!n)return!1;const{maxEntities:r,schema:o}=e;return r&&o&&Object.keys(o).forEach((e=>{delete n[e][t]})),c(t,n),n.count=n.count-1,!0},setBuffer:e=>{if(e.byteLength!==a.byteLength)throw new Error("setBuffer - byteLength mismatch!");const t=new Uint8Array(e);return new Uint8Array(a).set(t),a.slice(0)}}}function A(e){const{capacity:t}=e,n=function(e){const t=[];return t.length=e,t}(t),r=u(t),o=function(e){return function(t){return i(t)&&t<=e}}(t);return{createEntity:()=>r.pop(),destroyEntity(e){if(!o(e))return!1;const t=n[e];return void 0!==t&&(E(e)(t),delete n[e],r.push(e),!0)},getEntityArchetype:e=>n[e],getVacancyCount:()=>r.length,hasEntity:e=>o(e)&&void 0!==n[e],isValidEntity:o,setEntityArchetype:(e,t)=>!!o(e)&&(n[e]=t,!0)}}function O({entities:e}){this.push(...e)}function B(e){const t=[];return e.archetypes.forEach(O,t),t}function j(e){const{createBitfieldFromIds:t,componentMap:n,isArchetypeCandidate:r}=e,o=new Map;function i(e){if(!function(e){if(!Array.isArray(e.all)||!Array.isArray(e.any)||!Array.isArray(e.none))return!1;const{any:t,all:n,none:r}=e;return[...n,...t,...r].every((e=>Object.prototype.hasOwnProperty.call(e,"name")))}(e))throw new Error("Object is not a valid query.");const r=function(e){const{createBitfieldFromIds:t,componentMap:n,query:r}=e,{all:o,any:i,none:c}=r,a=(e,t,r)=>{const o=n.get(t);if(!o)throw new Error(`Component ${t.name} not found.`);return e[r]=o,e},s=o.reduce(a,new Array(o.length)),u=t(s),f=i.reduce(a,new Array(i.length)),y=t(f),p=t(c.reduce(a,new Array(c.length))),d=[...s,...f].reduce(((e,t)=>(e[t.name]=t,e)),{});Object.freeze(d);const l=new Set;return Object.freeze(Object.assign(Object.create(r),{archetypes:l,and:u,components:d,not:p,or:y}))}({createBitfieldFromIds:t,componentMap:n,query:e});return o.set(e,r),r}return{queryMap:o,getQueryEntered:function(e){return function(e){return[...e.archetypes].flatMap((e=>[...e.entered]))}(o.get(e)??i(e))},getQueryExited:function(e){return function(e){return[...e.archetypes].flatMap((e=>[...e.exited]))}(o.get(e)??i(e))},getQueryResult:function(e){const t=o.get(e)??i(e);return[()=>B(t),t.components]},getQueryResults:function(...e){const t={},n=e.reduce(((e,n)=>{const r=o.get(n)??i(n);return Object.assign(t,r.components),e.push(r),e}),[]);return[()=>n.flatMap(B),Object.freeze(t)]},refreshQuery:function(e){return function(t){const n=r(t),o=e.filter(n),i=t.archetypes.add.bind(t.archetypes);return[...o].forEach(i),t}}}}const x=Object.freeze({version:"0.9.0"});function v(t){const{capacity:n,components:r}=function(t){if(!t)throw new SyntaxError("World creation requires a specification object.");const{capacity:n=e,components:r}=t;if(!i(n))throw new SyntaxError("World creation: spec.capacity invalid.");if(!r.length)throw new SyntaxError("World creation: spec.components invalid.");return{capacity:n,components:r}}(t),{EMPTY_BITFIELD:o,createBitfieldFromIds:c,isBitOn:a,toggleBit:s}=function(e){if(!i(e))throw new SyntaxError("Bitfield capacity is invalid.");const t=e+31>>>5,n=new Uint32Array(t),r=t=>isNaN(t)||t<0||t>e?-1:t>>>5;return{EMPTY_BITFIELD:n,createBitfieldFromIds:e=>e.reduce(((e,{id:t})=>{const n=r(t);if(-1===n)throw new SyntaxError(`Bitfield: bit ${t} does not exist in this world.`);return e[n]&=~(1<<t-32*n),e}),new Uint32Array(t)),isBitOn:(e,t)=>{const n=r(e);if(-1===n)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this world.`);const o=t[n];if(void 0===o)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this bitfield.`);return Boolean(o&1<<e-32*n)},toggleBit:(e,t)=>{const n=r(e);if(-1===n)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this world.`);if(void 0===t[n])throw new SyntaxError(`Bitfield: bit ${e} does not exist in this bitfield.`);return t[n]^=1<<e-32*n,t}}}(r.length),{createEntity:u,destroyEntity:f,getEntityArchetype:y,getVacancyCount:p,hasEntity:d,isValidEntity:l,setEntityArchetype:h}=A({capacity:n}),{archetypeMap:g,isArchetypeCandidate:w,purgeArchetypeCaches:O,refreshArchetype:B,updateArchetype:v}=function(e){const{EMPTY_BITFIELD:t,getEntityArchetype:n,setEntityArchetype:r,toggleBit:o}=e,i=m({bitfield:t}),c=new Map,a=(e,t)=>{const{bitfield:n,cloneCache:r}=e,i=r.get(t);if(i)return[i.id,()=>i];const{id:c}=t,a=n.slice();o(c,a);const s=a.toString();return[s,()=>{const e=m({bitfield:a,id:s});return r.set(t,e),e}]};return{archetypeMap:c,isArchetypeCandidate:e=>function(n){const{bitfield:r,candidateCache:o}=n;if(o.has(e))return o.get(e)||!1;const{and:i=t,or:c=t,not:a=t}=e,s=r.every(((e,t)=>{const n=i[t];return 0==(a[t]&e)&&(n&e)===n&&(c[t]&e)<=0}));return o.set(e,s),s},purgeArchetypeCaches:e=>{const{candidateCache:t,cloneCache:n}=e;return t.clear(),n.clear(),e},refreshArchetype:e=>{const{entered:t,exited:n}=e;return t.clear(),n.clear(),e.isDirty=!1,e},updateArchetype:(e,t)=>{const o=n(e);let s;if(o){E(e)(o);const[n,r]=a(o,t);c.has(n)?s=c.get(n):(s=r(),c.set(n,s))}else{const[e,n]=a(i,t);c.has(e)?s=c.get(e):(s=n(),c.set(e,s))}return function(e){return function(t){const{entities:n,entered:r}=t;return n.add(e),r.add(e),t.isDirty=!0,t}}(e)(s),r(e,s),s}}}({EMPTY_BITFIELD:o,getEntityArchetype:y,setEntityArchetype:h,toggleBit:s}),{componentMap:C,addComponentToEntity:S,entityHasComponent:_,getBuffer:M,removeComponentFromEntity:T,setBuffer:z}=b({capacity:n,components:r,getEntityArchetype:y,isBitOn:a,isValidEntity:l,updateArchetype:v}),{queryMap:P,getQueryEntered:Q,getQueryExited:I,getQueryResult:L,getQueryResults:F,refreshQuery:R}=j({createBitfieldFromIds:c,componentMap:C,isArchetypeCandidate:w}),{load:q,save:$}=function(e){const{getBuffer:t,setBuffer:n,version:r}=e;return{load:function(e){const{componentBuffer:t}=e;return r.match(e.version)||console.warn(`Miski version mismatch: Expected ${r}, found ${e.version}.`),n(t),!0},save:function(){return Object.freeze({componentBuffer:t(),version:r})}}}({getBuffer:M,setBuffer:z,version:"0.9.0"});function N(){[...g.values()].forEach(O)}function D(){const e=[...g.values()],t=R(e);P.forEach(t),e.forEach(B)}return N(),D(),Object.freeze(Object.assign(Object.create(x),{capacity:n,addComponentToEntity:S,createEntity:u,destroyEntity:f,entityHasComponent:_,getEntityArchetype:y,getQueryEntered:Q,getQueryExited:I,getQueryResult:L,getQueryResults:F,getVacancyCount:p,hasEntity:d,load:q,purgeCaches:N,refresh:D,removeComponentFromEntity:T,save:$}))}export{d as createComponent,l as createQuery,h as createSystem,v as createWorld};
//# sourceMappingURL=miski.min.js.map
