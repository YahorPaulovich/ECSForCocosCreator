/*! Miski v0.10.0. MIT license. (C) 2021-2022 P. Hughes<github@phugh.es>(https://www.phugh.es). All rights reserved. **/
const e=1e6,t=Object.freeze(["changed","component","count","eid","id","isTag","maxEntities","name","proxy","schema","size","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","prototype","toLocaleString","toString","valueOf","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupGetter__","__proto__"]),n=/^(?![0-9])[a-zA-Z0-9$_]+$/,r=Object.freeze([]),o=Symbol("EMPTY"),i=Symbol("changed"),c=Symbol("count"),s=Symbol("dirty");function a(e){return!isNaN(e)&&e>=0&&e<=4294967295}function u(e){return Boolean("function"==typeof e&&Object.prototype.hasOwnProperty.call(e,"BYTES_PER_ELEMENT"))}function f(e){return Boolean("string"==typeof e&&e.length>0&&!0===n.test(e)||!t.includes(e))}function y(e){return Boolean("object"==typeof e&&!Array.isArray(e))}function d(e){const t=e-1;return Array.from({length:e},((e,n)=>t-n))}function p(e=0,t=0){return e&t}const l=(h=4,e=>Math.ceil(e/h)*h);var h;function E(e){return y(e)&&Object.entries(e).every((([e,t])=>f(e)&&(e=>{if(!Array.isArray(e))return u(e);{const[t,n]=e;if(!isNaN(n)&&u(t))return!0}return!1})(t)))}function m(e,t){return e+(Array.isArray(t)?t[0].BYTES_PER_ELEMENT:t.BYTES_PER_ELEMENT)}function g(e){return l(Object.values(e).reduce(m,0))}function w(e){if(!e)throw new SyntaxError("createComponent: a specification object is required.");const{maxEntities:t,name:n,schema:r}=e;if(t&&(!a(t)||0===t))throw new SyntaxError("createComponent: maxEntities must be a Uint32 > 0.");if(!f(n))throw new SyntaxError("Component name is invalid.");if(r&&!E(r))throw new SyntaxError("createComponent: component schema is invalid.");return Object.freeze({maxEntities:t??null,isTag:Boolean(r),name:n,schema:r?Object.freeze({...r}):null,size:r?g(r):0})}function b(...e){const t=[],n=[],r=[];return e.forEach((e=>{const{all:o,any:i,none:c}=e;t.push(...o),n.push(...i),r.push(...c)})),x({all:t,any:n,none:r})}function A(e){return Object.prototype.hasOwnProperty.call(e,"name")}function x(e){if(!e)throw new SyntaxError("createQuery: specification object is required.");const{all:t=r,any:n=r,none:o=r}=e;if(![...t,...n,...o].every(A))throw new SyntaxError("createQuery: Query specification object is invalid.");return Object.freeze({all:Object.freeze([...new Set(t)]),any:Object.freeze([...new Set(n)]),none:Object.freeze([...new Set(o)])})}function B(e,t){return n=>{const[r,o]=n.getQueryResult(t);return(...t)=>e(r,o(),...t)}}function S(e){const{bitfield:t,id:n}=function(e){if(!e)throw new SyntaxError("Archetype: specification object required.");const{bitfield:t,id:n}=e;if(!t)throw new SyntaxError("Archetype: spec.bitfield is required.");return{bitfield:t,id:n||t.toString()}}(e);let r=!0;return{get[s](){return r},set[s](e){r=!!e},get isDirty(){return r},bitfield:t,candidateCache:new Map,cloneCache:new Map,components:new Set,entered:new Set,entities:new Set,exited:new Set,id:n}}function C(e){const{bitfield:t,candidateCache:n}=e;return e=>{if(n.has(e))return n.get(e)??!1;const r=function(e){const{and:t,or:n,not:r}=e;return(e,o)=>(0===n[o]||p(e,n[o])>0)&&(!(p(e,t[o])!==t[o])&&0===p(e,r[o]))}(e),o=t.every(r);return n.set(e,o),o}}function v(e){const{candidateCache:t,cloneCache:n}=e;return t.clear(),n.clear(),e}function O(e){const{EMPTY_BITFIELD:t,capacity:n,toggleBit:r}=e,o=new Map,i=[];i.length=n;const c=S,a=c({bitfield:t}),u=function(e,t){return(n,r)=>{const{bitfield:o,cloneCache:i}=n;if(!Array.isArray(r)){const e=i.get(r);if(e)return[e.id,()=>e];r=[r]}const c=o.slice(),s=r.reduce(((e,n)=>(t(n.id,c)&&e.push(n),e)),[]),a=c.toString();return[a,()=>{const t=e({bitfield:c,id:a});Array.isArray(r)||i.set(r,t);const o=e=>{s.includes(e)&&t.components.add(e)};return n.components.forEach(o),s.forEach(o),t}]}}(c,r),f=e=>i[e],y=(e,t)=>(delete i[e],function(e,t){const{entities:n,exited:r}=t;return n.delete(e),r.add(e),t[s]=!0,t}(e,t)),d=(e,t)=>i[e]=t;return{EMPTY_ARCHETYPE:a,createArchetype:c,getEntityArchetype:f,isArchetypeCandidate:C,purgeArchetypesCaches:()=>o.forEach(v),refreshArchetypes:e=>{o.forEach((t=>{!function(e){const{entered:t,exited:n}=e;t.clear(),n.clear(),e[s]=!1}(t);const n=C(t);e.forEach((e=>{e[s]=!1,n(e)&&(e[s]=!0,e.archetypes.add(t))}))}))},removeEntityFromArchetype:y,setEntityArchetype:d,updateArchetype:(e,t)=>{const n=f(e);n&&y(e,n);const[r,i]=u(n??a,t),c=o.get(r)??i();return o.set(r,c),function(e,t){const{entities:n,entered:r}=t;n.add(e),r.add(e),t[s]=!0}(e,c),d(e,c),c}}}function _(e,t){if(!e)throw new SyntaxError("Proxy can only be used on components, not tags.");let n=0;return Object.keys(e).reduce(((r,o)=>(Object.defineProperty(r,o,{get:()=>e[o][n],set(r){e[o][n]=r,t.add(n)}}),r)),{get eid(){return n},set eid(e){n=e}})}function j(e){return e[i].clear(),e}function M(e){const t=new Map,n=d(e.length);return new Proxy(e,{get:(n,r)=>{return i=r,e[t.get(i)??o];var i},set:(r,o,i)=>((r,o)=>{const i=t.get(r)??n.pop();return void 0!==i&&(e[i]=o,t.set(r,i),!0)})(o,i),deleteProperty:(r,o)=>(r=>{const o=t.get(r);return void 0!==o&&(e[o]=0,t.delete(r),n.push(o),!0)})(o)})}function T(e){const{components:t,partitioner:n}=e;return[...new Set(t)].reduce(((e,t,r)=>{const o=function(e){const{component:t,id:n,storage:r}=e;if(!t)throw new Error("Component instantiation requires as component!");if(!a(n))throw new SyntaxError("Component ID is invalid.");if(r&&!y(r))throw new TypeError("Component storage is malformed.");let o=0;const s=new Set,u=Object.create(t,{[i]:{value:s,configurable:!1,enumerable:!0,writable:!1},[c]:{get:()=>o,set(e){o=e}},changed:{get:()=>s.values(),configurable:!1,enumerable:!0},count:{get:()=>o,configurable:!1,enumerable:!0},id:{value:n,configurable:!1,enumerable:!0,writable:!1}});return r&&(Object.defineProperty(u,"proxy",{value:_(r,s),configurable:!1,enumerable:!0,writable:!1}),Object.assign(u,r)),Object.freeze(u)}({component:t,id:r,storage:n(t)});return e.set(t,o),e}),new Map)}function P(e,t){const n=function(e){const{capacity:t,components:n}=e,r=function(e,t){return t.reduce(((t,n)=>{const{size:r}=n;return!r||r<=0?t:t+r*e}),0)}(t,n);return new ArrayBuffer(8*Math.ceil(r/8))}({capacity:e,components:t}),r=function(e){const{buffer:t,capacity:n}=e;let r=0,o=!1;return e=>{if(!0===o)throw new Error("ArrayBuffer is full!");const{maxEntities:i,schema:c,size:s=0}=e;if(!c||s<=0)return;const a=i??n;if(r+s*a>t.byteLength)throw new Error("Component will not fit inside the buffer!");let u=0;const f=Object.entries(c).reduce(((e,[n,o])=>{let c=o,s=0;Array.isArray(o)&&([c,s]=o);const f=new c(t,r+u,a);return e[n]=null===i?f:M(f),0!==s&&e[n].fill(s),u=l(u+c.BYTES_PER_ELEMENT*a),e}),{});return r+=u,r>t.byteLength&&(o=!0),f}}({buffer:n,capacity:e});return[n,r]}const I=(e,t,n)=>{((e,t)=>{const{schema:n}=t;n&&Object.entries(n).forEach((([n,r])=>{Array.isArray(r)&&(t[n][e]=r[1]??0)}))})(e,t),n&&((e,t,n)=>{Object.entries(n).forEach((([n,r])=>{t[n][e]=r??0}))})(e,t,n)};function F(e){const{isValidEntity:t,getEntityArchetype:n,isBitOn:r}=e;return e=>{if(!t(e))throw new SyntaxError(`Entity ${e} is not valid!`);return t=>{const o=n(e);if(!o)throw new SyntaxError(`Archetype for Entity ${e} not found.`);const{count:i,id:s,maxEntities:a}=t;return r(s,o.bitfield)?t:a&&i>=a?null:(t[c]=i+1,t)}}}function z(e,t){const{updateArchetype:n}=e,{adder:r,getInstances:o}=t;return(...e)=>{const t=o(e);if(t.length!==e.length)throw new SyntaxError("Not all components are registered in the world!");return function(e,t,n){return(r,o={})=>{const i=e(r),c=n.map(i).filter((e=>e));return c.forEach((e=>I(r,e,o[e.name]))),t(r,c),c}}(r,n,t)}}function Y(e,t){const{updateArchetype:n}=e,{adder:r,getInstances:o}=t;return e=>{const t=o(e);if(!t)throw new SyntaxError(`Component ${e.name} is not registered in the world.`);return function(e,t,n){return(r,o)=>!e(r)(n)&&(I(r,n,o),t(r,n),!0)}(r,n,t)}}function L({getEntityArchetype:e}){return t=>{const n=e(t);if(!n)return{};const{components:r}=n;return[...r].reduce(((e,n)=>{const{name:r,schema:o}=n;return e[r]={},e[r]=null===o||Object.keys(o).reduce(((e,r)=>(e[r]=n[r][t],e)),{}),e}),{})}}function Q(e,t){const{getEntityArchetype:n,isBitOn:r}=e,{getInstances:o}=t;return e=>{const t=o(e);if(!t)throw new SyntaxError(`Component ${e.name} is not registered!`);return e=>{const o=n(e);return!!o&&r(t.id,o.bitfield)}}}function $(e,t){const{maxEntities:n,schema:r}=e;n&&r&&Object.keys(r).forEach((n=>{delete e[n][t]}))}function N(e,t){const{getEntityArchetype:n,isBitOn:r,updateArchetype:o}=e,{getInstances:i}=t;return e=>{const t=i(e);if(!t)throw new SyntaxError(`Component ${e.name} is not registered!`);return e=>{const i=n(e);return i&&!r(t.id,i.bitfield)||(t[c]=t[c]-1,$(t,e),o(e,t)),!0}}}function R(e,t){const{getInstances:n}=t,r=function(e){const{getEntityArchetype:t,isBitOn:n,updateArchetype:r}=e;return e=>o=>{const i=t(o),s=e.map((e=>{if(!i||n(e.id,i.bitfield))return e[c]=e[c]-1,$(e,o),e})).filter((e=>e));return r(o,s),s}}(e);return(...e)=>{const t=n(e);if(t.length!==e.length)throw new SyntaxError("Not all components were found!");return r(t)}}function q(e,t){const{getEntityArchetype:n}=e,{getInstances:r,isMatch:o}=t;return(...e)=>{const t=r(e),i=(e,r)=>{const i=n(r);if(!i)return e;const c=o(i);return t.every(c)&&e.push(r),e};return(...e)=>e.reduce(i,[])}}function D(e){const t=t=>e.get(t);return e=>Array.isArray(e)?e.map(t).filter((e=>e)):t(e)}function V(e){return({bitfield:t})=>({id:n})=>e(n,t)}function k(e){const{capacity:t,components:n,isBitOn:r}=e,[o,i]=P(t,n),[c,s]=function(e){return[()=>e.slice(0),t=>{if(t.byteLength!==e.byteLength)throw new Error("setBuffer - byteLength mismatch!");const n=new Uint8Array(t);return new Uint8Array(e).set(n),e.slice(0)}]}(o),a=T({components:n,partitioner:i}),u={adder:F(e),getInstances:D(a),isMatch:V(r)};return{componentMap:a,addComponentToEntity:Y(e,u),addComponentsToEntity:z(e,u),getEntityProperties:L(e),hasComponent:Q(e,u),getBuffer:c,removeComponentFromEntity:N(e,u),removeComponentsFromEntity:R(e,u),setBuffer:s,withComponents:q(e,u)}}function U(e){const{capacity:t,EMPTY_ARCHETYPE:n,getEntityArchetype:r,removeEntityFromArchetype:o,setEntityArchetype:i}=e,c=d(t),s=function(e){return function(t){return a(t)&&t<=e}}(t);return{createEntity(){const e=c.pop();return void 0!==e&&i(e,n),e},destroyEntity(e){if(!s(e))return!1;const t=r(e);return!!t&&(o(e,t),c.push(e),!0)},getVacancyCount:()=>c.length,hasEntity:e=>s(e)&&void 0!==r(e),isValidEntity:s}}function H({entities:e}){this.push(...e)}function G(e){const{createBitfieldFromIds:t,componentMap:n}=e,o=new Map,i=new Map,c=e=>{if(!function(e){const{any:t=r,all:n=r,none:o=r}=e;return[...n,...t,...o].every(A)}(e))throw new Error("Object is not a valid query.");const i=function(e){const{createBitfieldFromIds:t,componentMap:n,query:r}=e,{all:o,any:i,none:c}=r,a=(e,t,r)=>{const o=n.get(t);if(!o)throw new Error(`Component ${t.name} not found.`);return e[r]=o,e},u=o.reduce(a,new Array(o.length)),f=t(u),y=i.reduce(a,new Array(i.length)),d=t(y),p=t(c.reduce(a,new Array(c.length))),l=[...u,...y].reduce(((e,t)=>(e[t.name]=t,e)),{});Object.freeze(l);const h=new Set;let E=!0;return Object.assign(Object.create(r),{get[s](){return E},set[s](e){E=!!e},get isDirty(){return E},archetypes:h,and:f,components:l,not:p,or:d})}({createBitfieldFromIds:t,componentMap:n,query:e});return o.set(e,i),i},a=e=>o.get(e)??c(e);return{queryMap:o,getQueryEntered:e=>function(e){return[...e.archetypes].flatMap((e=>[...e.entered]))}(a(e)),getQueryExited:e=>function(e){return[...e.archetypes].flatMap((e=>[...e.exited]))}(a(e)),getQueryResult:e=>{const t=a(e);return[t.components,()=>function(e,t){const{archetypes:n}=e;if(!t.has(e)){const r=[];return n.forEach(H,r),t.set(e,new Set(r)),r}const r=t.get(e),o=e=>r.add(e),i=e=>r.delete(e);if(e.isDirty){const e=[];return n.forEach(H,e),e.forEach(o),e}return n.forEach((e=>{e.entered.forEach(o),e.exited.forEach(i)})),[...r]}(t,i)]}}}function W(t){const{capacity:n,components:r}=function(t){if(!t)throw new SyntaxError("World creation requires a specification object.");const{capacity:n=e,components:r}=t;if(!a(n))throw new SyntaxError("World creation: spec.capacity invalid.");if(!r.length)throw new SyntaxError("World creation: spec.components invalid.");return{capacity:n,components:r}}(t),{EMPTY_BITFIELD:o,createBitfieldFromIds:i,isBitOn:c,toggleBit:s}=function(e){if(!a(e))throw new SyntaxError("Bitfield capacity is invalid.");const t=e+31>>>5,n=new Uint32Array(t),r=t=>isNaN(t)||t<0||t>e?-1:t>>>5;return{EMPTY_BITFIELD:n,createBitfieldFromIds:e=>e.reduce(((e,{id:t})=>{const n=r(t);if(-1===n)throw new SyntaxError(`Bitfield: bit ${t} does not exist in this world.`);return e[n]&=~(1<<t-32*n),e}),new Uint32Array(t)),isBitOn:(e,t)=>{const n=r(e);if(-1===n)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this world.`);const o=t[n];if(void 0===o)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this bitfield.`);return Boolean(o&1<<e-32*n)},toggleBit:(e,t)=>{const n=r(e);if(-1===n)throw new SyntaxError(`Bitfield: bit ${e} does not exist in this world.`);if(void 0===t[n])throw new SyntaxError(`Bitfield: bit ${e} does not exist in this bitfield.`);return t[n]^=1<<e-32*n,Boolean(t[n]&1<<e-32*n)}}}(r.length),{EMPTY_ARCHETYPE:u,getEntityArchetype:f,purgeArchetypesCaches:y,refreshArchetypes:d,removeEntityFromArchetype:p,setEntityArchetype:l,updateArchetype:h}=O({EMPTY_BITFIELD:o,capacity:n,toggleBit:s}),{createEntity:E,destroyEntity:m,getVacancyCount:g,hasEntity:w,isValidEntity:b}=U({capacity:n,EMPTY_ARCHETYPE:u,getEntityArchetype:f,removeEntityFromArchetype:p,setEntityArchetype:l}),{componentMap:A,addComponentsToEntity:x,addComponentToEntity:B,getBuffer:S,getEntityProperties:C,hasComponent:v,removeComponentFromEntity:_,removeComponentsFromEntity:M,setBuffer:T,withComponents:P}=k({capacity:n,components:r,getEntityArchetype:f,isBitOn:c,isValidEntity:b,updateArchetype:h}),{queryMap:I,getQueryEntered:F,getQueryExited:z,getQueryResult:Y}=G({createBitfieldFromIds:i,componentMap:A}),{load:L,save:Q}=function(e){const{getBuffer:t,setBuffer:n,version:r}=e;return{load:function(e){const{componentBuffer:t}=e;return n(t),!0},save:function(){return Object.freeze({componentBuffer:t(),version:r})}}}({getBuffer:S,setBuffer:T,version:"0.10.0"}),$=()=>{y()};$();const N=()=>{d(I),A.forEach(j)};return N(),Object.freeze({capacity:n,version:"0.10.0",addComponentsToEntity:x,addComponentToEntity:B,createEntity:E,destroyEntity:m,getEntityArchetype:f,getEntityProperties:C,getQueryEntered:F,getQueryExited:z,getQueryResult:Y,getVacancyCount:g,hasComponent:v,hasEntity:w,load:L,purgeCaches:$,refresh:N,removeComponentFromEntity:_,removeComponentsFromEntity:M,save:Q,withComponents:P})}export{w as createComponent,x as createQuery,B as createSystem,W as createWorld,b as mergeQueries};
//# sourceMappingURL=miski.min.js.map
