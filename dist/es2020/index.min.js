/*! *****************************************************************************
 *
 * miski
 * v0.5.0
 *
 * MIT License
 * 
 * Copyright (C) 2021 Peter Hughes<https://www.phugh.es>, all rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
***************************************************************************** */
async function indexOf(e,t){for(let r=0,n=e.length;r!=n;r++)if(e[r]===t)return Promise.resolve(r);return Promise.resolve(-1)}function spliceOne(e,t){const r=e.length;if(!r)return e;for(;t<r;)e[t]=e[t+1],t++;return e.length=e.length-1,e}function isObject(e){return Boolean("object"==typeof e&&!Array.isArray(e))}function systemNoop(e){}const e=/^(?![0-9])[a-zA-Z0-9$_]+$/;function isValidName(r){return"string"==typeof r&&((r=r.trim()).length>0&&e.test(r)&&!t.has(r))}const t=new Set(["entities","id","instances","name","schema","world","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","prototype","toLocaleString","toString","valueOf","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupGetter__","__proto__"]);function createQuery(e){if(!e)throw new Error("Query spec object required.");const{all:t=[],any:r=[],none:n=[]}=e;return{instances:[],all:[...t],any:[...r],none:[...n]}}function isQueryCandidate(e,t){for(let r=0,n=e.and.length;r<n;r++){const n=t.mask[r];if(0!=(e.not[r]&n))return!1;if((e.and[r]&n)!==e.and[r])return!1;if((e.or[r]&n)>0)return!1}return function addArchetypeToQuery(e,t){return-1!==e.archetypes.indexOf(t)||e.archetypes.push(t),e}(e,t),!0}function removeArchetypeFromQuery(e,t){const r=e.archetypes.indexOf(t);return-1===r||spliceOne(e.archetypes,r),e}function _getComponents(e){return[...e.components]}function getComponentsFromQuery(e){return e.archetypes.flatMap(_getComponents).reduce(((e,t)=>(e[t.name]=t,e)),{})}function _getEntities(e){return[...e.entities]}function getEntitiesFromQuery(e){return e.archetypes.flatMap(_getEntities)}async function updateEntityArchetype(e,t,r,n=!1){const{archetypes:i,entities:a,queries:o}=e,s=[...o.values()];let u=[];const m=a[t];if(m&&(m.entities.delete(t),u=[...m.components],0===m.entities.size)){const _removeArchetype=e=>removeArchetypeFromQuery(e,m);await Promise.all(s.map(_removeArchetype)),delete i[m.name]}if(r)if(!1===n)u.push(r);else{const e=u.indexOf(r);e>-1&&spliceOne(u,e)}const c=await async function createArchetype(e,...t){const r=await createBitmaskFromComponents(e,...t);return{components:new Set(t),entities:new Set,mask:r,name:r.toString()}}(e,...u);let y;if(c.name in i){if(y=i[c.name],void 0===y)throw new Error("Could not get archetype")}else{y=c,i[y.name]=y;const _isMatch=e=>isQueryCandidate(e,y);await Promise.all(s.map(_isMatch))}return y.entities.add(t),a[t]=y,y}function isValidSchema(e){if(!e)return!1;return isObject(e)}function getDataFromStore(e,t){return e[t]}function setDataInStore(e,t,r){if(t<0||t>e.length)throw new SyntaxError("Entity is out of range.");if(!e.guard(r))throw new TypeError("Value is not correct type.");return e[t]=r,e}function defineDataStore(e){const{name:t,initial:r,guard:n,arrayType:i=Array,prefill:a=!1}=e;if(!t||!n)throw new SyntaxError("Invalid datastore spec - mandatory properties missing.");if(!isValidName(t))throw new Error("Invalid name.");const o=r();if(!n(o))throw new TypeError("Initial property is of invalid type. Make sure guard(initial()) returns true.");const s=new i,u=function isTypedArray(e){return Boolean(ArrayBuffer.isView(e)&&!(e instanceof DataView))}(s);if(u&&("number"!=typeof o||Number.isNaN(o)))throw new TypeError(`Initial property for typed array type must be a number. Found ${typeof o}.`);return Object.create(Object.getPrototypeOf(s),{getProp:{value:function(e){return this[e]},enumerable:!0},setProp:{value:function(e,t){if(e<0||e>this.length)throw new SyntaxError("Entity is out of range.");if(!this.guard(t))throw new TypeError("Property is not correct type.");return this[e]=t,this},enumerable:!0},arrayType:{value:i,enumerable:!0},guard:{value:n,enumerable:!0},initial:{value:r,enumerable:!0},isTypedArray:{value:u,enumerable:!0},name:{value:t,enumerable:!0},prefill:{value:a,enumerable:!0}})}function createDataStorage(e,t){const{arrayType:r,initial:n,prefill:i}=t,a=new r(e.spec.maxEntities);return Object.setPrototypeOf(a,t),!0===i&&a.fill(n()),a.world=e,a}async function createBitmaskFromComponents(e,...t){const r=function createBitmask(e=32){return new Uint32Array(Math.ceil(e/32))}(e.spec.maxComponents||32);if(!t.length)return r;return await Promise.all(t.map((t=>{if(t.world.id!==e.id)throw new Error("Components are not from the same world.");!function setBitOn(e,t){if(!function isValidBit(e,t){return!(t<0||t>function getMaxBit(e){return 32*e.length}(e))}(e,t))throw new SyntaxError(`Bit ${t} does not exist on mask.`);return e[Math.floor(t/32)]|=1<<t%32,e}(r,t.id)}))),r}function createComponent(e){if(!e)throw new SyntaxError("Component creation requires a specification object.");const{name:t,schema:r}=e;if(!isValidName(t))throw new SyntaxError("Component name is invalid.");if(!isValidSchema(r))throw new SyntaxError("Component schema is invalid.");return{instances:[],name:t,schema:r}}async function registerComponent(e,t){if(!e)throw new SyntaxError("Component registration requires a World object.");if(!t)throw new SyntaxError("Component registration requires a Component object.");const{instances:r,name:n,schema:i}=t,{components:a}=e;if(n in a)throw new Error(`Component with name "${n}" is already registered.`);const o=await indexOf(a,void 0);if(-1===o)throw new Error("Maximum components reached.");const s=Object.create(t,{entities:{value:new Set,enumerable:!0},id:{value:o,configurable:!1,enumerable:!0,writeable:!1},world:{value:e,configurable:!1,enumerable:!0,writeable:!1}});return await Promise.all(Object.entries(i).map((([t,r])=>{if(!isValidName(t))throw new SyntaxError(`Property name "${String(t)}" is invalid or forbidden.`);Object.defineProperty(s,t,{value:createDataStorage(e,r),configurable:!1,enumerable:!0,writable:!1})}))),r.push(s),a[o]=s,s}async function unregisterComponent(e){if(!e)throw new SyntaxError("Component instance required.");const{id:t,name:r,world:n}=e,{components:i}=n,a=i[t];if(!a||e!==a)throw new Error(`Component "${r}" does not exist in this world.`);return await Promise.all([...a.entities].map((e=>removeComponentFromEntity(a,e)))),delete i[t],n}async function addComponentToEntity(e,t,r){if(!e)throw new SyntaxError("Component instance required.");if("number"!=typeof t)throw new SyntaxError("Invalid or undefined entity provided.");const{id:n,name:i,schema:a,world:o}=e,{spec:s,components:u}=o;if(t<0||t>s.maxEntities)throw new Error(`Invalid entity provided: "${t}".`);const m=u[n];if(!m||e!==m)throw new Error(`Component "${i}" does not exist in this world.`);if(m.entities.has(t))throw new Error(`Entity "${t}" already has component "${i}".`);if(m.entities.add(t),r){const _resetData=e=>setDataInStore(m[e],t,r[e]);await Promise.all(Object.keys(a).map(_resetData))}return await updateEntityArchetype(o,t,m,!1),e}async function removeComponentFromEntity(e,t){if(!e)throw new SyntaxError("Component instance required.");if("number"!=typeof t)throw new SyntaxError("Invalid or undefined entity provided.");const{id:r,name:n,schema:i,world:a}=e,{spec:o,components:s}=a;if(t<0||t>o.maxEntities)throw new Error(`Invalid entity provided: "${t}".`);const u=s[r];if(void 0===u||e!==u)throw new Error(`Component "${n}" does not exist in this world.`);if(!u.entities.has(t))throw new Error(`Entity "${t}" does not have component "${n}" to remove.`);u.entities.delete(t);return await Promise.all(Object.keys(i).map((e=>function resetDataInStore(e,t){const{initial:r,isTypedArray:n,prefill:i}=e;if(t<0||t>e.length)throw new SyntaxError("Entity is out of range.");try{delete e[t]}catch(r){if(!n)throw new Error(r);e[t]=0}return!0===i&&(e[t]=r()),e}(u[e],t)))),await updateEntityArchetype(a,t,e,!0),e}async function createEntity(e){if(!e)throw new SyntaxError("Entity creation requires a World object.");const t=await indexOf(e.entities,void 0);if(-1===t)throw new Error("Maximum entities reached.");return await updateEntityArchetype(e,t),t}async function destroyEntity(e,t){if(!e)throw new SyntaxError("Entity destruction requires a World object.");if("number"!=typeof t)throw new SyntaxError("Invalid or undefined entity provided.");const{archetypes:r,spec:n,entities:i,queries:a}=e;if(t<0||t>n.maxEntities)throw new Error("Entity is out of range.");const o=i[t];if(delete i[t],void 0===o)return e;if(o.entities.delete(t),0===o.entities.size){const _removeArchetype=e=>removeArchetypeFromQuery(e,o);await Promise.all([...a.values()].map(_removeArchetype)),delete r[o.name]}return e}const _filterEnabled=e=>!0===e.enabled;function runPreSystems(e){[...e.systems].filter(_filterEnabled).forEach((e=>e.pre(getEntitiesFromQuery(e.query))))}function runPostSystems(e,t=1){[...e.systems].filter(_filterEnabled).forEach((e=>{e.post(getEntitiesFromQuery(e.query),getComponentsFromQuery(e.query),t)}))}function runUpdateSystems(e,t=0){[...e.systems].filter(_filterEnabled).forEach((e=>{e.update(getEntitiesFromQuery(e.query),getComponentsFromQuery(e.query),t)}))}function createSystem(e){const{name:t,pre:r=systemNoop,post:n=systemNoop,update:i=systemNoop}=e;if(!isValidName(t))throw new SyntaxError("System name is invalid.");return{instances:[],name:t,post:n,pre:r,update:i}}async function registerSystem(e,t,r){const{systems:n}=e,i=await async function createQueryInstance(e,t){const{archetypes:r,components:n,queries:i}=e;if(i.has(t))return i.get(t);const _getInstance=async e=>{const t=await indexOf(n,e);if(-1===t)throw new Error("ComponentInstance not found.");return n[t]},[a,o,s]=await Promise.all([await Promise.all(t.all.map(_getInstance)),await Promise.all(t.any.map(_getInstance)),await Promise.all(t.none.map(_getInstance))]),[u,m,c]=await Promise.all([await createBitmaskFromComponents(e,...a),await createBitmaskFromComponents(e,...o),await createBitmaskFromComponents(e,...s)]),y={archetypes:[],and:u,or:m,not:c,world:e};return await Promise.all(Object.values(r).map((e=>isQueryCandidate(y,e)))),i.set(t,y),y}(e,r);let a=!1;const o=Object.create(t,{enabled:{get:()=>a,set(e){a=e},configurable:!1,enumerable:!0},query:{value:i,configurable:!1,enumerable:!0,writeable:!1},world:{value:e,configurable:!1,enumerable:!0,writeable:!1}});return t.instances.push(o),n.push(o),o}async function unregisterSystem(e){const{world:t}=e,{systems:r}=t,n=await indexOf(r,e);return void 0===n||spliceOne(r,n),t}function enableSystem(e){return e.enabled=!0,e}function disableSystem(e){return e.enabled=!1,e}function isSystemEnabled(e){return e.enabled}function numberGuard(e){return"number"==typeof e&&!Number.isNaN(e)}function initToZero(){return 0}const r=defineDataStore({guard:e=>!0,initial:()=>{},name:"any"}),n=defineDataStore({arrayType:Int8Array,guard:numberGuard,initial:initToZero,name:"i8"}),i=defineDataStore({arrayType:Uint8Array,guard:numberGuard,initial:initToZero,name:"ui8"}),a=defineDataStore({arrayType:Uint8ClampedArray,guard:numberGuard,initial:initToZero,name:"ui8c"}),o=defineDataStore({arrayType:Int16Array,guard:numberGuard,initial:initToZero,name:"i16"}),s=defineDataStore({arrayType:Uint16Array,guard:numberGuard,initial:initToZero,name:"ui16"}),u=defineDataStore({arrayType:Int32Array,guard:numberGuard,initial:initToZero,name:"i32"}),m=defineDataStore({arrayType:Uint32Array,guard:numberGuard,initial:initToZero,name:"ui32"}),c=defineDataStore({arrayType:BigInt64Array,guard:numberGuard,initial:initToZero,name:"i64"}),y=defineDataStore({arrayType:BigUint64Array,guard:numberGuard,initial:initToZero,name:"ui64"}),l=defineDataStore({arrayType:Float32Array,guard:numberGuard,initial:initToZero,name:"f32"}),d=defineDataStore({arrayType:Int32Array,guard:numberGuard,initial:initToZero,name:"f64"}),f=defineDataStore({guard:e=>Array.isArray(e),initial:()=>[],name:"array"}),p=defineDataStore({guard:e=>"boolean"==typeof e,initial:()=>!1,name:"boolean"}),w=defineDataStore({guard:e=>"function"==typeof e,initial:()=>()=>{},name:"function"}),h=defineDataStore({guard:numberGuard,initial:initToZero,name:"number"}),b=defineDataStore({guard:e=>isObject(e),initial:()=>({}),name:"object"}),g=defineDataStore({guard:e=>"string"==typeof e,initial:()=>"",name:"string"}),E=128,S=1e4,v={maxComponents:E,maxEntities:S};function createWorld(e=v){const{maxComponents:t=E,maxEntities:r=S}=e;return{archetypes:{},components:new Array(t),entities:new Array(r),id:`${Date.now().toString(36)}_${Math.random().toString(36).substr(2,9)}`,queries:new Map,spec:Object.freeze({maxComponents:t,maxEntities:r}),systems:[]}}export{addComponentToEntity,r as any,f as array,p as boolean,createComponent,createEntity,createQuery,createSystem,createWorld,defineDataStore,destroyEntity,disableSystem,enableSystem,l as f32,d as f64,w as fnc,getDataFromStore,o as i16,u as i32,c as i64,n as i8,initToZero,isSystemEnabled,isValidName,isValidSchema,h as number,numberGuard,b as object,registerComponent,registerSystem,removeComponentFromEntity,runPostSystems,runPreSystems,runUpdateSystems,setDataInStore,g as string,s as ui16,m as ui32,y as ui64,i as ui8,a as ui8c,unregisterComponent,unregisterSystem};
//# sourceMappingURL=index.min.js.map
