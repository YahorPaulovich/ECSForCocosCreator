{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/archetype/archetype.ts","../src/bitfield.ts","../src/component/manager.ts","../src/component/instance.ts","../src/component/buffer.ts","../src/entity.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts","../src/archetype/manager.ts","../src/serialize.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport * as pkg from \"../package.json\";\n\n/** Miski version */\nexport const VERSION: string = pkg.version;\n\n/** Default maximum entities value */\nexport const DEFAULT_MAX_ENTITIES = 1_000_000;\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties\n  \"component\",\n  \"id\",\n  \"isTag\",\n  \"name\",\n  \"schema\",\n  \"size\",\n  // object properties\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** The number 8 - to avoid magic numbers */\nexport const ONE_BYTE = 8;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"./constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    (typeof str === \"string\" && str.length > 0 && VALID_NAME_PATTERN.test(str) === true) ||\n      !FORBIDDEN_NAMES.includes(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/** An empty function for use in Systems */\nexport function noop(): void {\n  return void 0;\n}\n\n/** @author https://stackoverflow.com/a/67605309 */\nexport type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isTypedArrayConstructor, isValidName, TypedArray, TypedArrayConstructor } from \"../utils.js\";\n\n/** The interface available to end users */\nexport type SchemaProps<T> = Record<keyof T, number>;\n\n/** Component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n * Values in the array are initialised to 0 by default.\n * To set your own default value: `{ property: [Int8Array, default value] }`.\n */\nexport type Schema<T> = Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Schema type guard */\nexport function isValidSchema<T>(schema: unknown): schema is Schema<T> {\n  const _validateProps = (value: TypedArrayConstructor | [TypedArrayConstructor, number]) => {\n    if (Array.isArray(value)) {\n      const [a, b] = value;\n      if (!isNaN(b) && isTypedArrayConstructor(a)) return true;\n    } else {\n      return isTypedArrayConstructor(value);\n    }\n    return false;\n  };\n  const _validate = ([name, value]: [string, unknown]) => {\n    return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n  };\n  return isObject(schema) && Object.entries(schema).every(_validate);\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/** @returns the size in bytes that a component's storage requires for one entity */\nexport function calculateSchemaSize<T>(schema: Schema<T>): number {\n  return Object.values(schema).reduce(byteSum, 0) as number;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isValidName } from \"../utils.js\";\nimport { ComponentInstance } from \"./instance.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\n/** { [component name]: component instance } */\nexport type ComponentRecord = Record<string, ComponentInstance<unknown>>;\n\nexport interface ComponentSpec<T> {\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport interface Component<T> {\n  /** `true` if the component has no schema */\n  isTag: boolean;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  size: number;\n}\n\n/**\n * Define a new component.\n * @param spec the component's specification.\n * @param spec.name the component's string identifier.\n * @param spec.schema the component's optional schema object.\n * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n */\nexport function createComponent<T extends Schema<T>>(spec: ComponentSpec<T>): Component<T> {\n  if (!spec) throw new SyntaxError(\"Component creation requires a specification object.\");\n  const { name, schema } = spec;\n  if (!isValidName(name)) throw new SyntaxError(\"Component name is invalid.\");\n  if (schema && !isValidSchema(schema)) throw new SyntaxError(\"Component schema is invalid.\");\n  return Object.freeze({\n    isTag: schema ? false : true,\n    name,\n    schema: schema ? Object.freeze({ ...schema }) : null,\n    size: schema ? calculateSchemaSize(schema) : 0,\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Readonly<Component<unknown>[]>;\n}\n\n/** Queries are groupings of archetypes */\nexport interface Query {\n  /** AND - Gather entities as long as they have all these components */\n  all: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none: Readonly<Component<unknown>[]>;\n}\n\nexport function isValidQuery(object: unknown): object is Query {\n  if (\n    !Array.isArray((object as Query).all) ||\n    !Array.isArray((object as Query).any) ||\n    !Array.isArray((object as Query).none)\n  ) {\n    return false;\n  }\n  const { any, all, none } = object as Query;\n  const _validateComponent = <T>(component: Component<T>) => Object.prototype.hasOwnProperty.call(component, \"name\");\n  return [...all, ...any, ...none].every(_validateComponent);\n}\n\n/**\n * Create a new Query\n * @param spec The Query's specification object\n * @param spec.all AND - Gather entities as long as they have all these components\n * @param spec.any OR - Gather entities as long as they have 0...* of these components\n * @param spec.none NOT - Gather entities as long as they don't have these components\n * @returns a valid Query object\n */\nexport function createQuery(spec: QuerySpec): Readonly<Query> {\n  if (!spec) throw new SyntaxError(\"createQuery: specification object is required.\");\n  const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n  if (![...all, ...any, ...none].every((component) => Object.prototype.hasOwnProperty.call(component, \"name\"))) {\n    throw new SyntaxError(\"Query specification object is invalid.\");\n  }\n  return Object.freeze({\n    all: Object.freeze([...all]),\n    any: Object.freeze([...any]),\n    none: Object.freeze([...none]),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ParametersExceptFirst } from \"./utils.js\";\nimport { World } from \"./world.js\";\n\n/** A multi-arity function where the first parameter is always the World object */\nexport type System<T extends (world: World, ...args: any[]) => ReturnType<T>, U extends ParametersExceptFirst<T>> = (\n  world: World,\n  ...args: U\n) => ReturnType<T>;\n\n/**\n * Creates a new curried System function\n * @param callback the System function to be called\n * @returns a curried function (world) => (...args) => result;\n *\n * @example\n * const world = {} as World;\n * const log = (world: World, value: string) => console.log(value);\n * const logSystem = createSystem(log);\n * const logSystemInstance = logSystem(world);\n * logSystemInstance(\"hello, world!\"); // hello, world!\n */\nexport function createSystem<\n  T extends (world: World, ...args: any[]) => ReturnType<T>,\n  U extends ParametersExceptFirst<T>,\n>(callback: System<T, U>) {\n  return function (world: World) {\n    return function (...args: U): ReturnType<T> {\n      return callback(world, ...args);\n    };\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * Archetypes are unique groupings of Entities by Components\n * An archetype must have:\n *  - A unique ID\n *  - A Set of Entity inhabitants\n *  - A way of knowing which Components are represented (Bitfield)\n *  - A way of checking if a QueryInstance matches the Archetype's Components\n */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\nimport { Entity } from \"../entity.js\";\nimport { QueryData } from \"../query/instance.js\";\n\nexport interface ArchetypeSpec {\n  /** The Bitfield */\n  bitfield: Bitfield;\n  /** Optional */\n  id?: string;\n}\n\nexport interface Archetype {\n  /** The Archetype's Component Bitfield */\n  bitfield: Bitfield;\n  /** Entities which have entered this archetype since last refresh */\n  entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  exited: Set<Entity>;\n  /** The Archetype's unique ID */\n  id: string;\n  /** Add an entity to the inhabitants list */\n  addEntity: (entity: Entity) => Archetype;\n  /** Get the ID of an archetype based on this with a toggled component */\n  cloneInStep: <T>(component: ComponentInstance<T>) => [string, () => Archetype];\n  /** @returns a clone on this archetype */\n  cloneWithToggle: <T>(component: ComponentInstance<T>) => Archetype;\n  /** @returns an iterator of Entities which inhabit this Archetype */\n  getEntities: () => IterableIterator<Entity>;\n  /** @returns `true` if the Entity inhabits this Archetype */\n  hasEntity: (entity: Entity) => boolean;\n  /** @returns `true` if the query criteria match this archetype */\n  isCandidate: (query: QueryData) => boolean;\n  /** Purge various archetype related caches */\n  purge: () => void;\n  /** Remove an entity from the inhabitants list */\n  removeEntity: (entity: Entity) => Archetype;\n  /** Run archetype maintenance functions */\n  refresh: () => void;\n}\n\nfunction validateSpec(spec: ArchetypeSpec): Required<ArchetypeSpec> {\n  if (!spec) throw new SyntaxError(\"Archetype: specification object required.\");\n  const { bitfield, id } = spec;\n  if (!bitfield) throw new SyntaxError(\"Archetype: spec.bitfield is required.\");\n  return { bitfield, id: id || bitfield.toString() };\n}\n\nfunction entityFns(state: Archetype) {\n  const { entities, entered, exited } = state;\n  return {\n    /** Add an entity to the inhabitants list */\n    addEntity: function (entity: Entity): Archetype {\n      entities.add(entity);\n      entered.add(entity);\n      return state;\n    },\n    /** @returns an array of Entities which inhabit this Archetype */\n    getEntities: function (): IterableIterator<Entity> {\n      return entities.values();\n    },\n    /** @returns `true` if the Entity inhabits this Archetype */\n    hasEntity: function (entity: Entity): boolean {\n      return entities.has(entity);\n    },\n    /** Remove an entity from the inhabitants list */\n    removeEntity: function (entity: Entity): Archetype {\n      entities.delete(entity);\n      exited.add(entity);\n      return state;\n    },\n  };\n}\n\nfunction cloner(state: Archetype) {\n  const { bitfield } = state;\n  const cache: Map<ComponentInstance<unknown>, Archetype> = new Map();\n  return {\n    cloneInStep: function <T>(component: ComponentInstance<T>): [string, () => Archetype] {\n      if (cache.has(component)) {\n        const cached = cache.get(component)!;\n        return [cached.id, () => cached];\n      } else {\n        const { id } = component;\n        const bitfieldCopy = bitfield.copy().toggle(id);\n        const bitfieldId = bitfieldCopy.toString();\n        return [\n          bitfieldId,\n          function () {\n            const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldId });\n            cache.set(component, clone);\n            return clone;\n          },\n        ];\n      }\n    },\n    /** @returns a clone on this archetype */\n    cloneWithToggle: function <T>(component: ComponentInstance<T>): Archetype {\n      if (cache.has(component)) return cache.get(component)!;\n      const { id } = component;\n      const bitfieldCopy = bitfield.copy().toggle(id);\n      const clone = createArchetype({ bitfield: bitfieldCopy });\n      cache.set(component, clone);\n      return clone;\n    },\n    purgeCloneCache: function () {\n      return cache.clear();\n    },\n  };\n}\n\nfunction candidateChecker(state: Archetype) {\n  const { bitfield } = state;\n  const _bitfield = bitfield.array;\n  const cache: Map<QueryData, boolean> = new Map();\n  return {\n    /** @returns `true` if the query criteria match this archetype */\n    isCandidate: function (query: QueryData): boolean {\n      if (cache.has(query)) return cache.get(query) || false;\n      const { and, or, not } = query;\n      const _not = not?.array ?? EMPTY_ARRAY;\n      const _and = and?.array ?? EMPTY_ARRAY;\n      const _or = or?.array ?? EMPTY_ARRAY;\n      function checkStatus(target: number, i: number): boolean {\n        // is ?? 0 right here??\n        const _n = _not[i] ?? 0;\n        const _a = _and[i] ?? 0;\n        const _o = _or[i] ?? 0;\n        if ((_n & target) !== 0) return false;\n        if ((_a & target) !== _a) return false;\n        if ((_o & target) > 0) return false;\n        return true;\n      }\n      const status = _bitfield.every(checkStatus);\n      cache.set(query, status);\n      return status;\n    },\n    purgeCandidateCache: function () {\n      return cache.clear();\n    },\n  };\n}\n\n/** Archetypes are unique groupings of entities by components */\nexport function createArchetype(spec: ArchetypeSpec): Archetype {\n  const { bitfield, id } = validateSpec(spec);\n  const entered: Set<Entity> = new Set();\n  const entities: Set<Entity> = new Set();\n  const exited: Set<Entity> = new Set();\n  const data = { bitfield, entered, entities, exited, id } as Archetype;\n  const { addEntity, getEntities, removeEntity } = entityFns(data);\n  const { cloneInStep, cloneWithToggle, purgeCloneCache } = cloner(data);\n  const { isCandidate, purgeCandidateCache } = candidateChecker(data);\n  const refresh = () => {\n    entered.clear();\n    exited.clear();\n  };\n  const purge = () => {\n    purgeCandidateCache();\n    purgeCloneCache();\n  };\n  return Object.freeze(\n    Object.assign(data, {\n      addEntity,\n      cloneInStep,\n      cloneWithToggle,\n      getEntities,\n      isCandidate,\n      purge,\n      refresh,\n      removeEntity,\n    }),\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\nimport { isTypedArray, isUint32 } from \"./utils.js\";\n\nexport interface BitfieldSpec {\n  /** The number of bits/flags required */\n  capacity: number;\n  /** Optional pre-created bitfield array (avoids new array generation) */\n  array?: Uint32Array;\n}\n\nexport interface Bitfield {\n  /** The size of the bitfield */\n  capacity: number;\n  /** The underlying bit array */\n  array: Uint32Array;\n  /**\n   * Set all bits to 0\n   * @returns `true` if the bitfield array was cleared successfully\n   */\n  clear: () => Bitfield;\n  /** @returns a new Bitfield based on this Bitfield */\n  copy: () => Bitfield;\n  /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n  isOn: (bit: number) => boolean;\n  /**\n   * Set a bit 'off' (e.g., falsy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  off: (bit: number) => Bitfield;\n  /**\n   * Set a bit 'on' (e.g., truthy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  on: (bit: number) => Bitfield;\n  /**\n   * Toggle a bit in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  toggle: (bit: number) => Bitfield;\n  /** @returns the bitfield array as a string */\n  toString: () => string;\n}\n\n/** Curried bitfield factory function */\nexport function bitfieldCloner(bitfield: Bitfield) {\n  return function () {\n    return bitfield.copy().clear();\n  };\n}\n\n/**\n * Create a new Bitfield\n * @param spec The Bitfield's specification object\n * @param spec.capacity The number of bits/flags\n * @param spec.array Optional pre-created bitfield array (avoids new array generation)\n */\nexport function bitfield(spec: BitfieldSpec): Bitfield {\n  const { capacity, array } = validateSpec(spec);\n  const state = { capacity, array } as Bitfield;\n  const bitToIdx = getBitIndex(capacity);\n  const { clear } = clearer(state);\n  const { copy } = copier(state);\n  const { isOn } = onChecker(state, bitToIdx);\n  const { off } = offer(state, bitToIdx);\n  const { on } = onner(state, bitToIdx);\n  const { toggle } = toggler(state, bitToIdx);\n  const { toString } = stringifier(state);\n  return Object.freeze(Object.assign(state, { clear, copy, isOn, off, on, toggle, toString }));\n}\n\n/** Validates and returns a BitfieldSpec object */\nfunction validateSpec(spec: BitfieldSpec): Required<BitfieldSpec> {\n  if (!spec) throw new SyntaxError(\"Bitfield: a specification object is required.\");\n  const { capacity, array } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"Bitfield: spec.capacity is invalid.\");\n  if (array) {\n    if (!isTypedArray(array)) throw new TypeError(\"Bitfield: spec.array is invalid.\");\n    if (array.length !== (capacity + 31) >>> 5) throw new SyntaxError(\"Bitfield: spec.array is wrong size.\");\n  }\n  return { capacity, array: array || new Uint32Array((capacity + 31) >>> 5) };\n}\n\n/** Check if bit is valid and convert to array index */\nfunction getBitIndex(capacity: number): (bit: number) => number {\n  return function bitToIdx(bit: number): number {\n    if (bit == undefined || isNaN(bit) || bit < 0 || bit > capacity) return -1;\n    return bit >>> 5;\n  };\n}\n\nfunction clearer(state: Bitfield) {\n  const { array } = state;\n  return {\n    /**\n     * Set all bits to 0\n     * @returns `true` if the bitfield array was cleared successfully\n     */\n    clear: function (): Bitfield {\n      array.fill(0);\n      return state;\n    },\n  };\n}\n\nfunction copier(state: Bitfield) {\n  const { capacity, array } = state;\n  return {\n    /** @returns a new Bitfield based on this Bitfield */\n    copy: function (): Bitfield {\n      return bitfield({ capacity, array: array.slice() });\n    },\n  };\n}\n\nfunction offer(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'off' (e.g., falsy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    off: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] &= ~(1 << (bit - i * 32));\n      return state;\n    },\n  };\n}\n\nfunction onner(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'on' (e.g., truthy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    on: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] |= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n\nfunction onChecker(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n    isOn: function (bit: number): boolean {\n      const i = bitToIdx(bit);\n      if (i === -1) return false;\n      const cell = array[i];\n      if (!cell) return false;\n      return Boolean(cell & (1 << (bit - i * 32)));\n    },\n  };\n}\n\nfunction stringifier(state: Bitfield) {\n  const { array } = state;\n  return {\n    /** @returns the bitfield array as a string */\n    toString: function (): string {\n      return array.toString();\n    },\n  };\n}\n\nfunction toggler(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Toggle a bit in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    toggle: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] ^= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Entity } from \"../entity.js\";\nimport { ComponentBufferPartitioner, createComponentBuffer, createComponentBufferPartitioner } from \"./buffer.js\";\nimport { Component, ComponentRecord } from \"./component.js\";\nimport { ComponentInstance, createComponentInstance } from \"./instance.js\";\nimport { SchemaProps } from \"./schema.js\";\n\nexport interface ComponentManager {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>) => boolean;\n  entityHasComponent: <T>(entity: Entity, component: Component<T>) => boolean;\n  getBuffer: () => ArrayBuffer;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n}\n\nexport interface ComponentManagerSpec {\n  capacity: number;\n  components: Component<unknown>[];\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  isValidEntity: (entity: Entity) => entity is Entity;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\n/**\n * Create component instances for the world\n * @param spec The function's specification object\n * @param spec.components An array of components to instantiate\n * @param spec.capacity The associated world's component buffer partitioner function\n * @returns an object whose keys are component names, and whose values are component instances\n */\nfunction instantiateComponents(spec: {\n  components: Component<unknown>[];\n  partitioner: ComponentBufferPartitioner;\n}): ComponentRecord {\n  const { components, partitioner } = spec;\n  const reducer = <T>(obj: ComponentRecord, component: Component<T>, id: number) => {\n    const { name } = component;\n    if (Object.prototype.hasOwnProperty.call(obj, name))\n      throw new Error(`ComponentInstance with name \"${name}\" already exists.`);\n    const storage = partitioner(component);\n    obj[name] = createComponentInstance({ component, id, storage });\n    return obj;\n  };\n  return [...new Set(components)].reduce(reducer, {});\n}\n\nexport function createComponentManager(spec: ComponentManagerSpec): Readonly<ComponentManager> {\n  const { capacity, components, getEntityArchetype, isValidEntity, updateArchetype } = spec;\n\n  const buffer = createComponentBuffer({ capacity, components });\n  const partitioner = createComponentBufferPartitioner({ buffer, capacity });\n\n  /** { component_name: ComponentInstance } */\n  const instances = instantiateComponents({ components, partitioner });\n\n  /** <Component, ComponentInstance> */\n  const componentMap: Map<Component<unknown>, ComponentInstance<unknown>> = new Map();\n  Object.values(instances).forEach(<T>(instance: ComponentInstance<T>) => {\n    componentMap.set(Object.getPrototypeOf(instance) as Component<T>, instance);\n  });\n\n  const getBuffer = (): ArrayBuffer => buffer.slice(0);\n\n  const setBuffer = (source: ArrayBuffer): ArrayBuffer => {\n    if (source.byteLength !== buffer.byteLength) {\n      throw new Error(\"setBuffer - byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(buffer);\n    target.set(view);\n    return buffer.slice(0);\n  };\n\n  return Object.freeze({\n    componentMap,\n\n    addComponentToEntity<T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>): boolean {\n      if (!isValidEntity(entity)) return false;\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      // set any default initial properties\n      if (component.schema) {\n        Object.entries(component.schema).forEach(([key, value]) => {\n          if (Array.isArray(value)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n            inst[key][entity] = value[1] ?? 0;\n          }\n        });\n      }\n      // set any custom initial properties\n      if (props) {\n        Object.entries(props).forEach(([key, value]) => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          inst[key][entity] = value;\n        });\n      }\n      return true;\n    },\n\n    entityHasComponent<T>(entity: Entity, component: Component<T>): boolean {\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      const arch = getEntityArchetype(entity);\n      if (!arch) return false;\n      const { bitfield } = arch;\n      return bitfield.isOn(inst.id);\n    },\n\n    getBuffer,\n\n    removeComponentFromEntity<T>(component: Component<T>, entity: Entity): boolean {\n      if (!isValidEntity(entity)) return false;\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      return true;\n    },\n\n    setBuffer,\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isUint32, TypedArray } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentInstanceSpec<T> {\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport interface ComponentInstance<T> extends Component<T> {\n  /** The instance's identifier */\n  id: number;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T> & Record<keyof T, TypedArray>> {\n  const { component, id, storage } = spec;\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n  const instance = Object.create(component, {\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n  return Object.freeze(Object.assign(instance, storage));\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ONE_BYTE } from \"../constants.js\";\nimport { TypedArrayConstructor } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentBufferSpec {\n  capacity: number;\n  components: Component<unknown>[];\n}\n\nexport interface ComponentBufferPartitionerSpec {\n  buffer: ArrayBuffer;\n  capacity: number;\n}\n\n/** <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray } */\nexport type ComponentBufferPartitioner = <T>(component: Component<T>) => SchemaStorage<T> | undefined;\n\n/** Calculate the total required storage space for all component schemas */\nfunction getComponentSize(capacity: number, components: Component<unknown>[]) {\n  function componentSum<T>(total: number, component: Component<T>): number {\n    const { size = 0 } = component;\n    if (!size || size <= 0) return total;\n    return total + size * capacity;\n  }\n  return components.reduce(componentSum, 0);\n}\n\n/**\n * Create a properly sized ArrayBuffer to hold all a world's component's data.\n * @param spec The component buffer's specification object\n * @param spec.capacity The world's entity capacity\n * @param spec.components The components which the buffer will contain\n */\nexport function createComponentBuffer(spec: ComponentBufferSpec): ArrayBuffer {\n  const { capacity, components } = spec;\n  const totalSize = getComponentSize(capacity, components);\n  return new ArrayBuffer(ONE_BYTE * Math.ceil(totalSize / ONE_BYTE));\n}\n\n/**\n * Creates a function which allows for the creation of component storage partitions.\n * @param spec the partitioner's specification object\n * @param spec.buffer the buffer to partition\n * @param spec.capacity the world's entity capacity\n * @returns <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray };\n */\nexport function createComponentBufferPartitioner(spec: ComponentBufferPartitionerSpec): ComponentBufferPartitioner {\n  const { buffer, capacity } = spec;\n  let bufferOffset = 0;\n  let full = false;\n\n  return function partitionComponentBuffer<T>(component: Component<T>): SchemaStorage<T> | undefined {\n    if (full === true) throw new Error(\"ArrayBuffer is full!\");\n    const { schema, size = 0 } = component;\n    if (!size || size <= 0) return; // bail early if component is a tag\n    if (bufferOffset + size * capacity > buffer.byteLength) {\n      throw new Error(\"Component will not fit inside the buffer!\");\n    }\n\n    let componentOffset = 0;\n    function partition(\n      res: SchemaStorage<T>,\n      [key, value]: [keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]],\n    ) {\n      let typedArray = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) {\n        const [arrayConstructor, defaultValue] = value;\n        typedArray = arrayConstructor;\n        initialValue = defaultValue;\n      }\n      res[key] = new typedArray(buffer, bufferOffset + componentOffset, capacity);\n      if (initialValue !== 0) res[key].fill(initialValue as never);\n      componentOffset += typedArray.BYTES_PER_ELEMENT * capacity;\n      return res;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const data = Object.entries(schema!) as [keyof T, TypedArrayConstructor][];\n    const storage = data.reduce(partition, {} as SchemaStorage<T>);\n\n    bufferOffset += componentOffset;\n    if (bufferOffset > buffer.byteLength) full = true;\n\n    return storage;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { isUint32, Opaque } from \"./utils.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\nexport interface EntityManagerSpec {\n  capacity: number;\n}\n\nexport interface EntityManager {\n  createEntity: () => Entity | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  getVacancyCount: () => number;\n  hasEntity: (entity: Entity) => boolean;\n  isValidEntity: (entity: Entity) => entity is Entity;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n}\n\nfunction createEntityArchetypeArray(capacity: number) {\n  const entityArchetypes: Archetype[] = [];\n  entityArchetypes.length = capacity; // @note V8 hack, quicker/smaller than new Array(capacity)\n  return entityArchetypes;\n}\n\nfunction createAvailableEntityArray(capacity: number): Entity[] {\n  // @todo would this be better as a generator?\n  const total = capacity - 1;\n  return Array.from({ length: capacity }, (_, i) => total - i) as Entity[];\n}\n\n/**\n *\n * @param capacity\n * @returns\n */\nfunction entityValidator(capacity: number): (entity: Entity) => entity is Entity {\n  /** @return `true` if the given entity is valid for the given capacity */\n  return function isValidEntity(entity: Entity): entity is Entity {\n    if (!isUint32(entity) || entity > capacity) return false;\n    return true;\n  };\n}\n\n/** Manages the creation, destruction and recycling of entities */\nexport function createEntityManager(spec: EntityManagerSpec): Readonly<EntityManager> {\n  if (!spec) throw new SyntaxError(\"EntityManager creation requires a spec object.\");\n  const { capacity } = spec;\n\n  const entityArchetypes = createEntityArchetypeArray(capacity);\n  const availableEntities = createAvailableEntityArray(capacity);\n  const isValidEntity = entityValidator(capacity);\n\n  return Object.freeze({\n    /** @returns the next available Entity or `undefined` if no Entity is available */\n    createEntity(): Entity | undefined {\n      return availableEntities.pop();\n    },\n\n    /**\n     * Remove and recycle an Entity\n     * @returns `true` if there was an archetype change\n     */\n    destroyEntity(entity: Entity): boolean {\n      if (!isValidEntity(entity)) return false;\n      const archetype = entityArchetypes[entity];\n      if (archetype !== undefined) {\n        archetype.removeEntity(entity);\n        delete entityArchetypes[entity];\n        availableEntities.push(entity);\n        return true;\n      }\n      return false;\n    },\n\n    /** @returns the Entity's Archetype or undefined if Entity is not alive */\n    getEntityArchetype(entity: Entity): Archetype | undefined {\n      return entityArchetypes[entity];\n    },\n\n    /** @returns the number of available entities */\n    getVacancyCount() {\n      return availableEntities.length;\n    },\n\n    /** @return `true` if the Entity !== undefined */\n    hasEntity(entity: Entity): boolean {\n      return isValidEntity(entity) && entityArchetypes[entity] !== undefined;\n    },\n\n    isValidEntity,\n\n    /** @returns `true` if the Archetype was changed successfully */\n    setEntityArchetype(entity: Entity, archetype: Archetype): boolean {\n      if (isValidEntity(entity)) {\n        entityArchetypes[entity] = archetype;\n        return true;\n      }\n      return false;\n    },\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { createQueryInstance, QueryInstance } from \"./instance.js\";\nimport { isValidQuery, Query } from \"./query.js\";\n\nexport interface QueryManagerSpec {\n  bitfieldFactory: () => Bitfield;\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n}\n\nexport interface QueryManager {\n  queryMap: Map<Query, QueryInstance>;\n  /** Entities which have entered this query since last refresh */\n  getQueryEntered: (query: Query) => Entity[];\n  /** Entities which have exited this query since last refresh */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  getQueryResult: (query: Query) => [Entity[], ComponentRecord];\n}\n\nexport function createQueryManager(spec: QueryManagerSpec): QueryManager {\n  const { bitfieldFactory, componentMap } = spec;\n\n  const queryMap: Map<Query, QueryInstance> = new Map();\n\n  const register = (query: Query) => {\n    if (!isValidQuery(query)) throw new Error(\"Object is not a valid query.\");\n    const instance = createQueryInstance({ bitfieldFactory, componentMap, query });\n    queryMap.set(query, instance);\n    return instance;\n  };\n\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  function getQueryResult(query: Query): [Entity[], ComponentRecord] {\n    const instance = queryMap.get(query) ?? register(query);\n    return [instance.getEntities(), instance.getComponents()];\n  }\n\n  /** Entities which have entered this query since last refresh */\n  function getQueryEntered(query: Query): Entity[] {\n    const instance = queryMap.get(query) ?? register(query);\n    return instance.getEntered();\n  }\n\n  /** Entities which have exited this query since last refresh */\n  function getQueryExited(query: Query): Entity[] {\n    const instance = queryMap.get(query) ?? register(query);\n    return instance.getExited();\n  }\n\n  return {\n    queryMap,\n    getQueryEntered,\n    getQueryExited,\n    getQueryResult,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Query } from \"./query.js\";\n\nexport interface QueryInstanceSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Readonly<Bitfield>;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  getComponents: () => ComponentRecord;\n  /** Entities which have entered this query since last refresh */\n  getEntered: () => Entity[];\n  getEntities: () => Entity[];\n  /** Entities which have exited this query since last refresh */\n  getExited: () => Entity[];\n  refresh: (archetypes: Archetype[]) => void;\n}\n\nexport interface QueryData {\n  /** A bitfield for the AND match criteria */\n  and?: Readonly<Bitfield>;\n  /** A bitfield for the OR match criteria */\n  or?: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not?: Readonly<Bitfield>;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): Readonly<QueryInstance> {\n  const { componentMap, query, bitfieldFactory } = spec;\n\n  const archetypes: Set<Archetype> = new Set();\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<unknown>> = {};\n\n  const fields: QueryData = {};\n\n  const getComponentInstances = (arr: ComponentInstance<unknown>[], component: Component<unknown>) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr.push(inst);\n    return arr;\n  };\n\n  const mapCompo = <T>(component: ComponentInstance<T>) => {\n    components[component.name] = component;\n  };\n\n  if (query.all.length) {\n    const instances = query.all.reduce(getComponentInstances, []);\n    instances.forEach(mapCompo);\n    fields.and = bitfieldFactory(instances);\n  }\n\n  if (query.any.length) {\n    const instances = query.any.reduce(getComponentInstances, []);\n    instances.forEach(mapCompo);\n    fields.or = bitfieldFactory(instances);\n  }\n\n  if (query.none.length) {\n    const instances = query.none.reduce(getComponentInstances, []);\n    fields.not = bitfieldFactory(instances);\n  }\n\n  // Lock component object\n  Object.freeze(components);\n\n  const getComponents = (): ComponentRecord => components;\n\n  /** @todo cache entities per archetype and add a dirty flag to archetypes - only update entities from dirty archetypes */\n  const getEntities = (): Entity[] => [...archetypes].flatMap((archetype) => [...archetype.entities]);\n\n  const getEntered = (): Entity[] => [...archetypes].flatMap((archetype) => [...archetype.entered]);\n\n  const getExited = (): Entity[] => [...archetypes].flatMap((archetype) => [...archetype.exited]);\n\n  const refresher = (archetype: Archetype) => {\n    if (archetype.isCandidate(fields)) {\n      archetypes.add(archetype);\n    }\n  };\n\n  const refresh = (archetypes: Archetype[]) => archetypes.forEach(refresher);\n\n  return Object.freeze(\n    Object.assign(Object.create(query), {\n      getComponents,\n      getEntered,\n      getEntities,\n      getExited,\n      refresh,\n    }) as QueryInstance,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { createArchetypeManager } from \"./archetype/manager.js\";\nimport { bitfield, bitfieldCloner } from \"./bitfield.js\";\nimport { Component, ComponentRecord } from \"./component/component.js\";\nimport { createComponentManager } from \"./component/manager.js\";\nimport { SchemaProps } from \"./component/schema.js\";\nimport { DEFAULT_MAX_ENTITIES, VERSION } from \"./constants.js\";\nimport { createEntityManager, Entity } from \"./entity.js\";\nimport { QueryInstance } from \"./query/instance.js\";\nimport { createQueryManager } from \"./query/manager.js\";\nimport { Query } from \"./query/query.js\";\nimport { createSerializationManager, MiskiData } from \"./serialize.js\";\nimport { isUint32 } from \"./utils.js\";\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world  */\n  components: Component<unknown>[];\n}\n\nexport interface WorldProto {\n  /** The Miski version used to create this World */\n  readonly version: string;\n}\n\nexport interface World extends WorldProto {\n  /** The maximum number of entities allowed in the world */\n  readonly capacity: number;\n  /**\n   * Add a component to an entity.\n   * @param component the component to add.\n   * @param entity the entity to add the component to.\n   * @param props optional initial component values to set for the entity.\n   * @returns `true` if the component was added successfully.\n   */\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T> | undefined) => boolean;\n  /**\n   * Create a new entity for use in the world.\n   * @returns the entity or `undefined` if no entities were available.\n   */\n  createEntity: () => Entity | undefined;\n  /**\n   * Destroy a given entity.\n   * @returns `true` if the entity was successfully destroyed.\n   */\n  destroyEntity: (entity: Entity) => boolean;\n  /**\n   * Check if an entity has a given component.\n   * @param entity the entity to check.\n   * @param component the component to check for.\n   * @returns `true` if the entity has the component.\n   */\n  entityHasComponent: <T>(entity: Entity, component: Component<T>) => boolean;\n  /**\n   * Get a given entity's archetype.\n   * @param entity the entity to expose.\n   * @returns the Archetype object or `undefined` if no archetype found.\n   */\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  /** @returns an array of entities which have entered a query's archetypes since last world.refresh() */\n  getQueryEntered: (query: Query) => Entity[];\n  /** @returns an array of entities which have left a query's archetypes since last world.refresh() */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of entities and components which match the query's criteria */\n  getQueryResult: (query: Query) => [Entity[], ComponentRecord];\n  /** @returns the number of available entities in the world. */\n  getVacancyCount: () => number;\n  /** @returns `true` if the entity is valid and !== undefined */\n  hasEntity: (entity: Entity) => boolean;\n  /**\n   * Load data into the world.\n   * @param data the MiskiData object to load\n   * @returns `true` if all the data was successfully loaded into the world.\n   */\n  load: (data: MiskiData) => boolean;\n  /**\n   * Purge various caches throughout the world.\n   * Should not be necessary but useful if memory footprint is creeping.\n   */\n  purgeCaches: () => void;\n  /**\n   * Run various maintenance functions in the world.\n   * Recommended once per frame.\n   */\n  refresh: () => void;\n  /**\n   * Remove a component from an entity.\n   * @param component the component to remove.\n   * @param entity the entity to remove the component from.\n   * @returns `true` if the component was removed successfully.\n   */\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n  /** Serialize various aspects of the world's data */\n  save: () => Readonly<MiskiData>;\n}\n\n/** World.prototype - Miski version data etc. */\nexport const WORLD_PROTO: Readonly<WorldProto> = Object.freeze({\n  version: VERSION,\n});\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec) throw new SyntaxError(\"World creation requires a specification object.\");\n  const { capacity = DEFAULT_MAX_ENTITIES, components } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"World creation: spec.capacity invalid.\");\n  if (!components.length) throw new SyntaxError(\"World creation: spec.components invalid.\");\n  return { capacity, components };\n}\n\nfunction createBitfieldFactory(capacity: number) {\n  const emptyBitfield = bitfield({ capacity });\n  const bitfieldFactory = bitfieldCloner(emptyBitfield);\n  return bitfieldFactory;\n}\n\nexport function createWorld(spec: WorldSpec): Readonly<World> {\n  const { capacity, components } = validateWorldSpec(spec);\n  const bitfieldFactory = createBitfieldFactory(components.length);\n\n  const {\n    createEntity,\n    destroyEntity,\n    getEntityArchetype,\n    getVacancyCount,\n    hasEntity,\n    isValidEntity,\n    setEntityArchetype,\n  } = createEntityManager({ capacity });\n\n  const { archetypeMap, updateArchetype } = createArchetypeManager({\n    bitfieldFactory,\n    getEntityArchetype,\n    setEntityArchetype,\n  });\n\n  const { componentMap, addComponentToEntity, entityHasComponent, getBuffer, removeComponentFromEntity, setBuffer } =\n    createComponentManager({\n      capacity,\n      components,\n      getEntityArchetype,\n      isValidEntity,\n      updateArchetype,\n    });\n\n  const { queryMap, getQueryEntered, getQueryExited, getQueryResult } = createQueryManager({\n    bitfieldFactory,\n    componentMap,\n  });\n\n  const { load, save } = createSerializationManager({ getBuffer, setBuffer });\n\n  function purgeCaches() {\n    const archetypes = [...archetypeMap.values()];\n    const purgeArchetypes = (archetype: Archetype) => archetype.purge();\n    archetypes.forEach(purgeArchetypes);\n  }\n  purgeCaches();\n\n  function refresh() {\n    const archetypes = [...archetypeMap.values()];\n    const refreshQuery = (instance: QueryInstance) => instance.refresh(archetypes);\n    queryMap.forEach(refreshQuery);\n    const refreshArchetype = (archetype: Archetype) => archetype.refresh();\n    archetypes.forEach(refreshArchetype);\n  }\n  refresh();\n\n  return Object.freeze(\n    Object.assign(Object.create(WORLD_PROTO), {\n      capacity,\n      addComponentToEntity,\n      createEntity,\n      destroyEntity,\n      entityHasComponent,\n      getEntityArchetype,\n      getQueryEntered,\n      getQueryExited,\n      getQueryResult,\n      getVacancyCount,\n      hasEntity,\n      load,\n      purgeCaches,\n      refresh,\n      removeComponentFromEntity,\n      save,\n    }) as World,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Archetype, createArchetype } from \"./archetype.js\";\n\nexport interface ArchetypeManagerSpec {\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Bitfield;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n}\n\nexport interface ArchetypeManager {\n  archetypeMap: Map<string, Archetype>;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\nexport function createArchetypeManager(spec: ArchetypeManagerSpec): ArchetypeManager {\n  const { bitfieldFactory, getEntityArchetype, setEntityArchetype } = spec;\n  const archetypeMap: Map<string, Archetype> = new Map();\n\n  return {\n    archetypeMap,\n\n    /**\n     * Update an entity's archetype\n     * @param entity the entity to update\n     * @param component the component to toggle\n     * @returns the entity's new archetype\n     */\n    updateArchetype<T>(entity: Entity, component: ComponentInstance<T>): Archetype {\n      const previousArchetype = getEntityArchetype(entity);\n      let nextArchetype: Archetype | undefined;\n      if (previousArchetype) {\n        previousArchetype.removeEntity(entity);\n        const [id, factory] = previousArchetype.cloneInStep(component);\n        if (archetypeMap.has(id)) {\n          nextArchetype = archetypeMap.get(id)!;\n        } else {\n          nextArchetype = factory();\n          archetypeMap.set(id, nextArchetype);\n        }\n      } else {\n        nextArchetype = createArchetype({ bitfield: bitfieldFactory([component]) });\n        archetypeMap.set(nextArchetype.id, nextArchetype);\n      }\n      nextArchetype.addEntity(entity);\n      setEntityArchetype(entity, nextArchetype);\n      return nextArchetype;\n    },\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nexport interface SerializationManagerSpec {\n  getBuffer: () => ArrayBuffer;\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n}\n\nexport interface MiskiData {\n  componentBuffer: ArrayBuffer;\n}\n\nexport interface SerializationManager {\n  load: (data: MiskiData) => boolean;\n  save: () => MiskiData;\n}\n\nexport function createSerializationManager(spec: SerializationManagerSpec): SerializationManager {\n  const { getBuffer, setBuffer } = spec;\n\n  function save(): Readonly<MiskiData> {\n    return Object.freeze({\n      componentBuffer: getBuffer(),\n    });\n  }\n\n  function load(data: MiskiData): boolean {\n    const { componentBuffer } = data;\n    /** @todo validate! */\n    setBuffer(componentBuffer);\n    return true;\n  }\n\n  return {\n    load,\n    save,\n  };\n}\n"],"names":["DEFAULT_MAX_ENTITIES","FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","isUint32","n","isNaN","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","test","includes","isObject","Array","isArray","isValidSchema","schema","entries","every","name","value","a","b","_validateProps","byteSum","total","BYTES_PER_ELEMENT","calculateSchemaSize","values","reduce","createComponent","spec","SyntaxError","isTag","size","createQuery","all","any","none","component","createSystem","callback","world","args","createArchetype","bitfield","id","toString","validateSpec","entered","Set","entities","exited","data","addEntity","getEntities","removeEntity","state","entity","add","hasEntity","has","delete","entityFns","cloneInStep","cloneWithToggle","purgeCloneCache","cache","Map","cached","get","bitfieldCopy","copy","toggle","bitfieldId","clone","set","clear","cloner","isCandidate","purgeCandidateCache","_bitfield","array","query","and","or","not","_not","_and","_or","status","target","i","_n","_a","_o","candidateChecker","assign","purge","refresh","capacity","ArrayBuffer","isView","DataView","TypeError","Uint32Array","bitToIdx","bit","undefined","getBitIndex","fill","clearer","slice","copier","isOn","cell","onChecker","off","offer","on","onner","toggler","stringifier","instantiateComponents","components","partitioner","obj","Error","storage","instance","create","configurable","enumerable","writable","createComponentInstance","createComponentManager","getEntityArchetype","isValidEntity","updateArchetype","buffer","totalSize","getComponentSize","Math","ceil","createComponentBuffer","bufferOffset","full","byteLength","componentOffset","res","key","typedArray","initialValue","arrayConstructor","defaultValue","createComponentBufferPartitioner","instances","componentMap","forEach","getPrototypeOf","addComponentToEntity","props","inst","entityHasComponent","arch","getBuffer","removeComponentFromEntity","setBuffer","source","view","Uint8Array","createEntityManager","entityArchetypes","createEntityArchetypeArray","availableEntities","from","_","createAvailableEntityArray","entityValidator","createEntity","pop","destroyEntity","archetype","push","getVacancyCount","setEntityArchetype","createQueryManager","bitfieldFactory","queryMap","register","isValidQuery","archetypes","fields","getComponentInstances","arr","mapCompo","refresher","getComponents","getEntered","flatMap","getExited","createQueryInstance","getQueryEntered","getQueryExited","getQueryResult","WORLD_PROTO","version","createWorld","validateWorldSpec","bitfieldCloner","createBitfieldFactory","archetypeMap","previousArchetype","nextArchetype","factory","createArchetypeManager","load","save","componentBuffer","createSerializationManager","purgeCaches"],"mappings":"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"}