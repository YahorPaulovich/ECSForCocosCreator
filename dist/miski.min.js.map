{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/archetype/archetype.ts","../src/archetype/manager.ts","../src/component/proxy.ts","../src/component/instance.ts","../src/utils/sparse-facade.ts","../src/component/manager.ts","../src/component/buffer.ts","../src/entity.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts","../src/bitfield.ts","../src/serialize.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport * as pkg from \"../package.json\";\n\n/** Miski version */\nexport const VERSION: string = pkg.version;\n\n/** Default maximum entities value */\nexport const DEFAULT_MAX_ENTITIES = 1_000_000;\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties\n  \"changed\",\n  \"component\",\n  \"count\",\n  \"eid\",\n  \"id\",\n  \"isTag\",\n  \"maxEntities\",\n  \"name\",\n  \"proxy\",\n  \"schema\",\n  \"size\",\n  // object properties\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** The number 8 - to avoid magic numbers */\nexport const ONE_BYTE = 8;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n\n/** A symbol for use where returning undefined from an array etc. is desirable */\nexport const EMPTY_SYMBOL = Symbol(\"EMPTY\");\n\n/** Symbol for use as a key for the `changed` flag getter and setter */\nexport const $_CHANGED = Symbol(\"changed\");\n\n/** Symbol for use as a key for the `count` flag getter and setter */\nexport const $_COUNT = Symbol(\"count\");\n\n/** Symbol for use as a key for the `isDirty` flag getter and setter */\nexport const $_DIRTY = Symbol(\"dirty\");\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"../constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    (typeof str === \"string\" && str.length > 0 && VALID_NAME_PATTERN.test(str) === true) ||\n      !FORBIDDEN_NAMES.includes(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/** An empty function for use in Systems */\nexport function noop(): void {\n  return void 0;\n}\n\n/** @author https://stackoverflow.com/a/67605309 */\nexport type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never;\n\n/** The parameters of a function omitting the first two parameters */\nexport type ParametersExceptFirstTwo<F> = F extends (arg0: any, arg1: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n\nexport function createAvailabilityArray(capacity: number): number[] {\n  const total = capacity - 1;\n  return Array.from({ length: capacity }, (_, i) => total - i);\n}\n\nexport function sortAscending(a: number, b: number): number {\n  return b - a;\n}\n\nexport function hasOwnProperty<K extends PropertyKey>(key: K) {\n  return function <U>(obj: U): obj is U & Record<K, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n}\n\nexport function filterEntries<K extends PropertyKey>(keys: K[]) {\n  return function <T extends Record<K, unknown>>(obj: T) {\n    const reducer = (curr: Record<K, T[K]>, key: K): Record<K, T[K]> => {\n      if (hasOwnProperty(key)(obj)) curr[key] = obj[key];\n      return curr;\n    };\n    return keys.reduce(reducer, {} as Record<K, T[K]>);\n  };\n}\n\nexport function getProperty<K extends PropertyKey>(key: K) {\n  return function <U extends Record<K, unknown>>(obj: U): U[K] {\n    return obj[key];\n  };\n}\n\nexport function getOwnProperty<K extends PropertyKey>(key: K) {\n  const hasKey = hasOwnProperty(key);\n  return function <U extends Record<K, unknown>>(obj: U): U[K] | undefined {\n    return hasKey(obj) ? obj[key] : undefined;\n  };\n}\n\nexport function intersectBits(a = 0, b = 0): number {\n  return a & b;\n}\n\nexport function roundUpToMultipleOf(f: number): (n: number) => number {\n  return (n: number) => Math.ceil(n / f) * f;\n}\n\nexport const multipleOf4 = roundUpToMultipleOf(4);\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport {\n  isObject,\n  isTypedArrayConstructor,\n  isValidName,\n  multipleOf4,\n  TypedArray,\n  TypedArrayConstructor,\n} from \"../utils/utils.js\";\n\n/** Object of single component properties */\nexport type SchemaProps<T> = Record<keyof T, number | bigint | undefined>;\n\n/** Component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n * Values in the array are initialised to 0 by default.\n * To set your own default value: `{ property: [Int8Array, default value] }`.\n */\nexport type Schema<T> = Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Schema type guard */\nexport function isValidSchema<T>(schema: unknown): schema is Schema<T> {\n  const _validateProps = (value: TypedArrayConstructor | [TypedArrayConstructor, number]) => {\n    if (Array.isArray(value)) {\n      const [a, b] = value;\n      if (!isNaN(b) && isTypedArrayConstructor(a)) return true;\n    } else {\n      return isTypedArrayConstructor(value);\n    }\n    return false;\n  };\n  const _validate = ([name, value]: [string, unknown]) => {\n    return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n  };\n  return isObject(schema) && Object.entries(schema).every(_validate);\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/** @returns the size in bytes that a component's storage requires for one entity */\nexport function calculateSchemaSize<T>(schema: Schema<T>): number {\n  return multipleOf4(Object.values(schema).reduce(byteSum, 0) as number);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isUint32, isValidName } from \"../utils/utils.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\nexport interface ComponentSpec<T> {\n  /**\n   * The maximum number of entities able to equip this component per world.\n   *\n   * Defaults to all entities.\n   *\n   * __Warning__: use this only where memory consumption is a concern, performance will be worse.\n   */\n  maxEntities?: number;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport interface Component<T> {\n  /** `true` if the component has no schema */\n  isTag: boolean;\n  /** The maximum number of entities able to equip this component per world. */\n  maxEntities: number | null;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  size: number;\n}\n\n/**\n * Define a new component.\n * @param spec the component's specification.\n * @param spec.name the component's string identifier.\n * @param spec.schema the component's optional schema object.\n * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n */\nexport function createComponent<T extends Schema<T>>(spec: ComponentSpec<T>): Readonly<Component<T>> {\n  if (!spec) {\n    throw new SyntaxError(\"createComponent: a specification object is required.\");\n  }\n  const { maxEntities, name, schema } = spec;\n  if (maxEntities && (!isUint32(maxEntities) || maxEntities === 0)) {\n    throw new SyntaxError(\"createComponent: maxEntities must be a Uint32 > 0.\");\n  }\n  if (!isValidName(name)) {\n    throw new SyntaxError(\"Component name is invalid.\");\n  }\n  if (schema && !isValidSchema(schema)) {\n    throw new SyntaxError(\"createComponent: component schema is invalid.\");\n  }\n  return Object.freeze({\n    maxEntities: maxEntities ?? null,\n    isTag: Boolean(schema),\n    name,\n    schema: schema ? Object.freeze({ ...schema }) : null,\n    size: schema ? calculateSchemaSize(schema) : 0,\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Readonly<Component<unknown>[]>;\n}\n\n/** Queries are groupings of archetypes */\nexport type Query = Readonly<{\n  /** AND - Gather entities as long as they have all these components */\n  all: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none: Readonly<Component<unknown>[]>;\n}>;\n\n/** Merge multiple Queries into one new Query */\nexport function mergeQueries(...queries: Query[]): Query {\n  const _all: Component<unknown>[] = [];\n  const _any: Component<unknown>[] = [];\n  const _none: Component<unknown>[] = [];\n  queries.forEach((query) => {\n    const { all, any, none } = query;\n    _all.push(...all);\n    _any.push(...any);\n    _none.push(...none);\n  });\n  return createQuery({\n    all: _all,\n    any: _any,\n    none: _none,\n  });\n}\n\nfunction _validateQueryArrays<T>(component: Component<T>) {\n  return Object.prototype.hasOwnProperty.call(component, \"name\");\n}\n\nexport function isValidQuery(object: unknown): object is Query {\n  const { any = EMPTY_ARRAY, all = EMPTY_ARRAY, none = EMPTY_ARRAY } = object as Query;\n  return [...all, ...any, ...none].every(_validateQueryArrays);\n}\n\n/**\n * Create a new Query\n * @param spec The Query's specification object\n * @param spec.all AND - Gather entities as long as they have all these components\n * @param spec.any OR - Gather entities as long as they have 0...* of these components\n * @param spec.none NOT - Gather entities as long as they don't have these components\n */\nexport function createQuery(spec: QuerySpec): Query {\n  if (!spec) throw new SyntaxError(\"createQuery: specification object is required.\");\n  const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n  if (![...all, ...any, ...none].every(_validateQueryArrays)) {\n    throw new SyntaxError(\"createQuery: Query specification object is invalid.\");\n  }\n  return Object.freeze({\n    all: Object.freeze([...new Set(all)]),\n    any: Object.freeze([...new Set(any)]),\n    none: Object.freeze([...new Set(none)]),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { Entity } from \"./entity.js\";\nimport type { Query } from \"./query/query.js\";\nimport type { ParametersExceptFirstTwo } from \"./utils/utils.js\";\nimport type { World } from \"./world.js\";\n\n/** A multi-arity function where the first parameter is always the World object */\nexport type System<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> = (components: ComponentRecord, entities: Entity[], ...args: U) => ReturnType<T>;\n\n/**\n * Creates a new curried System function\n * @param system the System function to be called\n * @returns a curried function (world) => (...args) => result;\n *\n * @example\n * const logQuery = createQuery({ all: [loggable]});\n * const log = (components: Record<string, ComponentInstance>, entities: Entity[], value: string) => console.log(value);\n * const logSystem = createSystem(log, logQuery);\n * const logSystemInstance = logSystem(world);\n * logSystemInstance(\"hello, world!\"); // hello, world!\n */\nexport function createSystem<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n>(system: System<T, U>, query: Query) {\n  return (world: World) => {\n    const [components, getEntities] = world.getQueryResult(query);\n    return (...args: U): ReturnType<T> => system(components, getEntities(), ...args);\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Bitfield } from \"../bitfield.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport { $_DIRTY } from \"../constants.js\";\nimport type { Entity } from \"../entity.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\n\nexport interface ArchetypeSpec {\n  /** The Archetype's Components as an id Bitfield */\n  bitfield: Bitfield;\n  /** Optional ID string. Will be generated if omitted */\n  id?: string;\n}\n\n/** Archetypes are unique groupings of entities by components */\nexport interface Archetype {\n  /** @private Provides a getter and setter for the `isDirty` flag */\n  [$_DIRTY]: boolean;\n  /** The Archetype's Component Bitfield */\n  bitfield: Bitfield;\n  /** */\n  candidateCache: Map<QueryInstance, boolean>;\n  /** */\n  cloneCache: Map<ComponentInstance<unknown>, Archetype>;\n  /** The components associated with this archetype */\n  components: Set<ComponentInstance<unknown>>;\n  /** Entities which have entered this archetype since last refresh */\n  entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  exited: Set<Entity>;\n  /** The Archetype's unique ID */\n  id: string;\n  /** `true` if the object is in a dirty state */\n  isDirty: boolean;\n}\n\nfunction validateSpec(spec: ArchetypeSpec): Required<ArchetypeSpec> {\n  if (!spec) throw new SyntaxError(\"Archetype: specification object required.\");\n  const { bitfield, id } = spec;\n  if (!bitfield) throw new SyntaxError(\"Archetype: spec.bitfield is required.\");\n  return { bitfield, id: id || bitfield.toString() };\n}\n\nexport function createArchetype(spec: ArchetypeSpec): Archetype {\n  const { bitfield, id } = validateSpec(spec);\n\n  let isDirty = true;\n\n  return {\n    get [$_DIRTY](): boolean {\n      return isDirty;\n    },\n    set [$_DIRTY](dirty: boolean) {\n      isDirty = !!dirty;\n    },\n    get isDirty(): boolean {\n      return isDirty;\n    },\n    bitfield,\n    candidateCache: new Map() as Map<QueryInstance, boolean>,\n    cloneCache: new Map() as Map<ComponentInstance<unknown>, Archetype>,\n    components: new Set(),\n    entered: new Set(),\n    entities: new Set(),\n    exited: new Set(),\n    id,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Bitfield } from \"../bitfield.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport { $_DIRTY } from \"../constants.js\";\nimport type { Entity } from \"../entity.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\nimport type { Query } from \"../query/query.js\";\nimport { intersectBits } from \"../utils/utils.js\";\nimport { Archetype, ArchetypeSpec, createArchetype as _createArchetype } from \"./archetype.js\";\n\ninterface ArchetypeManagerSpec {\n  capacity: number;\n  EMPTY_BITFIELD: Bitfield;\n  toggleBit: (bit: number, bitfield: Bitfield) => boolean;\n}\n\ninterface ArchetypeManager {\n  EMPTY_ARCHETYPE: Archetype;\n  createArchetype: (spec: ArchetypeSpec) => Archetype;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  isArchetypeCandidate: (archetype: Archetype) => (query: QueryInstance) => boolean;\n  purgeArchetypesCaches: () => void;\n  refreshArchetypes: (queries: Map<Query, QueryInstance>) => void;\n  removeEntityFromArchetype: (entity: Entity, archetype: Archetype) => Archetype;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => Archetype;\n  updateArchetype: (entity: Entity, component: ComponentInstance<unknown> | ComponentInstance<unknown>[]) => Archetype;\n}\n\n/** Add an Entity to an Archetype's inhabitants list */\nfunction addEntityToArchetype(entity: Entity, archetype: Archetype): Archetype {\n  const { entities, entered } = archetype;\n  entities.add(entity);\n  entered.add(entity);\n  archetype[$_DIRTY] = true;\n  return archetype;\n}\n\n/** For use in the looping over of an Archetype's bitfield */\nfunction getCandidateStatus(query: QueryInstance): (target: number, idx: number) => boolean {\n  const { and, or, not } = query;\n  return (target: number, idx: number): boolean => {\n    const OR = or[idx] === 0 || intersectBits(target, or[idx]) > 0;\n    if (!OR) return false;\n    const AND = intersectBits(target, and[idx]) === and[idx];\n    if (!AND) return false;\n    return intersectBits(target, not[idx]) === 0;\n  };\n}\n\n/** @returns `true` if the query criteria match this archetype */\nfunction isArchetypeCandidate(archetype: Archetype): (query: QueryInstance) => boolean {\n  const { bitfield, candidateCache } = archetype;\n  return (query: QueryInstance): boolean => {\n    if (candidateCache.has(query)) return candidateCache.get(query) ?? false;\n    const checkStatus = getCandidateStatus(query);\n    const status = bitfield.every(checkStatus);\n    candidateCache.set(query, status);\n    return status;\n  };\n}\n\n/** Purge the `candidate` and `clone` caches in an Archetype */\nfunction purgeArchetypeCaches(archetype: Archetype): Archetype {\n  const { candidateCache, cloneCache } = archetype;\n  candidateCache.clear();\n  cloneCache.clear();\n  return archetype;\n}\n\n/** Clear the entered/exited list and set `isDirty` to `false` */\nfunction refreshArchetype(archetype: Archetype): Archetype {\n  const { entered, exited } = archetype;\n  entered.clear();\n  exited.clear();\n  archetype[$_DIRTY] = false;\n  return archetype;\n}\n\n/** Remove an Entity from an Archetype's inhabitants list */\nfunction _removeEntityFromArchetype(entity: Entity, archetype: Archetype): Archetype {\n  const { entities, exited } = archetype;\n  entities.delete(entity);\n  exited.add(entity);\n  archetype[$_DIRTY] = true;\n  return archetype;\n}\n\n/** Shorthand utility types */\ntype ComponentInstances = ComponentInstance<unknown> | ComponentInstance<unknown>[];\ntype ArchetypeCloneState = [string, () => Archetype];\ntype ArchetypeCloner = (archetype: Archetype, component: ComponentInstances) => ArchetypeCloneState;\n\nfunction archetypeCloner(\n  createArchetype: (spec: ArchetypeSpec) => Archetype,\n  toggleBit: (bit: number, bitfield: Bitfield) => boolean,\n): ArchetypeCloner {\n  return (archetype: Archetype, component: ComponentInstances): ArchetypeCloneState => {\n    const { bitfield, cloneCache } = archetype;\n\n    // If component is single, attempt to get result from Archetype.cloneCache\n    if (!Array.isArray(component)) {\n      const cached = cloneCache.get(component);\n      if (cached) return [cached.id, () => cached];\n      component = [component];\n    }\n\n    // Clone the Archetype's bitfield\n    const bitfieldCopy = bitfield.slice() as Bitfield;\n\n    // Handle toggling of Components in the Archetype\n    const components = component.reduce((res, instance) => {\n      const isOn = toggleBit(instance.id, bitfieldCopy); // this is also modifying bitfieldCopy\n      if (isOn) res.push(instance);\n      return res;\n    }, [] as ComponentInstance<unknown>[]);\n\n    // Pre-evaluate the bitfield copy's ID after toggling components\n    const bitfieldId = bitfieldCopy.toString();\n\n    return [\n      bitfieldId,\n      () => {\n        const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldId });\n        if (!Array.isArray(component)) cloneCache.set(component, clone);\n        const add = <T>(c: ComponentInstance<T>) => {\n          if (components.includes(c)) clone.components.add(c);\n        };\n        archetype.components.forEach(add);\n        components.forEach(add);\n        return clone;\n      },\n    ];\n  };\n}\n\n/** Instantiate World's Archetype functions */\nexport function createArchetypeManager(spec: ArchetypeManagerSpec): ArchetypeManager {\n  const { EMPTY_BITFIELD, capacity, toggleBit } = spec;\n\n  /** Map<Archetype.id, Archetype> */\n  const archetypeMap: Map<string, Archetype> = new Map();\n\n  /** arr[entity] = the entity's archetype */\n  const entityArchetypes: Archetype[] = [];\n  entityArchetypes.length = capacity; // @note V8 hack\n\n  // exported this through the manager for consistency\n  const createArchetype = _createArchetype;\n\n  const EMPTY_ARCHETYPE = createArchetype({ bitfield: EMPTY_BITFIELD });\n\n  const cloneArchetypeWithToggle = archetypeCloner(createArchetype, toggleBit);\n\n  /** @returns the Entity's Archetype or undefined if Entity is not alive */\n  const getEntityArchetype = (entity: Entity): Archetype | undefined => entityArchetypes[entity];\n\n  const purgeArchetypesCaches = () => archetypeMap.forEach(purgeArchetypeCaches);\n\n  const refreshArchetypes = (queries: Map<Query, QueryInstance>) => {\n    archetypeMap.forEach((archetype) => {\n      refreshArchetype(archetype);\n      const isCandidate = isArchetypeCandidate(archetype);\n      // Refresh the Query's Archetype candidate registry\n      queries.forEach((query) => {\n        query[$_DIRTY] = false;\n        if (isCandidate(query)) {\n          query[$_DIRTY] = true;\n          query.archetypes.add(archetype);\n        }\n      });\n    });\n  };\n\n  const removeEntityFromArchetype = (entity: Entity, archetype: Archetype) => {\n    delete entityArchetypes[entity];\n    return _removeEntityFromArchetype(entity, archetype);\n  };\n\n  const setEntityArchetype = (entity: Entity, archetype: Archetype) => (entityArchetypes[entity] = archetype);\n\n  /**\n   * Update an entity's archetype\n   * @param entity the entity to update\n   * @param component the component to toggle\n   * @returns the entity's new archetype\n   */\n  const updateArchetype = (entity: Entity, component: ComponentInstances) => {\n    const previousArchetype = getEntityArchetype(entity);\n    if (previousArchetype) removeEntityFromArchetype(entity, previousArchetype);\n    const [id, factory] = cloneArchetypeWithToggle(previousArchetype ?? EMPTY_ARCHETYPE, component);\n    const nextArchetype = archetypeMap.get(id) ?? factory();\n    archetypeMap.set(id, nextArchetype);\n    addEntityToArchetype(entity, nextArchetype);\n    setEntityArchetype(entity, nextArchetype);\n    return nextArchetype;\n  };\n\n  return {\n    EMPTY_ARCHETYPE,\n    createArchetype,\n    getEntityArchetype,\n    isArchetypeCandidate,\n    purgeArchetypesCaches,\n    refreshArchetypes,\n    removeEntityFromArchetype,\n    setEntityArchetype,\n    updateArchetype,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Entity } from \"../entity.js\";\nimport type { SchemaStorage } from \"./schema.js\";\n\nexport type StorageProxy<T> = Record<keyof T, number> & { eid: Entity };\n\nexport function storageProxy<T>(storage: SchemaStorage<T>, changed: Set<Entity>): StorageProxy<T> {\n  if (!storage) throw new SyntaxError(\"Proxy can only be used on components, not tags.\");\n\n  let entityId: Entity = 0 as Entity;\n\n  return Object.keys(storage).reduce(\n    (res, key) => {\n      Object.defineProperty(res, key, {\n        get() {\n          return storage[key as keyof T][entityId];\n        },\n        set(value: number) {\n          storage[key as keyof T][entityId] = value;\n          changed.add(entityId);\n        },\n      });\n      return res;\n    },\n    {\n      get eid(): Entity {\n        return entityId;\n      },\n      set eid(entity: Entity) {\n        entityId = entity;\n      },\n    } as StorageProxy<T>,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_CHANGED, $_COUNT } from \"../constants.js\";\nimport type { Entity } from \"../entity.js\";\nimport { isObject, isUint32, TypedArray } from \"../utils/utils.js\";\nimport type { Component } from \"./component.js\";\nimport { StorageProxy, storageProxy } from \"./proxy.js\";\nimport type { SchemaStorage } from \"./schema.js\";\n\ninterface ComponentInstanceSpec<T> {\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport type ComponentInstance<T> = Component<T> &\n  Record<keyof T, TypedArray> & {\n    [$_CHANGED]: Set<Entity>;\n    [$_COUNT]: number;\n    /** Entities who's properties have been changed via .proxy since last refresh */\n    changed: IterableIterator<Entity>;\n    /** The number of entities which have this component instance */\n    count: number;\n    /** The instance's identifier */\n    id: number;\n    /** */\n    proxy: StorageProxy<T>;\n  };\n\nexport function refreshComponentInstance<T>(instance: ComponentInstance<T>): ComponentInstance<T> {\n  instance[$_CHANGED].clear();\n  return instance;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T>(spec: ComponentInstanceSpec<T>): Readonly<ComponentInstance<T>> {\n  const { component, id, storage } = spec;\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n\n  /** number of entities which have this component instance */\n  let entityCount = 0;\n\n  const changed: Set<Entity> = new Set();\n\n  const instance = Object.create(component, {\n    [$_CHANGED]: {\n      value: changed,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n    [$_COUNT]: {\n      get() {\n        return entityCount;\n      },\n      set(value: number) {\n        entityCount = value;\n      },\n    },\n    changed: {\n      get() {\n        return changed.values();\n      },\n      configurable: false,\n      enumerable: true,\n    },\n    count: {\n      get() {\n        return entityCount;\n      },\n      configurable: false,\n      enumerable: true,\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n\n  if (storage) {\n    // create instance.proxy\n    Object.defineProperty(instance, \"proxy\", {\n      value: storageProxy(storage, changed),\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    });\n    // assign raw storage\n    Object.assign(instance, storage);\n  }\n\n  return Object.freeze(instance);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { EMPTY_SYMBOL } from \"../constants.js\";\nimport type { Entity } from \"../entity.js\";\nimport { createAvailabilityArray, TypedArray } from \"./utils.js\";\n\n/**\n * @param dense the typed array to apply the facade to\n * @returns A proxy to the dense array\n */\nexport function sparseFacade<T extends TypedArray>(dense: T): T {\n  /** Map<Entity, Dense Array Index> */\n  const sparse: Map<Entity, number> = new Map();\n\n  /** Array of available indexes in dense */\n  const available = createAvailabilityArray(dense.length);\n\n  /** @returns the entity's value from the dense array or undefined if non-existant */\n  const getter = (entity: Entity) => dense[sparse.get(entity) ?? (EMPTY_SYMBOL as unknown as number)];\n\n  /** @returns `false` if dense array is full, `true` if value set successfully */\n  const set = (entity: Entity, value: T[0]): boolean => {\n    const idx = sparse.get(entity) ?? available.pop();\n    if (idx === undefined) return false;\n    dense[idx] = value;\n    sparse.set(entity, idx);\n    return true;\n  };\n\n  /** @returns `false` if the entity isn't already stored, `true` if deleted successfully */\n  const remove = (entity: Entity): boolean => {\n    const idx = sparse.get(entity);\n    if (idx === undefined) return false;\n    dense[idx] = 0;\n    sparse.delete(entity);\n    available.push(idx);\n    return true;\n  };\n\n  return new Proxy(dense, {\n    get: (_target: T, key: string | symbol) => getter(key as unknown as Entity),\n    set: (_target: T, key: string | symbol, value: T[0]) => set(key as unknown as Entity, value),\n    deleteProperty: (_target: T, key: string | symbol) => remove(key as unknown as Entity),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Bitfield } from \"../bitfield.js\";\nimport { $_COUNT } from \"../constants.js\";\nimport type { Entity } from \"../entity.js\";\nimport { ComponentBufferPartitioner, createComponentBuffer, createComponentBufferPartitioner } from \"./buffer.js\";\nimport type { Component } from \"./component.js\";\nimport { ComponentInstance, createComponentInstance } from \"./instance.js\";\nimport type { SchemaProps } from \"./schema.js\";\n\n/** { [component name]: component instance } */\nexport type ComponentRecord = Record<string, ComponentInstance<unknown>>;\n\nexport type ComponentMap = Map<Component<unknown>, ComponentInstance<unknown>>;\n\nexport interface ComponentManager {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  addComponentsToEntity: (\n    ...components: Component<unknown>[]\n  ) => (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => ComponentInstance<unknown>[];\n  addComponentToEntity: <T>(component: Component<T>) => (entity: Entity, properties?: SchemaProps<T>) => boolean;\n  getBuffer: () => ArrayBuffer;\n  getEntityProperties: (entity: Entity) => Record<string, SchemaProps<unknown>>;\n  hasComponent: <T>(component: Component<T>) => (entity: Entity) => boolean;\n  removeComponentFromEntity: <T>(component: Component<T>) => (entity: Entity) => boolean;\n  removeComponentsFromEntity: (...components: Component<unknown>[]) => (entity: Entity) => ComponentInstance<unknown>[];\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n  withComponents: (...components: Component<unknown>[]) => (...entities: Entity[]) => Entity[];\n}\n\ninterface ComponentManagerSpec {\n  capacity: number;\n  components: Component<unknown>[];\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  isBitOn: (bit: number, bitfield: Bitfield) => boolean;\n  isValidEntity: (entity: Entity) => entity is Entity;\n  updateArchetype: (entity: Entity, component: ComponentInstance<unknown> | ComponentInstance<unknown>[]) => Archetype;\n}\n\ntype R<C> = C extends Component<unknown> ? ComponentInstance<unknown> : ComponentInstance<unknown>[];\n\ninterface ComponentManagerFns {\n  adder: (entity: Entity) => <T>(instance: ComponentInstance<T>) => ComponentInstance<T> | null;\n  getInstances: <C extends Component<unknown> | Component<unknown>[]>(components: C) => R<C>;\n  isMatch: ({ bitfield }: Archetype) => ({ id }: ComponentInstance<unknown>) => boolean;\n}\n\n/**\n * Create component instances for the world\n * @param spec The function's specification object\n * @param spec.components An array of components to instantiate\n * @param spec.capacity The associated world's component buffer partitioner function\n * @returns an object whose keys are component names, and whose values are component instances\n */\nfunction instantiateComponents(spec: {\n  components: Component<unknown>[];\n  partitioner: ComponentBufferPartitioner;\n}): ComponentMap {\n  const { components, partitioner } = spec;\n  const reducer = <T>(res: ComponentMap, component: Component<T>, id: number) => {\n    const storage = partitioner(component);\n    const instance = createComponentInstance({ component, id, storage });\n    res.set(component, instance);\n    return res;\n  };\n  return [...new Set(components)].reduce(reducer, new Map() as ComponentMap);\n}\n\n/** @private */\nfunction createStorage(capacity: number, components: Component<unknown>[]): [ArrayBuffer, ComponentBufferPartitioner] {\n  const buffer = createComponentBuffer({ capacity, components });\n  const partitioner = createComponentBufferPartitioner({ buffer, capacity });\n  return [buffer, partitioner];\n}\n\n/** @private */\nfunction bufferFns(buffer: ArrayBuffer): [() => ArrayBuffer, (source: ArrayBuffer) => ArrayBuffer] {\n  /** @returns a copy of the component storage buffer */\n  const getBuffer = (): ArrayBuffer => buffer.slice(0);\n\n  /** */\n  const setBuffer = (source: ArrayBuffer): ArrayBuffer => {\n    if (source.byteLength !== buffer.byteLength) {\n      throw new Error(\"setBuffer - byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(buffer);\n    target.set(view);\n    return buffer.slice(0);\n  };\n\n  return [getBuffer, setBuffer];\n}\n\n/** @private */\nconst _setDefaults = <T>(entity: Entity, instance: ComponentInstance<T>) => {\n  const { schema } = instance;\n  if (schema) {\n    Object.entries(schema).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n        instance[key][entity] = value[1] ?? 0;\n      }\n    });\n  }\n};\n\n/** @private */\nconst _setCustom = <T>(entity: Entity, instance: ComponentInstance<T>, properties: SchemaProps<T>) => {\n  Object.entries(properties).forEach(([key, value]) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    instance[key][entity] = value ?? 0;\n  });\n};\n\n/** @private */\nconst _setter = <T>(entity: Entity, instance: ComponentInstance<T>, properties?: SchemaProps<T>) => {\n  // @note modifies the instance\n  // @todo merge default and custom property objects and set once\n  _setDefaults(entity, instance);\n  if (properties) _setCustom(entity, instance, properties);\n};\n\n/** @private */\nfunction _adder(spec: ComponentManagerSpec) {\n  const { isValidEntity, getEntityArchetype, isBitOn } = spec;\n  return (entity: Entity) => {\n    if (!isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n    return <T>(instance: ComponentInstance<T>) => {\n      const archetype = getEntityArchetype(entity);\n      if (!archetype) throw new SyntaxError(`Archetype for Entity ${entity} not found.`);\n      const { count, id, maxEntities } = instance;\n      if (isBitOn(id, archetype.bitfield)) return instance;\n      if (maxEntities && count >= maxEntities) return null;\n      instance[$_COUNT] = count + 1;\n      return instance;\n    };\n  };\n}\n\n/** @private */\nfunction _addMultiple(\n  adder: (entity: Entity) => <T>(instance: ComponentInstance<T>) => ComponentInstance<T> | null,\n  updateArchetype: (entity: Entity, component: ComponentInstance<unknown> | ComponentInstance<unknown>[]) => Archetype,\n  instances: ComponentInstance<unknown>[],\n) {\n  return (entity: Entity, properties: Record<string, SchemaProps<unknown>> = {}): ComponentInstance<unknown>[] => {\n    const add = adder(entity);\n    const added = instances.map(add).filter((x) => x) as ComponentInstance<unknown>[];\n    added.forEach((instance) => _setter(entity, instance, properties[instance.name]));\n    updateArchetype(entity, added);\n    return added;\n  };\n}\n\n/** @private */\nfunction _addComponentsToEntity(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { updateArchetype } = spec;\n  const { adder, getInstances } = fns;\n  return (...components: Component<unknown>[]) => {\n    const instances = getInstances(components) as ComponentInstance<unknown>[];\n    if (instances.length !== components.length) {\n      throw new SyntaxError(\"Not all components are registered in the world!\");\n    }\n    return _addMultiple(adder, updateArchetype, instances);\n  };\n}\n\n/** @private */\nfunction _addSingle<T>(\n  adder: (entity: Entity) => <T>(instance: ComponentInstance<T>) => ComponentInstance<T> | null,\n  updateArchetype: (entity: Entity, component: ComponentInstance<unknown> | ComponentInstance<unknown>[]) => Archetype,\n  instance: ComponentInstance<T>,\n) {\n  return (entity: Entity, properties?: SchemaProps<T>): boolean => {\n    if (adder(entity)(instance)) return false;\n    _setter(entity, instance, properties);\n    updateArchetype(entity, instance);\n    return true;\n  };\n}\n\n/** @private */\nfunction _addComponentToEntity(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { updateArchetype } = spec;\n  const { adder, getInstances } = fns;\n  return <T>(component: Component<T>) => {\n    const instance = getInstances(component);\n    if (!instance) throw new SyntaxError(`Component ${component.name} is not registered in the world.`);\n    return _addSingle(adder, updateArchetype, instance);\n  };\n}\n\n/** @private */\nfunction _getEntityProperties({ getEntityArchetype }: ComponentManagerSpec) {\n  return (entity: Entity): Record<string, SchemaProps<unknown>> => {\n    const archetype = getEntityArchetype(entity);\n    if (!archetype) return {};\n    const { components } = archetype;\n    return [...components].reduce(<T>(res: Record<string, SchemaProps<unknown>>, component: ComponentInstance<T>) => {\n      const { name, schema } = component;\n      res[name] = {};\n      if (schema === null) {\n        res[name] = true;\n      } else {\n        res[name] = Object.keys(schema).reduce((prev, key) => {\n          prev[key as keyof T] = component[key as keyof T][entity];\n          return prev;\n        }, {} as SchemaProps<T>);\n      }\n      return res;\n    }, {});\n  };\n}\n\n/** @private */\nfunction _hasComponent(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { getEntityArchetype, isBitOn } = spec;\n  const { getInstances } = fns;\n  return <T>(component: Component<T>): ((entity: Entity) => boolean) => {\n    const instance = getInstances(component);\n    if (!instance) throw new SyntaxError(`Component ${component.name} is not registered!`);\n    return (entity: Entity): boolean => {\n      const archetype = getEntityArchetype(entity);\n      if (!archetype) return false;\n      return isBitOn(instance.id, archetype.bitfield);\n    };\n  };\n}\n\n/** @private */\nfunction _deleteStorageValues<T>(instance: ComponentInstance<T>, entity: Entity) {\n  const { maxEntities, schema } = instance;\n  // make sure facade storage is freed for those that need it\n  if (maxEntities && schema) {\n    Object.keys(schema).forEach((key) => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      delete instance[key][entity];\n    });\n  }\n}\n\n/** @private */\nfunction _removeComponentFromEntity(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { getEntityArchetype, isBitOn, updateArchetype } = spec;\n  const { getInstances } = fns;\n  return (component: Component<unknown>) => {\n    const instance = getInstances(component);\n    if (!instance) throw new SyntaxError(`Component ${component.name} is not registered!`);\n    return (entity: Entity): boolean => {\n      const archetype = getEntityArchetype(entity);\n      if (archetype && !isBitOn(instance.id, archetype.bitfield)) return true;\n      instance[$_COUNT] = instance[$_COUNT] - 1;\n      _deleteStorageValues(instance, entity);\n      updateArchetype(entity, instance);\n      return true;\n    };\n  };\n}\n\n/** @private */\nfunction _removeMultiple(spec: ComponentManagerSpec) {\n  const { getEntityArchetype, isBitOn, updateArchetype } = spec;\n  return (instances: ComponentInstance<unknown>[]) => {\n    return (entity: Entity): ComponentInstance<unknown>[] => {\n      const archetype = getEntityArchetype(entity);\n      const _getStatus = <T>(instance: ComponentInstance<T>): ComponentInstance<T> | undefined => {\n        if (archetype && !isBitOn(instance.id, archetype.bitfield)) return;\n        instance[$_COUNT] = instance[$_COUNT] - 1;\n        _deleteStorageValues(instance, entity);\n        return instance;\n      };\n      const removed = instances.map(_getStatus).filter((x) => x) as ComponentInstance<unknown>[];\n      updateArchetype(entity, removed);\n      return removed;\n    };\n  };\n}\n\n/** @private */\nfunction _removeComponentsFromEntity(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { getInstances } = fns;\n  const removeMultiple = _removeMultiple(spec);\n  return (...components: Component<unknown>[]) => {\n    const instances = getInstances(components);\n    if (instances.length !== components.length) throw new SyntaxError(\"Not all components were found!\");\n    return removeMultiple(instances);\n  };\n}\n\n/** @private */\nfunction _withComponents(spec: ComponentManagerSpec, fns: ComponentManagerFns) {\n  const { getEntityArchetype } = spec;\n  const { getInstances, isMatch } = fns;\n  return (...components: Component<unknown>[]) => {\n    const instances = getInstances(components);\n    const _reducer = (res: Entity[], entity: Entity) => {\n      const archetype = getEntityArchetype(entity);\n      if (!archetype) return res;\n      const _match = isMatch(archetype);\n      if (instances.every(_match)) res.push(entity);\n      return res;\n    };\n    return (...entities: Entity[]) => entities.reduce(_reducer, []);\n  };\n}\n\n/** @private */\nfunction _getInstances(componentMap: ComponentMap) {\n  const _getter = (component: Component<unknown>) => componentMap.get(component);\n  return <C extends Component<unknown> | Component<unknown>[]>(components: C): R<C> => {\n    if (Array.isArray(components)) {\n      return components.map(_getter).filter((x) => x) as R<C>;\n    }\n    return _getter(components) as R<C>;\n  };\n}\n\nfunction _isMatch(isBitOn: (bit: number, bitfield: Bitfield) => boolean) {\n  return ({ bitfield }: Archetype) => {\n    return ({ id }: ComponentInstance<unknown>) => {\n      return isBitOn(id, bitfield);\n    };\n  };\n}\n\n/**\n *\n * @param spec\n * @returns\n */\nexport function createComponentManager(spec: ComponentManagerSpec): ComponentManager {\n  const { capacity, components, isBitOn } = spec;\n\n  const [buffer, partitioner] = createStorage(capacity, components);\n\n  const [getBuffer, setBuffer] = bufferFns(buffer);\n\n  const componentMap = instantiateComponents({ components, partitioner });\n\n  const fns = {\n    adder: _adder(spec),\n    getInstances: _getInstances(componentMap),\n    isMatch: _isMatch(isBitOn),\n  };\n\n  return {\n    // properties\n    componentMap,\n    // methods\n    addComponentToEntity: _addComponentToEntity(spec, fns),\n    addComponentsToEntity: _addComponentsToEntity(spec, fns),\n    getEntityProperties: _getEntityProperties(spec),\n    hasComponent: _hasComponent(spec, fns),\n    getBuffer,\n    removeComponentFromEntity: _removeComponentFromEntity(spec, fns),\n    removeComponentsFromEntity: _removeComponentsFromEntity(spec, fns),\n    setBuffer,\n    withComponents: _withComponents(spec, fns),\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ONE_BYTE } from \"../constants.js\";\nimport { sparseFacade } from \"../utils/sparse-facade.js\";\nimport { multipleOf4, TypedArrayConstructor } from \"../utils/utils.js\";\nimport type { Component } from \"./component.js\";\nimport type { SchemaStorage } from \"./schema.js\";\n\ninterface ComponentBufferSpec {\n  capacity: number;\n  components: Component<unknown>[];\n}\n\ninterface ComponentBufferPartitionerSpec {\n  buffer: ArrayBuffer;\n  capacity: number;\n}\n\n/** <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray } */\nexport type ComponentBufferPartitioner = <T>(component: Component<T>) => SchemaStorage<T> | undefined;\n\n/** Calculate the total required storage space for all component schemas */\nfunction getComponentSize(capacity: number, components: Component<unknown>[]) {\n  const componentSum = <T>(total: number, component: Component<T>): number => {\n    const { size } = component;\n    if (!size || size <= 0) return total;\n    return total + size * capacity;\n  };\n  return components.reduce(componentSum, 0);\n}\n\n/**\n * Create a properly sized ArrayBuffer to hold all a world's component's data.\n * @param spec The component buffer's specification object\n * @param spec.capacity The world's entity capacity\n * @param spec.components The components which the buffer will contain\n */\nexport function createComponentBuffer(spec: ComponentBufferSpec): ArrayBuffer {\n  const { capacity, components } = spec;\n  const totalSize = getComponentSize(capacity, components);\n  return new ArrayBuffer(ONE_BYTE * Math.ceil(totalSize / ONE_BYTE));\n}\n\n/**\n * Creates a function which allows for the creation of component storage partitions.\n * @param spec the partitioner's specification object\n * @param spec.buffer the buffer to partition\n * @param spec.capacity the world's entity capacity\n * @returns <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray };\n */\nexport function createComponentBufferPartitioner(spec: ComponentBufferPartitionerSpec): ComponentBufferPartitioner {\n  const { buffer, capacity } = spec;\n  let bufferOffset = 0;\n  let full = false;\n\n  return <T>(component: Component<T>): SchemaStorage<T> | undefined => {\n    if (full === true) throw new Error(\"ArrayBuffer is full!\");\n    const { maxEntities, schema, size = 0 } = component;\n    if (!schema || size <= 0) return; // bail early if component is a tag\n    const requiredSize = maxEntities ?? capacity;\n\n    if (bufferOffset + size * requiredSize > buffer.byteLength) {\n      throw new Error(\"Component will not fit inside the buffer!\");\n    }\n\n    let componentOffset = 0;\n    const partition = (\n      res: SchemaStorage<T>,\n      [key, value]: [keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]],\n    ) => {\n      let typedArray = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) {\n        [typedArray, initialValue] = value;\n      }\n      const dense = new typedArray(buffer, bufferOffset + componentOffset, requiredSize);\n      res[key] = maxEntities === null ? dense : sparseFacade(dense);\n      if (initialValue !== 0) res[key].fill(initialValue as never);\n      componentOffset = multipleOf4(componentOffset + typedArray.BYTES_PER_ELEMENT * requiredSize);\n      return res;\n    };\n\n    const data = Object.entries(schema) as [keyof T, TypedArrayConstructor][];\n    const storage = data.reduce(partition, {} as SchemaStorage<T>);\n\n    bufferOffset += componentOffset;\n    if (bufferOffset > buffer.byteLength) full = true;\n\n    return storage;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Archetype } from \"./archetype/archetype.js\";\nimport { createAvailabilityArray, isUint32, Opaque } from \"./utils/utils.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\ninterface EntityManagerSpec {\n  capacity: number;\n  EMPTY_ARCHETYPE: Archetype;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  removeEntityFromArchetype: (entity: Entity, archetype: Archetype) => Archetype;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => Archetype;\n}\n\ninterface EntityManager {\n  createEntity: () => Entity | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getVacancyCount: () => number;\n  hasEntity: (entity: Entity) => boolean;\n  isValidEntity: (entity: Entity) => entity is Entity;\n}\n\n/** Type-guard for Entity */\nfunction entityValidator(capacity: number): (entity: Entity) => entity is Entity {\n  /** @return `true` if the given entity is valid for the given capacity */\n  return function isValidEntity(entity: Entity): entity is Entity {\n    return isUint32(entity) && entity <= capacity;\n  };\n}\n\n/** Manages the creation, destruction and recycling of entities */\nexport function createEntityManager(spec: EntityManagerSpec): EntityManager {\n  const { capacity, EMPTY_ARCHETYPE, getEntityArchetype, removeEntityFromArchetype, setEntityArchetype } = spec;\n\n  const availableEntities = createAvailabilityArray(capacity) as Entity[];\n  const isValidEntity = entityValidator(capacity);\n\n  return {\n    /** @returns the next available Entity or `undefined` if no Entity is available */\n    createEntity(): Entity | undefined {\n      const entity = availableEntities.pop();\n      if (entity !== undefined) setEntityArchetype(entity, EMPTY_ARCHETYPE);\n      return entity;\n    },\n\n    /**\n     * Remove and recycle an Entity\n     * @returns `true` if there was an archetype change\n     */\n    destroyEntity(entity: Entity): boolean {\n      if (!isValidEntity(entity)) return false;\n      const archetype = getEntityArchetype(entity);\n      if (!archetype) return false;\n      removeEntityFromArchetype(entity, archetype);\n      availableEntities.push(entity);\n      return true;\n    },\n\n    /** @returns the number of available entities */\n    getVacancyCount() {\n      return availableEntities.length;\n    },\n\n    /** @return `true` if the Entity !== undefined */\n    hasEntity(entity: Entity): boolean {\n      return isValidEntity(entity) && getEntityArchetype(entity) !== undefined;\n    },\n\n    isValidEntity,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport type { Bitfield } from \"../bitfield.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { ComponentRecord } from \"../component/manager.js\";\nimport type { Entity } from \"../entity.js\";\nimport { createQueryInstance, QueryInstance } from \"./instance.js\";\nimport { isValidQuery, Query } from \"./query.js\";\n\ninterface QueryManagerSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  createBitfieldFromIds: (components: ComponentInstance<unknown>[]) => Bitfield;\n}\n\nexport interface QueryManager {\n  queryMap: Map<Query, QueryInstance>;\n  /** Entities which have entered this query since last refresh */\n  getQueryEntered: (query: Query) => Entity[];\n  /** Entities which have exited this query since last refresh */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of Components and Entities which match the Query criteria */\n  getQueryResult: (query: Query) => [ComponentRecord, () => Entity[]];\n}\n\nfunction flattenEntities(this: Entity[], { entities }: Archetype) {\n  this.push(...entities);\n}\n\n/**\n *\n * @param query\n * @returns\n * @todo cache entities per archetype and add a dirty flag to archetypes - only update entities from dirty archetypes\n */\nexport function getEntitiesFromQuery(query: QueryInstance, cache: Map<QueryInstance, Set<Entity>>): Entity[] {\n  const { archetypes } = query;\n\n  // if new query, do full sweep and create cache set\n  if (!cache.has(query)) {\n    const res: Entity[] = [];\n    archetypes.forEach(flattenEntities, res);\n    cache.set(query, new Set(res));\n    return res;\n  }\n\n  const cached = cache.get(query) as Set<Entity>;\n  const adder = (e: Entity) => cached.add(e);\n  const remover = (e: Entity) => cached.delete(e);\n\n  // if query has new Archetypes, do full sweep\n  if (query.isDirty) {\n    const res: Entity[] = [];\n    archetypes.forEach(flattenEntities, res);\n    res.forEach(adder);\n    return res;\n  }\n\n  // else just update the dirty archetypes\n  archetypes.forEach((archetype) => {\n    archetype.entered.forEach(adder);\n    archetype.exited.forEach(remover);\n  });\n\n  return [...cached];\n}\n\n/**\n *\n * @param query\n * @returns\n */\nexport function getEnteredFromQuery(query: QueryInstance): Entity[] {\n  return [...query.archetypes].flatMap((archetype) => [...archetype.entered]);\n}\n\n/**\n *\n * @param query\n * @returns\n */\nexport function getExitedFromQuery(query: QueryInstance): Entity[] {\n  return [...query.archetypes].flatMap((archetype) => [...archetype.exited]);\n}\n\nexport function createQueryManager(spec: QueryManagerSpec): QueryManager {\n  const { createBitfieldFromIds, componentMap } = spec;\n\n  /** Map of registered Queries and their instances */\n  const queryMap: Map<Query, QueryInstance> = new Map();\n\n  const entityCache: Map<QueryInstance, Set<Entity>> = new Map();\n\n  /** Register a Query in the world, producing a QueryInstance */\n  const registerQuery = (query: Query): QueryInstance => {\n    if (!isValidQuery(query)) throw new Error(\"Object is not a valid query.\");\n    const instance = createQueryInstance({ createBitfieldFromIds, componentMap, query });\n    queryMap.set(query, instance);\n    return instance;\n  };\n\n  /** @private utility function to get QueryInstance from Query in the world */\n  const _getQueryInstance = (query: Query): QueryInstance => queryMap.get(query) ?? registerQuery(query);\n\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  const getQueryResult = (query: Query): [ComponentRecord, () => Entity[]] => {\n    const instance = _getQueryInstance(query);\n    return [instance.components, () => getEntitiesFromQuery(instance, entityCache)];\n  };\n\n  /** Entities which have entered this query since last refresh */\n  const getQueryEntered = (query: Query): Entity[] => getEnteredFromQuery(_getQueryInstance(query));\n\n  /** Entities which have exited this query since last refresh */\n  const getQueryExited = (query: Query): Entity[] => getExitedFromQuery(_getQueryInstance(query));\n\n  return {\n    queryMap,\n    getQueryEntered,\n    getQueryExited,\n    getQueryResult,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Bitfield } from \"../bitfield.js\";\nimport { $_DIRTY } from \"../constants.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Query } from \"./query.js\";\n\ninterface QueryInstanceSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  createBitfieldFromIds: (components: ComponentInstance<unknown>[]) => Bitfield;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  /** @private Provides a getter and setter for the `isDirty` flag */\n  [$_DIRTY]: boolean;\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield>;\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  components: Record<string, ComponentInstance<unknown>>;\n  /** `true` if the object is in a dirty state */\n  isDirty: boolean;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield>;\n}\n\n/**\n *\n * @param world\n * @param query\n * @returns\n */\nexport function createQueryInstance(spec: QueryInstanceSpec): QueryInstance {\n  const { createBitfieldFromIds, componentMap, query } = spec;\n  const { all, any, none } = query;\n\n  /** */\n  const getComponentInstances = <T>(arr: ComponentInstance<unknown>[], component: Component<T>, idx: number) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr[idx] = inst as ComponentInstance<T>;\n    return arr;\n  };\n\n  /** */\n  const _allInstances = all.reduce(getComponentInstances, new Array(all.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const and = createBitfieldFromIds(_allInstances);\n\n  /** */\n  const _anyInstances = any.reduce(getComponentInstances, new Array(any.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const or = createBitfieldFromIds(_anyInstances);\n\n  /** */\n  const _noneInstances = none.reduce(getComponentInstances, new Array(none.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const not = createBitfieldFromIds(_noneInstances);\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<unknown>> = [..._allInstances, ..._anyInstances].reduce(\n    (components, component) => {\n      components[component.name] = component;\n      return components;\n    },\n    {} as Record<string, ComponentInstance<unknown>>,\n  );\n  Object.freeze(components);\n\n  /** */\n  const archetypes: Set<Archetype> = new Set();\n\n  let isDirty = true;\n\n  return Object.assign(Object.create(query), {\n    get [$_DIRTY](): boolean {\n      return isDirty;\n    },\n    set [$_DIRTY](dirty: boolean) {\n      isDirty = !!dirty;\n    },\n    get isDirty(): boolean {\n      return isDirty;\n    },\n    archetypes,\n    and,\n    components,\n    not,\n    or,\n  }) as QueryInstance;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Archetype } from \"./archetype/archetype.js\";\nimport { createArchetypeManager } from \"./archetype/manager.js\";\nimport { bitfieldFactory } from \"./bitfield.js\";\nimport type { Component } from \"./component/component.js\";\nimport { ComponentInstance, refreshComponentInstance } from \"./component/instance.js\";\nimport { ComponentRecord, createComponentManager } from \"./component/manager.js\";\nimport type { SchemaProps } from \"./component/schema.js\";\nimport { DEFAULT_MAX_ENTITIES, VERSION } from \"./constants.js\";\nimport { createEntityManager, Entity } from \"./entity.js\";\nimport { createQueryManager } from \"./query/manager.js\";\nimport type { Query } from \"./query/query.js\";\nimport { createSerializationManager, MiskiData } from \"./serialize.js\";\nimport { isUint32 } from \"./utils/utils.js\";\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world  */\n  components: Component<unknown>[];\n}\n\nexport interface World {\n  /** The maximum number of entities allowed in the world */\n  readonly capacity: number;\n  /** The Miski version used to create this World */\n  readonly version: string;\n  /** Add multiple components to an entity at once by defining a prefab. */\n  addComponentsToEntity: (\n    ...components: Component<unknown>[]\n  ) => (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => ComponentInstance<unknown>[];\n  /**\n   * Add a component to an entity.\n   * @param component the component to add.\n   * @param entity the entity to add the component to.\n   * @param props optional initial component values to set for the entity.\n   * @returns `true` if the component was added successfully.\n   */\n  addComponentToEntity: <T>(component: Component<T>) => (entity: Entity, properties?: SchemaProps<T>) => boolean;\n  /**\n   * Create a new entity for use in the world.\n   * @returns the entity or `undefined` if no entities were available.\n   */\n  createEntity: () => Entity | undefined;\n  /**\n   * Destroy a given entity.\n   * @returns `true` if the entity was successfully destroyed.\n   */\n  destroyEntity: (entity: Entity) => boolean;\n  /**\n   * Get a given entity's archetype.\n   * @param entity the entity to expose.\n   * @returns the Archetype object or `undefined` if no archetype found.\n   */\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  /** Get all component properties for a given entity */\n  getEntityProperties: (entity: Entity) => Record<string, SchemaProps<unknown>>;\n  /** @returns an array of entities which have entered a query's archetypes since last world.refresh() */\n  getQueryEntered: (query: Query) => Entity[];\n  /** @returns an array of entities which have left a query's archetypes since last world.refresh() */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of entities and components which match the query's criteria */\n  getQueryResult: (query: Query) => [ComponentRecord, () => Entity[]];\n  /** @returns the number of available entities in the world. */\n  getVacancyCount: () => number;\n  /** Test a single component against a single entity */\n  hasComponent: <T>(component: Component<T>) => (entity: Entity) => boolean;\n  /** @returns `true` if the entity is valid and !== undefined */\n  hasEntity: (entity: Entity) => boolean;\n  /**\n   * Load data into the world.\n   * @param data the MiskiData object to load\n   * @returns `true` if all the data was successfully loaded into the world.\n   */\n  load: (data: MiskiData) => boolean;\n  /**\n   * Purge various caches throughout the world.\n   * Should not be necessary but useful if memory footprint is creeping.\n   */\n  purgeCaches: () => void;\n  /**\n   * Run various maintenance functions in the world.\n   * Recommended once per frame.\n   */\n  refresh: () => void;\n  /**\n   * Remove a component from an entity.\n   * @param component the component to remove.\n   * @param entity the entity to remove the component from.\n   * @returns `true` if the component was removed successfully.\n   */\n  removeComponentFromEntity: <T>(component: Component<T>) => (entity: Entity) => boolean;\n  /** Remove multiple components from an entity at once. */\n  removeComponentsFromEntity: (...components: Component<unknown>[]) => (entity: Entity) => ComponentInstance<unknown>[];\n  /** Serialize various aspects of the world's data */\n  save: () => Readonly<MiskiData>;\n  /** Reduces an array of entities to just those who have all the desired components */\n  withComponents: (...components: Component<unknown>[]) => (...entities: Entity[]) => Entity[];\n}\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec) throw new SyntaxError(\"World creation requires a specification object.\");\n  const { capacity = DEFAULT_MAX_ENTITIES, components } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"World creation: spec.capacity invalid.\");\n  if (!components.length) throw new SyntaxError(\"World creation: spec.components invalid.\");\n  return { capacity, components };\n}\n\n/**\n * Create a new World object\n * @param spec The world's specification object\n * @param spec.capacity The maximum number of entities allowed in the world\n * @param spec.components Components to instantiate in the world\n * @returns a new, frozen World object\n */\nexport function createWorld(spec: WorldSpec): Readonly<World> {\n  const { capacity, components } = validateWorldSpec(spec);\n\n  // eslint-disable-next-line prettier/prettier\n  const {\n    EMPTY_BITFIELD,\n    createBitfieldFromIds,\n    isBitOn,\n    toggleBit,\n  } = bitfieldFactory(components.length);\n\n  const {\n    EMPTY_ARCHETYPE,\n    getEntityArchetype,\n    purgeArchetypesCaches,\n    refreshArchetypes,\n    removeEntityFromArchetype,\n    setEntityArchetype,\n    updateArchetype,\n  } = createArchetypeManager({\n    EMPTY_BITFIELD,\n    capacity,\n    toggleBit,\n  });\n\n  // eslint-disable-next-line prettier/prettier\n  const {\n    createEntity,\n    destroyEntity,\n    getVacancyCount,\n    hasEntity,\n    isValidEntity,\n  } = createEntityManager({\n    capacity,\n    EMPTY_ARCHETYPE,\n    getEntityArchetype,\n    removeEntityFromArchetype,\n    setEntityArchetype,\n  });\n\n  const {\n    componentMap,\n    addComponentsToEntity,\n    addComponentToEntity,\n    getBuffer,\n    getEntityProperties,\n    hasComponent,\n    removeComponentFromEntity,\n    removeComponentsFromEntity,\n    setBuffer,\n    withComponents,\n  } = createComponentManager({\n    capacity,\n    components,\n    getEntityArchetype,\n    isBitOn,\n    isValidEntity,\n    updateArchetype,\n  });\n\n  // eslint-disable-next-line prettier/prettier\n  const {\n    queryMap,\n    getQueryEntered,\n    getQueryExited,\n    getQueryResult,\n  } = createQueryManager({\n    createBitfieldFromIds,\n    componentMap,\n  });\n\n  // eslint-disable-next-line prettier/prettier\n  const {\n    load,\n    save\n  } = createSerializationManager({\n    getBuffer,\n    setBuffer,\n    version: VERSION,\n  });\n\n  const purgeCaches = () => {\n    purgeArchetypesCaches();\n  };\n  purgeCaches();\n\n  const refresh = () => {\n    refreshArchetypes(queryMap);\n    componentMap.forEach(refreshComponentInstance);\n  };\n  refresh();\n\n  return Object.freeze({\n    capacity,\n    version: VERSION,\n\n    addComponentsToEntity,\n    addComponentToEntity,\n    createEntity,\n    destroyEntity,\n    getEntityArchetype,\n    getEntityProperties,\n    getQueryEntered,\n    getQueryExited,\n    getQueryResult,\n    getVacancyCount,\n    hasComponent,\n    hasEntity,\n    load,\n    purgeCaches,\n    refresh,\n    removeComponentFromEntity,\n    removeComponentsFromEntity,\n    save,\n    withComponents,\n  }) as World;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\nimport { isUint32, Opaque } from \"./utils/utils.js\";\n\n/** A Bitfield is just a Uint32Array */\nexport type Bitfield = Opaque<Uint32Array, \"Bitfield\">;\n\n/** @param capacity The required number of bits in the bitfield */\nexport function bitfieldFactory(capacity: number) {\n  if (!isUint32(capacity)) throw new SyntaxError(\"Bitfield capacity is invalid.\");\n\n  /** The array length to accommodate the required capacity */\n  const size = (capacity + 31) >>> 5;\n\n  /** An empty bitfield for use in cloning etc. */\n  const EMPTY_BITFIELD = new Uint32Array(size) as Bitfield;\n\n  /** Check if bit is valid and convert to array index */\n  const getIndex = (bit: number): number => {\n    if (isNaN(bit) || bit < 0 || bit > capacity) return -1;\n    return bit >>> 5;\n  };\n\n  /**\n   * Create a new bitfield\n   * @param objs array of { id: number } type objects to pre-populate the bitfield with\n   */\n  const createBitfieldFromIds = <T extends { id: number }>(objs: T[]): Bitfield => {\n    return objs.reduce((bitfield, { id }) => {\n      const i = getIndex(id);\n      if (i === -1) throw new SyntaxError(`Bitfield: bit ${id} does not exist in this world.`);\n      bitfield[i] &= ~(1 << (id - i * 32));\n      return bitfield;\n    }, new Uint32Array(size) as Bitfield);\n  };\n\n  /** @returns `true` if a given bit is 'on' (i.e., truthy) in the Bitfield */\n  const isBitOn = (bit: number, bitfield: Bitfield): boolean => {\n    const i = getIndex(bit);\n    if (i === -1) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this world.`);\n    const cell = bitfield[i];\n    if (cell === undefined) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this bitfield.`);\n    return Boolean(cell & (1 << (bit - i * 32)));\n  };\n\n  /**\n   * Toggle a bit in the Bitfield\n   * @return the resulting state of the bit\n   */\n  const toggleBit = (bit: number, bitfield: Bitfield): boolean => {\n    const i = getIndex(bit);\n    if (i === -1) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this world.`);\n    if (bitfield[i] === undefined) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this bitfield.`);\n    bitfield[i] ^= 1 << (bit - i * 32);\n    return Boolean(bitfield[i]! & (1 << (bit - i * 32)));\n  };\n\n  return {\n    EMPTY_BITFIELD,\n    createBitfieldFromIds,\n    isBitOn,\n    toggleBit,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\ninterface SerializationManagerSpec {\n  getBuffer: () => ArrayBuffer;\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n  version: string;\n}\n\nexport interface MiskiData {\n  componentBuffer: ArrayBuffer;\n  version: string;\n}\n\nexport interface SerializationManager {\n  load: (data: MiskiData) => boolean;\n  save: () => MiskiData;\n}\n\nexport function createSerializationManager(spec: SerializationManagerSpec): SerializationManager {\n  const { getBuffer, setBuffer, version } = spec;\n\n  function save(): Readonly<MiskiData> {\n    return Object.freeze({\n      componentBuffer: getBuffer(),\n      version,\n    });\n  }\n\n  function load(data: MiskiData): boolean {\n    const { componentBuffer } = data;\n    /** @todo validate! */\n    setBuffer(componentBuffer);\n    return true;\n  }\n\n  return {\n    load,\n    save,\n  };\n}\n"],"names":["DEFAULT_MAX_ENTITIES","FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","EMPTY_SYMBOL","Symbol","$_CHANGED","$_COUNT","$_DIRTY","isUint32","n","isNaN","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","test","includes","isObject","Array","isArray","createAvailabilityArray","capacity","total","from","_","i","intersectBits","a","b","multipleOf4","f","Math","ceil","isValidSchema","schema","entries","every","name","value","_validateProps","byteSum","BYTES_PER_ELEMENT","calculateSchemaSize","values","reduce","createComponent","spec","SyntaxError","maxEntities","isTag","size","mergeQueries","queries","_all","_any","_none","forEach","query","all","any","none","push","createQuery","_validateQueryArrays","component","Set","createSystem","system","world","components","getEntities","getQueryResult","args","createArchetype","bitfield","id","toString","validateSpec","isDirty","dirty","candidateCache","Map","cloneCache","entered","entities","exited","isArchetypeCandidate","archetype","has","get","checkStatus","and","or","not","target","idx","getCandidateStatus","status","set","purgeArchetypeCaches","clear","createArchetypeManager","EMPTY_BITFIELD","toggleBit","archetypeMap","entityArchetypes","_createArchetype","EMPTY_ARCHETYPE","cloneArchetypeWithToggle","cached","bitfieldCopy","slice","res","instance","bitfieldId","clone","add","c","archetypeCloner","getEntityArchetype","entity","removeEntityFromArchetype","delete","_removeEntityFromArchetype","setEntityArchetype","purgeArchetypesCaches","refreshArchetypes","refreshArchetype","isCandidate","archetypes","updateArchetype","previousArchetype","factory","nextArchetype","addEntityToArchetype","storageProxy","storage","changed","entityId","keys","key","defineProperty","eid","refreshComponentInstance","sparseFacade","dense","sparse","available","Proxy","_target","getter","pop","undefined","deleteProperty","remove","instantiateComponents","partitioner","Error","TypeError","entityCount","create","configurable","enumerable","writable","count","assign","createComponentInstance","createStorage","buffer","totalSize","getComponentSize","ArrayBuffer","createComponentBuffer","bufferOffset","full","requiredSize","byteLength","componentOffset","typedArray","initialValue","fill","createComponentBufferPartitioner","_setter","properties","_setDefaults","_setCustom","_adder","isValidEntity","isBitOn","_addComponentsToEntity","fns","adder","getInstances","instances","added","map","filter","x","_addMultiple","_addComponentToEntity","_addSingle","_getEntityProperties","prev","_hasComponent","_deleteStorageValues","_removeComponentFromEntity","_removeComponentsFromEntity","removeMultiple","removed","_removeMultiple","_withComponents","isMatch","_reducer","_match","_getInstances","componentMap","_getter","_isMatch","createComponentManager","getBuffer","setBuffer","source","view","Uint8Array","bufferFns","addComponentToEntity","addComponentsToEntity","getEntityProperties","hasComponent","removeComponentFromEntity","removeComponentsFromEntity","withComponents","createEntityManager","availableEntities","entityValidator","createEntity","destroyEntity","getVacancyCount","hasEntity","flattenEntities","this","createQueryManager","createBitfieldFromIds","queryMap","entityCache","registerQuery","isValidQuery","getComponentInstances","arr","inst","_allInstances","_anyInstances","createQueryInstance","_getQueryInstance","getQueryEntered","flatMap","getEnteredFromQuery","getQueryExited","getExitedFromQuery","cache","e","remover","getEntitiesFromQuery","createWorld","validateWorldSpec","Uint32Array","getIndex","bit","objs","cell","bitfieldFactory","load","save","version","data","componentBuffer","createSerializationManager","purgeCaches","refresh"],"mappings":"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"}