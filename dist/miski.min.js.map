{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/utils/bitfield.ts","../src/archetype/archetype.ts","../src/archetype/manager.ts","../src/component/proxy.ts","../src/component/instance.ts","../src/utils/bitpool.ts","../src/utils/sparse-facade.ts","../src/component/buffer.ts","../src/component/manager.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/** Miski version */\nexport const VERSION: string = \"__VERSION__\"; // __VERSION__ is replaced by rollup\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties:\n  \"changed\",\n  \"component\",\n  \"count\",\n  \"eid\",\n  \"entity\",\n  \"id\",\n  \"isTag\",\n  \"maxEntities\",\n  \"name\",\n  \"owners\",\n  \"proxy\",\n  \"schema\",\n  \"size\",\n  // object properties:\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n\n/** Symbol for use as a key for the `changed` flag getter and setter */\nexport const $_CHANGED = Symbol(\"changed\");\n\n/** Symbol for use as a key for the `owners` flag getter and setter */\nexport const $_OWNERS = Symbol(\"owners\");\n\n/** Lookup table for powers of 2 */\nexport const LOG_2: Record<number, number> = Object.freeze({\n  1: 0,\n  2: 1,\n  4: 2,\n  8: 3,\n  16: 4,\n  32: 5,\n  64: 6,\n  128: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11,\n  4096: 12,\n  8192: 13,\n  16384: 14,\n  32768: 15,\n  65536: 16,\n  131072: 17,\n  262144: 18,\n  524288: 19,\n  1048576: 20,\n  2097152: 21,\n  4194304: 22,\n  8388608: 23,\n  16777216: 24,\n  33554432: 25,\n  67108864: 26,\n  134217728: 27,\n  268435456: 28,\n  536870912: 29,\n  1073741824: 30,\n  2147483648: 31,\n});\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"../constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** @returns true if `n` is a Uint32 > 0 */\nexport function isPositiveInt(n: number) {\n  return isUint32(n) && n > 0;\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    typeof str === \"string\" &&\n    str.length > 0 &&\n    FORBIDDEN_NAMES.includes(str) === false &&\n    VALID_NAME_PATTERN.test(str)\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/**\n * The parameters of a function omitting the first two parameters\n * @author https://stackoverflow.com/a/67605309\n */\nexport type ParametersExceptFirstTwo<F> = F extends (arg0: any, arg1: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n\n/** Creates a function that will round a number up to a given multiple */\nexport function roundUpToMultipleOf(f: number): (n: number) => number {\n  return (n: number) => Math.ceil(n / f) * f;\n}\n\n/** @returns the input rounded up to the closest multiple of 4 */\nexport const multipleOf4 = roundUpToMultipleOf(4);\n\n/** @returns the input rounded up to the closest multiple of 8 */\nexport const multipleOf8 = roundUpToMultipleOf(8);\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isTypedArrayConstructor, isValidName } from \"../utils/utils.js\";\nimport type { TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\n/** Individual entity's component properties */\nexport type SchemaProps<T> = Record<keyof T, number | bigint | undefined>;\n\n/** Internal component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n *\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n *\n * Values in TypedArrays are initialised to 0 by default.\n *\n * To set an initial value: `{ property: [Int8Array, defaultValue] }`.\n *\n * Set to `null` to define a tag component.\n */\nexport type Schema<T> = null | Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Validates the properties of a schema entry */\nfunction _validateProps(value: TypedArrayConstructor | [TypedArrayConstructor, number]): boolean {\n  if (Array.isArray(value)) {\n    // if this is an array, the user wants to set an initial value\n    const [TAC, n] = value;\n    return (!isNaN(n) && isTypedArrayConstructor(TAC));\n  }\n  return isTypedArrayConstructor(value);\n}\n\n/** Validates the names and values of a schema's entries */\nfunction _validateSchemaEntry([name, value]: [string, unknown]): boolean {\n  return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n}\n\n/** Schema type guard */\nexport function isValidSchema<T extends Schema<T>>(schema: unknown): schema is Schema<T> {\n  try {\n    if (schema === undefined) return false;\n    if (schema === null) return true;\n    if (!isObject(schema)) return false;\n    const entries = Object.entries(schema);\n    if (!entries.length) return false;\n    return entries.every(_validateSchemaEntry);\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return ((total as number) + size);\n}\n\n/**\n * @returns the size in bytes that a component's storage requires for one entity\n *          or NaN if the object is invalid;\n */\nexport function calculateSchemaSize<T extends Schema<T>>(schema: Schema<T>): number {\n  try {\n    if (!isValidSchema(schema)) return Number.NaN;\n    if (schema === null) return 0;\n    /** @todo should this be to multipleOf4? */\n    return Object.values(schema).reduce(byteSum, 0) as number;\n  } catch (_) {\n    return Number.NaN;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isPositiveInt, isValidName } from \"../utils/utils.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\nexport interface ComponentSpec<T> {\n  /**\n   * The maximum number of entities able to equip this component per world.\n   *\n   * __Warning__: use this only where memory consumption is a concern, performance will be worse.\n   */\n  maxEntities?: number;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport class Component<T extends Schema<T>> {\n  /** `true` if the component has no schema */\n  readonly isTag: boolean;\n  /** The maximum number of entities able to equip this component per world. */\n  readonly maxEntities: number | null;\n  /** The component's label */\n  readonly name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  readonly schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  readonly size: number;\n\n  /**\n   * Define a new component.\n   * @param spec the component's specification.\n   * @param spec.name the component's string identifier.\n   * @param spec.schema the component's optional schema object.\n   * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n   */\n  constructor(spec: ComponentSpec<T>) {\n    if (!spec) throw new SyntaxError(\"A specification object is required.\");\n    const { maxEntities = null, name, schema = null } = spec;\n    if (maxEntities && !isPositiveInt(maxEntities)) throw new SyntaxError(\"spec.maxEntities must be a Uint32 > 0.\");\n    if (!isValidName(name)) throw new SyntaxError(\"spec.name is invalid.\");\n    if (!isValidSchema(schema)) throw new SyntaxError(\"spec.schema is invalid.\");\n    this.isTag = !schema;\n    this.maxEntities = maxEntities ?? null;\n    this.name = name;\n    this.schema = schema ? Object.freeze({ ...schema }) : null;\n    this.size = schema ? calculateSchemaSize(schema) : 0;\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\nimport type { Schema } from \"../component/schema.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Component<any>[];\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Component<any>[];\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Component<any>[];\n}\n\nfunction _validateQueryArrays<T extends Schema<T>>(component: Component<T>) {\n  return component instanceof Component;\n}\n\nexport class Query {\n  /** AND - Gather entities as long as they have all these components */\n  readonly all: Readonly<Component<any>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  readonly any: Readonly<Component<any>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  readonly none: Readonly<Component<any>[]>;\n\n  /**\n   * Create a new Query\n   *\n   * Queries are groupings of archetypes\n   *\n   * @param spec The Query's specification object\n   * @param spec.all AND - Gather entities as long as they have all these components\n   * @param spec.any OR - Gather entities as long as they have 0...* of these components\n   * @param spec.none NOT - Gather entities as long as they don't have these components\n   */\n  constructor(spec: QuerySpec) {\n    if (!spec) throw new SyntaxError(\"Query specification object is required.\");\n    const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n    if (![...all, ...any, ...none].every(_validateQueryArrays)) {\n      throw new SyntaxError(\"Query specification object is invalid.\");\n    }\n    this.all = Object.freeze([...new Set(all)]);\n    this.any = Object.freeze([...new Set(any)]);\n    this.none = Object.freeze([...new Set(none)]);\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Query } from \"./query/query.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { ParametersExceptFirstTwo } from \"./utils/utils.js\";\nimport type { Entity, World } from \"./world.js\";\n\n/**\n * A multi-arity function where the first two parameters\n * are the components and entities available to\n * the system respectively.\n */\nexport type SystemCallback<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> = (components: ComponentRecord, entities: Entity[], ...args: U) => ReturnType<T>;\n\nexport interface SystemSpec<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n}\n\nexport class System<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n\n  /**\n   * Creates a new system.\n   *\n   * Systems are the behaviours which affect components.\n   *\n   * @param spec the system's specification object\n   */\n  constructor(spec: SystemSpec<T, U>) {\n    const { system, query } = spec;\n    this.system = system;\n    this.query = query;\n  }\n\n  /**\n   * @param world the world to execute the system in\n   * @param args arguments to pass to the system's callback function\n   * @returns the result of the system's callback function\n   */\n  init(world: World): (...args: U) => ReturnType<T> {\n    const components = world.getQueryComponents(this.query);\n    const entities: Entity[] = [];\n    return (...args: U) => this.system(components, world.getQueryEntities(this.query, entities), ...args);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { LOG_2 } from \"../constants.js\";\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\n/** */\nexport class Bitfield extends Uint32Array {\n  static get [Symbol.species](): Uint32ArrayConstructor {\n    return Uint32Array;\n  }\n\n  /** @returns the index of the least significant bit or -1 if error */\n  static getLsbIndex(value: number): number {\n    if (value === 2147483648) return 31;\n    return LOG_2[value & -value] ?? -1;\n  }\n\n  /** @returns the number of set bits in a given number */\n  static getSetBitCount(value: number): number {\n    const a = value - ((value >> 1) & 0x55555555);\n    const b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n    return (((b + (b >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n  }\n\n  /** @returns the number of set bits in a given bitfield */\n  static getSetBitCountInBitfield(bitfield: Bitfield): number {\n    return bitfield.reduce((res, val) => {\n      if (val === 0) return res;\n      return res + Bitfield.getSetBitCount(val);\n    }, 0);\n  }\n\n  /**\n   * Create a new Bitfield from an array of objects\n   * @param length the number of bits in the bitfield\n   * @param key the key of the property to use for the bitfield's indexes\n   * @param objs an array of objects which have the key as an index to a number\n   *\n   * @example\n   * // Creating 32 bit bitfield from <T extends { id: number }>:\n   * Bitfield.fromObjects(32, \"id\", [{ id: 0, ... }, ...]);\n   */\n  static fromObjects<T>(length: number, key: keyof T, objs: T[]): Bitfield {\n    return objs.reduce((bitfield, obj) => {\n      const id = obj[key] as number;\n      if (isNaN(id as number)) return bitfield;\n      const i = Bitfield.indexOf(id);\n      if (i > -1) bitfield[i] ^= 1 << (id  - i * 32);\n      return bitfield;\n    }, new Bitfield(length));\n  }\n\n  /** @returns the index of a bit in the bitfield */\n  static indexOf(bit: number): number {\n    if (isNaN(bit) || bit < 0) return -1;\n    return bit >>> 5;\n  }\n\n  /** @returns the intersection of two bits */\n  static intersectBits(a = 0, b = 0): number {\n    return a & b;\n  }\n\n  /**\n   * Creates a new Bitfield\n   * @param length the number of bits in the array\n   */\n  constructor(length: number) {\n    super(Math.ceil(length / 32));\n  }\n\n  /** @returns The amount of bits in the array */\n  get size(): number {\n    return this.length << 5;\n  }\n\n  /** @returns a new Bitfield with identical properties to this Bitfield */\n  clone(): Bitfield {\n    const result = new Bitfield(this.length);\n    result.set(this);\n    return result;\n  }\n\n  /** @returns a new Bitfield based on this one with toggled bits */\n  cloneWithToggle<T>(key: keyof T, sources: T[]): Bitfield {\n    const bitfield = this.clone();\n    sources.forEach((source) => bitfield.toggle(source[key] as number));\n    return bitfield;\n  }\n\n  /** @returns the index and position of a bit in the bitfield */\n  getPosition(bit: number): { index: number, position: number } {\n    const index = Bitfield.indexOf(bit);\n    return {\n      index,\n      position: bit - (index << 5),\n    }\n  }\n\n  /** @returns `true` if a given bit is 'on' (i.e., truthy) in the Bitfield */\n  isOn(bit: number): boolean {\n    const i = Bitfield.indexOf(bit);\n    if (i === -1 || this[i] === undefined) return false;\n    return Boolean(this[i]! & (1 << (bit - i * 32)));\n  }\n\n  /**\n   * Toggle a bit in the Bitfield\n   * @return the resulting state of the bit\n   * @throws if the bit is not found (i.e., indexOf(bit) === -1)\n   */\n  toggle(bit: number): boolean {\n    const i = Bitfield.indexOf(bit);\n    if (i === -1) throw new SyntaxError(`Bitfield.indexOf(${bit}) returned -1.`);\n    if (this[i] === undefined) this[i] = 0;\n    this[i] ^= 1 << (bit - i * 32);\n    return !!(this[i]! & (1 << (bit - i * 32)));\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\n\nexport class Archetype {\n  /** The Archetype's Component Bitfield */\n  readonly bitfield: Bitfield;\n  /** QueryInstances and their candidacy status*/\n  readonly candidateCache: Map<QueryInstance, boolean>;\n  /** The components associated with this archetype */\n  readonly components: ComponentInstance<any>[];\n  /** Entities which have entered this archetype since last refresh */\n  readonly entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  readonly entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  readonly exited: Set<Entity>;\n  /** `true` if the object is in a dirty state */\n  isDirty: boolean;\n\n  constructor(length: number, components: ComponentInstance<any>[], bitfield?: Bitfield) {\n    this.bitfield = bitfield ?? Bitfield.fromObjects(length, \"id\", components);\n    this.candidateCache = new Map();\n    this.components = components;\n    this.entered = new Set();\n    this.entities = new Set();\n    this.exited = new Set();\n    this.isDirty = true;\n  }\n\n  /** The Archetype's unique identifier */\n  get id(): string {\n    return this.bitfield.toString();\n  }\n\n  /** `true` if this Archetype has no entities associated with it */\n  get isEmpty(): boolean {\n    return this.entities.size === 0;\n  }\n\n  /** Add an Entity to the Archetype */\n  addEntity(entity: Entity): Archetype {\n    this.entities.add(entity);\n    this.entered.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Create a new Archetype from this Archetype */\n  clone(): Archetype {\n    return new Archetype(this.bitfield.length, this.components, this.bitfield.clone());\n  }\n\n  /**\n   * Test this Archetype matches a given QueryInstance\n   * @param query The QueryInstance to test\n   * @returns `true` if the QueryInstance is a match\n   */\n  isCandidate(query: QueryInstance): boolean {\n    const cached = this.candidateCache.get(query);\n    if (cached !== undefined) return cached;\n    const status = this.bitfield.every(query.checkCandidacy);\n    this.candidateCache.set(query, status);\n    return status;\n  }\n\n  /** Clear entered/exited entities and set `isDirty` to `false` */\n  refresh(): Archetype {\n    this.entered.clear();\n    this.exited.clear();\n    this.isDirty = false;\n    return this;\n  }\n\n  /** Remove an Entity from the Archetype */\n  removeEntity(entity: Entity): Archetype {\n    this.entities.delete(entity);\n    this.exited.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Serialize the Archetype to a string */\n  toString(): string {\n    return `\n{\n  bitfield: ${this.bitfield.toString()},\n  components: ${this.components.map((inst) => inst.id).join(\",\")},\n  entities: ${[...this.entities.values()].join(\",\")},\n},\n    `;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype.js\";\nimport type { Query } from \"../query/query.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Entity } from \"../world.js\";\n\nexport interface ArchetypeManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nexport class ArchetypeManager {\n  /** Map<Archetype.id, Archetype> */\n  archetypeMap: Map<string, Archetype> = new Map();\n  /** Archetype's indexed by Entity */\n  entityArchetypes: Archetype[];\n  /** The root/empty archetype */\n  rootArchetype: Archetype;\n\n  constructor(spec: ArchetypeManagerSpec) {\n    const { capacity, components } = spec;\n    this.rootArchetype = new Archetype(components.length, []);\n    this.archetypeMap = new Map();\n    this.archetypeMap.set(this.rootArchetype.id, this.rootArchetype);\n    this.entityArchetypes = new Array(capacity).map((_, i) => this.rootArchetype.addEntity(i as Entity));\n  }\n\n  /** @returns an entity's archetype or undefined if not found */\n  getArchetype(entity: Entity): Archetype | undefined {\n    return this.entityArchetypes[entity];\n  }\n\n  /** Returns an entity to the root archetype */\n  resetArchetype(entity: Entity): ArchetypeManager {\n    if (this.entityArchetypes[entity] === this.rootArchetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = this.rootArchetype.addEntity(entity);\n    return this;\n  }\n\n  /** Performs various archetype maintenance */\n  refreshArchetypes(queries: Map<Query, QueryInstance>): ArchetypeManager {\n    /** @todo double loop isn't ideal */\n    this.archetypeMap.forEach((archetype) => {\n      queries.forEach((query) => {\n        if (!query.archetypes.has(archetype) && archetype.isCandidate(query)) {\n          query.isDirty = true;\n          query.archetypes.add(archetype);\n        }\n      });\n      archetype.refresh();\n    });\n    return this;\n  }\n\n  /** Replace an entity's archetype */\n  setArchetype(entity: Entity, archetype: Archetype): ArchetypeManager {\n    if (!this.archetypeMap.has(archetype.id)) throw new Error(\"Invalid archetype.\");\n    if (this.entityArchetypes[entity] === archetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = archetype.addEntity(entity);\n    return this;\n  }\n\n  /**\n   * Update an Entity's archetype\n   * @param entity the entity to update\n   * @param components the components to toggle\n   * @returns The entity's resulting archetype\n   */\n  updateArchetype(entity: Entity, components: ComponentInstance<any>[]): Archetype {\n    /** @todo replace this with a graph */\n    const previousArchetype = this.entityArchetypes[entity];\n    previousArchetype?.removeEntity(entity);\n    const bitfield = previousArchetype\n      ? previousArchetype.bitfield.cloneWithToggle<ComponentInstance<any>>(\"id\", components)\n      : this.rootArchetype.bitfield.cloneWithToggle<ComponentInstance<any>>(\"id\", components);\n    const id = bitfield.toString();\n    let nextArchetype = this.archetypeMap.get(id)\n    if (!nextArchetype) {\n      nextArchetype = new Archetype(this.rootArchetype.bitfield.length, components, bitfield);\n      this.archetypeMap.set(id, nextArchetype);\n    }\n    this.entityArchetypes[entity] = nextArchetype.addEntity(entity);\n    return nextArchetype;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Entity } from \"../world.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\n/**\n * A storage proxy is a convenience method\n * for setting entity's component properties\n * in a way which is type safe and\n * flips the `changed` property on the entity\n * at the expense of performance.\n * */\nexport type StorageProxy<T extends Schema<T>> = Record<keyof T, number> & { getEntity(): Entity, setEntity(entity: Entity): Entity };\n\nexport function storageProxy<T extends Schema<T>>(storage: SchemaStorage<T>, changed: Set<Entity>): StorageProxy<T> {\n  if (!storage) throw new SyntaxError(\"Proxy can only be used on components, not tags.\");\n\n  /** The currently selected entity */\n  let entityId: Entity = 0 as Entity;\n\n  return Object.freeze(\n    Object.keys(storage).reduce(\n      (res, key) => {\n        Object.defineProperty(res, key, {\n          get() {\n            return storage[key as keyof T][entityId];\n          },\n          set(value: number) {\n            if (storage[key as keyof T][entityId] !== value) {\n              changed.add(entityId);\n              storage[key as keyof T][entityId] = value;\n            }\n          },\n        });\n        return res;\n      },\n      {\n        getEntity(): Entity {\n          return entityId;\n        },\n        setEntity(entity: Entity): Entity {\n          if (entity == undefined) return entityId;\n          entityId = entity;\n          return entityId;\n        },\n      } as StorageProxy<T>,\n    ),\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_CHANGED, $_OWNERS } from \"../constants.js\";\nimport { isObject, isPositiveInt, isUint32 } from \"../utils/utils.js\";\nimport { storageProxy } from \"./proxy.js\";\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport type { TypedArray } from \"../utils/utils.js\";\nimport type { StorageProxy } from \"./proxy.js\";\nimport type { Entity } from \"../world.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\ninterface ComponentInstanceSpec<T extends Schema<T>> {\n  /** The world's entity capacity */\n  capacity: number;\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport type ComponentInstance<T extends Schema<T>> = Component<T> &\n  Record<keyof T, TypedArray> & {\n    /** @internal */\n    [$_CHANGED]: Set<Entity>;\n    /** @internal */\n    [$_OWNERS]: Bitfield;\n    /** Entities who's properties have been changed via this.proxy since last refresh */\n    changed: IterableIterator<Entity>;\n    /** The number of entities which have this component instance */\n    count: number;\n    /** The instance's identifier */\n    id: number;\n    /** */\n    proxy: StorageProxy<T>;\n  };\n\nexport function refreshComponentInstance<T extends Schema<T>>(instance: ComponentInstance<T>): ComponentInstance<T> {\n  instance[$_CHANGED].clear();\n  return instance;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T extends Schema<T>>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T>> {\n  const { capacity, component, id, storage } = spec;\n  if (!isPositiveInt(capacity)) throw new SyntaxError(\"Capacity must be integer > 0.\");\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n\n  const changed: Set<Entity> = new Set();\n  const owners: Bitfield = new Bitfield(capacity);\n\n  const instance = Object.create(component, {\n    [$_CHANGED]: {\n      value: changed,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    [$_OWNERS]: {\n      value: owners,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    changed: {\n      get() {\n        return changed.values();\n      },\n    },\n    count: {\n      get() {\n        return Bitfield.getSetBitCountInBitfield(owners);\n      },\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n\n  if (storage) {\n    // create instance.proxy\n    Object.defineProperty(instance, \"proxy\", {\n      value: storageProxy(storage, changed),\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    });\n    // assign raw storage\n    Object.assign(instance, storage);\n  }\n\n  return Object.freeze(instance);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"./bitfield.js\";\n\nexport class BitPool extends Bitfield {\n  private nextAvailable = 0;\n\n  constructor(size: number) {\n    super(size);\n    this.fill(4294967295);\n  }\n\n  get residents() {\n    return Bitfield.getSetBitCountInBitfield(this);\n  }\n\n  get vacancies() {\n    return this.size - this.nextAvailable;\n  }\n\n  acquire() {\n    const { nextAvailable } = this;\n    if (nextAvailable <= -1) return -1;\n    const index = this[nextAvailable] as number;\n    const position = Bitfield.getLsbIndex(index);\n    this[nextAvailable] &= ~(1 << position);\n    if (this[nextAvailable] === 0) {\n      this.nextAvailable = -1;\n      for (let i = 0; i < this.length; i++) {\n        if (this[i] !== 0) {\n          this.nextAvailable = i;\n          break;\n        }\n      }\n    }\n    return (nextAvailable << 5) + position;\n  }\n\n  release(idx: number): BitPool {\n    const { index, position } = this.getPosition(idx);\n    if (index === -1) return this;\n    this[index] |= 1 << position;\n    this.nextAvailable = index;\n    return this;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { BitPool } from \"./bitpool.js\";\nimport type { TypedArray } from \"./utils.js\";\nimport type { Entity } from \"../world.js\";\n\n/**\n * @param dense the typed array to apply the facade to\n * @returns A proxy to the dense array\n */\nexport function sparseFacade<T extends TypedArray>(dense: T): T {\n  /** Map<Entity, Dense Array Index> */\n  const sparse: Map<Entity, number> = new Map();\n\n  /** Array of available indexes in dense */\n  const available = new BitPool(dense.length);\n\n  /** @returns the entity's value from the dense array or undefined if non-existant */\n  const _get = (entity: Entity) => dense[sparse.get(entity) ?? -1];\n\n  /** @returns `false` if dense array is full, `true` if value set successfully */\n  const _set = (entity: Entity, value: T[0]): boolean => {\n    const idx = sparse.get(entity) ?? available.acquire();\n    if (idx === undefined) return false;\n    dense[idx] = value;\n    sparse.set(entity, idx);\n    return true;\n  };\n\n  /** @returns `false` if the entity isn't already stored, `true` if deleted successfully */\n  const _deleteProperty = (entity: Entity): boolean => {\n    const idx = sparse.get(entity);\n    if (idx === undefined) return false;\n    dense[idx] = 0;\n    sparse.delete(entity);\n    available.release(idx);\n    return true;\n  };\n\n  return new Proxy(dense, {\n    get: (_target: T, key: string | symbol) => _get(key as unknown as Entity),\n    set: (_target: T, key: string | symbol, value: T[0]) => _set(key as unknown as Entity, value),\n    deleteProperty: (_target: T, key: string | symbol) => _deleteProperty(key as unknown as Entity),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { sparseFacade } from \"../utils/sparse-facade.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\nimport type { TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\ninterface ComponentBufferSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nexport class ComponentBuffer extends ArrayBuffer {\n  /**\n   * @private\n   * Calculate the total required storage space for all component schemas\n   */\n  private static calculateSize(capacity: number, components: Component<any>[]): number {\n    return components.reduce((total: number, component: Component<any>): number => {\n      const { size } = component;\n      if (!size || size < 0) return total;\n      return total + (size * capacity);\n    }, 0);\n  }\n\n  /**\n   * @private\n   * Partitions the ComponentBuffer into individual TypedArrays for each Component\n   */\n  private static partition(buffer: ComponentBuffer, capacity: number, components: Component<any>[]) {\n    let offset = 0;\n    components.forEach(<T extends Schema<T>>(component: Component<T>) => {\n      const { maxEntities, schema } = component;\n      if (!schema) return;\n      const storage = {} as Record<keyof T, TypedArray>;\n      const requiredSize = maxEntities ?? capacity;\n      Object.entries(schema).forEach(([key, value]) => {\n        let typedArrayConstructor = value as TypedArrayConstructor;\n        let initialValue = 0;\n        if (Array.isArray(value)) [typedArrayConstructor, initialValue] = value;\n        const dense = new typedArrayConstructor(buffer, offset, requiredSize);\n        storage[key as keyof T] = maxEntities === null ? dense : sparseFacade(dense);\n        storage[key as keyof T].fill(initialValue as never);\n        offset += (typedArrayConstructor.BYTES_PER_ELEMENT * requiredSize);\n      })\n      buffer.map.set(component, storage);\n    });\n    return buffer;\n  }\n\n  /** Maximum number of in the world */\n  readonly capacity: number;\n\n  /** Components and their respective TypedArray storage */\n  readonly map: Map<Component<any>, SchemaStorage<any>> = new Map();\n\n  /**\n   * Create a properly sized ArrayBuffer to hold all a world's component's data.\n   * @param spec The component buffer's specification object\n   * @param spec.capacity The world's entity capacity\n   * @param spec.components The components which the buffer will contain\n   */\n  constructor(spec: ComponentBufferSpec) {\n    const { capacity, components } = spec;\n    super(ComponentBuffer.calculateSize(capacity, components));\n    ComponentBuffer.partition(this, capacity, components);\n    this.capacity = capacity;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_OWNERS } from \"../constants.js\";\nimport { createComponentInstance, refreshComponentInstance } from \"./instance.js\";\nimport { ComponentBuffer } from \"./buffer.js\";\nimport type { Entity } from \"../world.js\";\nimport type { TypedArrayConstructor } from \"../utils/utils.js\";\nimport type { Component } from \"./component.js\";\nimport type { ComponentInstance } from \"./instance.js\";\nimport type { Schema, SchemaProps } from \"./schema.js\";\n\n/** [component name]: component instance */\nexport type ComponentRecord = Record<string, ComponentInstance<any>>;\n\nexport type ComponentMap = Map<Component<any>, ComponentInstance<any>>;\n\nexport interface ComponentManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nfunction instantiate(buffer: ComponentBuffer, capacity: number, components: Component<any>[]) {\n  return components.reduce(\n    <T extends Schema<T>>(res: ComponentMap, component: Component<T>, id: number) => {\n      const instance = createComponentInstance({ capacity, component, id, storage: buffer.map.get(component) });\n      res.set(component, instance);\n      return res;\n    },\n    new Map() as ComponentMap,\n  );\n}\n\n/** @todo better async? */\nfunction add<T extends Schema<T>>(instance: ComponentInstance<T>, entity: number, properties?: Record<string, SchemaProps<unknown>>) {\n  const { maxEntities, name, schema } = instance;\n  if (maxEntities && instance.count >= maxEntities) {\n    throw new Error(`Component \"${name}\".maxEntities reached.`);\n  }\n  if (instance[$_OWNERS].isOn(entity)) return null;\n  instance[$_OWNERS].toggle(entity);\n  // set properties\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, value]) => {\n      instance[key as keyof T][entity] = properties ? (properties[name] as SchemaProps<T>)[key as keyof T] ?? (value as [TypedArrayConstructor, number])[1] ?? 0 : (value as [TypedArrayConstructor, number])[1] ?? 0;\n    });\n  }\n  return instance;\n};\n\n/** @todo better async? */\nfunction remove(instance: ComponentInstance<any>, entity: Entity) {\n  const { maxEntities, schema } = instance;\n  if (!instance[$_OWNERS].isOn(entity)) return null;\n  instance[$_OWNERS].toggle(entity);\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, prop]) => {\n      const storage = instance[key];\n      if (storage) {\n        if (maxEntities) {\n          delete storage[entity];\n        } else {\n          storage[entity] = Array.isArray(prop) ? prop[1] : 0;\n        }\n      }\n    });\n  }\n  return instance;\n};\n\nexport class ComponentManager {\n  readonly buffer: ComponentBuffer;\n  readonly componentMap: Map<Component<any>, ComponentInstance<any>>;\n\n  constructor(spec: ComponentManagerSpec) {\n    const { capacity, components } = spec;\n    this.buffer = new ComponentBuffer({ capacity, components });\n    this.componentMap = instantiate(this.buffer, capacity, components);\n  }\n\n  addComponentsToEntity(components: Component<any>[]): (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => ComponentInstance<any>[] {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => {\n      return instances.map((instance) => add(instance, entity, properties)).filter(Boolean) as ComponentInstance<any>[];\n    }\n  }\n\n  removeComponentsFromEntity(components: Component<any>[]) {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity) => {\n      return instances.map((instance) => remove(instance, entity)).filter(Boolean) as ComponentInstance<any>[];\n    }\n  }\n\n  getBuffer(): ArrayBuffer {\n    return this.buffer.slice(0);\n  }\n\n  getInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentMap.get(component);\n  }\n\n  getInstances(components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    return components.map(this.getInstance, this);\n  }\n\n  setBuffer(source: ArrayBuffer): ComponentManager {\n    if (source.byteLength !== this.buffer.byteLength) {\n      throw new Error(\"setBuffer: byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(this.buffer);\n    target.set(view);\n    return this;\n  }\n\n  refreshComponents(): ComponentManager {\n    this.componentMap.forEach(refreshComponentInstance);\n    return this;\n  }\n\n  export() {\n    return {\n      buffer: this.buffer.slice(0),\n      componentMap: [...this.componentMap.entries()],\n    };\n  }\n}\n","import { createQueryInstance } from \"./instance.js\";\nimport { Query } from \"./query.js\";\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { ComponentManager, ComponentRecord } from \"../component/manager.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"./instance.js\";\n\n/** @todo find a nicer way of doing this */\n// NOTE: The following functions are used to avoid flatmap which incurs a GC penalty\n\nfunction _flattenEntered(this: Set<Entity>, { entered }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entered.forEach(this.add, this);\n}\n\nfunction _flattenEntities(this: Set<Entity>, { entities }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entities.forEach(this.add, this);\n}\n\nfunction _flattenExited(this: Set<Entity>, { exited }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  exited.forEach(this.add, this);\n}\n\nfunction refreshQuery(query: QueryInstance) {\n  query.isDirty = false;\n}\n\nexport interface QueryManagerSpec {\n  componentManager: ComponentManager;\n}\n\nexport class QueryManager {\n  /** The components, and their instances, of a given world */\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  /** Cache for Entities which match each QueryInstance */\n  entityCache: Map<QueryInstance, Set<Entity>>;\n  /** Map of registered Queries and their instances */\n  queryMap: Map<Query, QueryInstance>;\n\n  /**\n   * Creates a new QueryManager\n   *\n   * QueryManagers are responsible for:\n   *  - registering and instantiating queries\n   *  - getting components and entities from query instances\n   *\n   * @param spec the manager's specification object\n   */\n  constructor(spec: QueryManagerSpec) {\n    const { componentManager } = spec;\n    this.componentMap = componentManager.componentMap;\n    this.entityCache = new Map();\n    this.queryMap = new Map();\n  }\n\n  /** @returns the components associated with a query */\n  getComponentsFromQuery(query: Query): ComponentRecord {\n    return this.getQueryInstance(query).components;\n  }\n\n  /** @returns an array of Entities which have entered this query since last refresh */\n  getEnteredFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n    const res: Set<Entity> = new Set(); /** @todo avoid creating new set */\n    this.getQueryInstance(query)?.archetypes.forEach(_flattenEntered, res);\n    arr.push(...res)\n    return arr;\n  }\n\n  /** @returns an array of Entities which match the query */\n  getEntitiesFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n\n    const instance = this.getQueryInstance(query);\n\n    const { archetypes, isDirty } = instance;\n\n    const cached = this.entityCache.get(instance) as Set<Entity>;\n\n    // if new query, do full sweep and create cache set\n    if (!cached) {\n      const res: Set<Entity> = new Set();\n      archetypes.forEach(_flattenEntities, res);\n      this.entityCache.set(instance, res);\n      arr.push(...res)\n      return arr;\n    }\n\n    // if query has new Archetypes, clear cache and do full sweep\n    if (isDirty === true) {\n      cached.clear();\n      archetypes.forEach(_flattenEntities, cached);\n      arr.push(...cached)\n      return arr;\n    }\n\n    // else just update the dirty archetypes\n    archetypes.forEach((archetype) => {\n      if (archetype.isDirty === true) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        archetype.entered.forEach(cached.add, cached);\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        archetype.exited.forEach(cached.delete, cached);\n      }\n    });\n\n    arr.push(...cached)\n    return arr;\n  }\n\n  /** @returns an array of Entities which have been removed from this query since last refresh */\n  getExitedFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n    const res: Set<Entity> = new Set(); /** @todo avoid creating new set */\n    this.getQueryInstance(query)?.archetypes.forEach(_flattenExited, res);\n    arr.push(...res)\n    return arr;\n  }\n\n  /** @returns an instantiated Query */\n  getQueryInstance(query: Query): QueryInstance {\n    return this.registerQuery(query);\n  }\n\n  /** Register a Query in the world, producing a QueryInstance */\n  registerQuery(query: Query): QueryInstance {\n    if (!(query instanceof Query)) throw new Error(\"Object is not a valid query.\");\n    const cached = this.queryMap.get(query);\n    if (cached) return cached;\n    const instance = createQueryInstance({ componentMap: this.componentMap, query });\n    this.queryMap.set(query, instance);\n    return instance;\n  }\n\n  /** Perform routine maintenance on each registered query */\n  refreshQueries(): QueryManager {\n    this.queryMap.forEach(refreshQuery);\n    return this;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Query } from \"./query.js\";\nimport type { Schema } from \"../component/schema.js\";\n\ninterface QueryInstanceSpec {\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield>;\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  checkCandidacy: (target: number, idx: number) => boolean;\n  /** */\n  components: Record<string, ComponentInstance<any>>;\n  /**\n   * `true` if the object is in a dirty state\n   *\n   * A query becomes dirty when an archetype is added or removed\n   */\n  isDirty: boolean;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield>;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): QueryInstance {\n  const { componentMap, query } = spec;\n  const { all, any, none } = query;\n\n  const getComponentInstances = <T extends Schema<T>>(\n    arr: ComponentInstance<any>[],\n    component: Component<T>,\n    idx: number,\n  ) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr[idx] = inst as ComponentInstance<T>;\n    return arr;\n  };\n\n  const length = componentMap.size;\n\n  const _allInstances = all.reduce(getComponentInstances, new Array(all.length) as ComponentInstance<any>[]);\n  const and = Bitfield.fromObjects(length, \"id\", _allInstances);\n\n  const _anyInstances = any.reduce(getComponentInstances, new Array(any.length) as ComponentInstance<any>[]);\n  const or = Bitfield.fromObjects(length, \"id\", _anyInstances);\n\n  const _noneInstances = none.reduce(getComponentInstances, new Array(none.length) as ComponentInstance<any>[]);\n  const not = Bitfield.fromObjects(length, \"id\", _noneInstances);\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<any>> = [..._allInstances, ..._anyInstances].reduce(\n    (res, component) => {\n      res[component.name] = component;\n      return res;\n    },\n    {} as Record<string, ComponentInstance<any>>,\n  );\n  Object.freeze(components);\n\n  const archetypes: Set<Archetype> = new Set();\n\n  const checkCandidacy = (target: number, idx: number): boolean => {\n    const OR = or[idx] === 0 || Bitfield.intersectBits(target, or[idx]) > 0;\n    if (!OR) return false;\n    const AND = Bitfield.intersectBits(target, and[idx]) === and[idx];\n    if (!AND) return false;\n    return Bitfield.intersectBits(target, not[idx]) === 0;\n  };\n\n  return Object.assign(Object.create(query), {\n    isDirty: true,\n    archetypes,\n    and,\n    checkCandidacy,\n    components,\n    not,\n    or,\n  }) as QueryInstance;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ArchetypeManager } from \"./archetype/manager.js\";\nimport { ComponentManager } from \"./component/manager.js\";\nimport { $_OWNERS, VERSION } from \"./constants.js\";\nimport { QueryManager } from \"./query/manager.js\";\nimport { Query } from \"./query/query.js\";\nimport { BitPool } from \"./utils/bitpool.js\";\nimport { isObject, isPositiveInt, isUint32, Opaque } from \"./utils/utils.js\";\nimport type { Component } from \"./component/component.js\";\nimport type { ComponentInstance } from \"./component/instance.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { Schema, SchemaProps } from \"./component/schema.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\nexport interface WorldData {\n  buffer: ArrayBuffer;\n  capacity: number;\n  version: string;\n}\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world */\n  components: Component<any>[];\n}\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec || !isObject(spec)) {\n    throw new SyntaxError(\"World creation requires a specification object.\");\n  }\n  const { capacity, components } = spec;\n  if (!isPositiveInt(capacity)) {\n    throw new SyntaxError(\"World: spec.capacity invalid.\");\n  }\n  if (\n    !Array.isArray(components) ||\n    !components.every((c) => Object.prototype.hasOwnProperty.call(c, \"name\"))\n  ) {\n    throw new TypeError(\"World: spec.components invalid.\");\n  }\n  return { ...spec, components: [...new Set(components)] };\n}\n\nexport class World {\n  private readonly archetypeManager: ArchetypeManager;\n  private readonly componentManager: ComponentManager;\n  private readonly queryManager: QueryManager;\n\n  /** Pool of Entity states */\n  private readonly entities: BitPool;\n\n  readonly version = VERSION;\n\n  /**\n   * Create a new World object\n   * @param spec An WorldSpec object\n   * @param spec.capacity The maximum number of entities allowed in the world\n   * @param spec.components An array of components to instantiate in the world\n   */\n  constructor(spec: WorldSpec) {\n    const { capacity, components } = validateWorldSpec(spec);\n    this.entities = new BitPool(capacity);\n    this.archetypeManager = new ArchetypeManager({ capacity, components });\n    this.componentManager = new ComponentManager({ capacity, components });\n    this.queryManager = new QueryManager({ componentManager: this.componentManager });\n    this.refresh(); /** @todo is this necessary? */\n    Object.freeze(this);\n  }\n\n  /** @returns the maximum number of entities the world can hold */\n  get capacity(): number {\n    return this.entities.size;\n  }\n\n  /** @returns the number of active entities */\n  get residents(): number {\n    return this.entities.residents;\n  }\n\n  /** @returns the number of available entities */\n  get vacancies(): number {\n    return this.entities.vacancies;\n  }\n\n  addComponentsToEntity(...components: Component<any>[]) {\n    const adder = this.componentManager.addComponentsToEntity(components);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>): World => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, adder(entity, properties));\n      return self;\n    };\n  }\n\n  /** @returns the next available Entity or `undefined` if no Entity is available */\n  createEntity(): Entity | undefined {\n    const entity = this.entities.acquire() as Entity;\n    if (entity < 0) return;\n    this.archetypeManager.setArchetype(entity, this.archetypeManager.rootArchetype);\n    return entity;\n  }\n\n  /** Remove and recycle an Entity */\n  destroyEntity(entity: Entity): World {\n    if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n    this.archetypeManager.resetArchetype(entity);\n    this.entities.release(entity);\n    return this;\n  }\n\n  getChangedFromComponents(...components: Component<any>[]): Entity[] {\n    const instances = this.componentManager.getInstances(components).filter((x) => x);\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    return [...new Set(instances.reduce((res, inst) => {\n      res.push(...inst!.changed)\n      return res;\n    }, [] as Entity[]))];\n  }\n\n  getChangedFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    const instance = this.queryManager.getQueryInstance(query);\n    arr.length = 0;\n    Object.values(instance.components).forEach((inst) => arr.push(...inst.changed));\n    return [...new Set(arr)];\n  }\n\n  getComponentInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentManager.componentMap.get(component);\n  }\n\n  getComponentInstances(...components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    return this.componentManager.getInstances(components);\n  }\n\n  getEntityProperties(entity: Entity): Record<string, SchemaProps<unknown>> {\n    const archetype = this.archetypeManager.getArchetype(entity);\n    if (!archetype) return {};\n    return archetype.components.reduce(\n      <T extends Schema<T>>(res: Record<keyof T, SchemaProps<unknown>>, component: ComponentInstance<T>) => {\n        const { name, schema } = component;\n        res[name as keyof T] = {};\n        if (schema === null) {\n          res[name as keyof T] = true;\n        } else {\n          res[name as keyof T] = Object.keys(schema).reduce((prev, key) => {\n            prev[key as keyof T] = component[key as keyof T][entity];\n            return prev;\n          }, {} as SchemaProps<T>);\n        }\n        return res;\n      },\n      {},\n    );\n  }\n\n  getQueryComponents(query: Query): ComponentRecord {\n    return this.queryManager.getComponentsFromQuery(query);\n  }\n\n  getQueryEntered(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getEnteredFromQuery(query, arr);\n  }\n\n  getQueryEntities(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getEntitiesFromQuery(query, arr);\n  }\n\n  getQueryExited(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getExitedFromQuery(query, arr);\n  }\n\n  hasComponent<T extends Schema<T>>(component: Component<T>): (entity: Entity) => boolean {\n    const instance = this.componentManager.getInstance(component);\n    if (!instance) throw new Error(\"Component is not registered.\");\n    return (entity: Entity) => instance[$_OWNERS].isOn(entity);\n  }\n\n  hasComponents(...components: Component<any>[]): (entity: Entity) => boolean[] {\n    const instances = this.componentManager.getInstances(components).filter((x) => x) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    return (entity: Entity): boolean[] => {\n      return instances.map((component) => component[$_OWNERS].isOn(entity));\n    };\n  }\n\n  /**\n   * @return `true` if the Entity is valid and exists in the world\n   * @throws if the entity is invalid\n   */\n  isEntityActive(entity: Entity): boolean {\n    if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n    return this.entities.isOn(entity);\n  }\n\n  /** @return `true` if the given entity is valid for the given capacity */\n  isValidEntity(entity: Entity): entity is Entity {\n    return isUint32(entity) && entity < this.entities.size;\n  }\n\n  /** Swap the ComponentBuffer of one world with this world */\n  load(data: WorldData): World {\n    const { buffer, capacity, version } = data;\n    if (version !== this.version) {\n      throw new Error(`Version mismatch. Trying to load ${version} data into ${this.version} world.`);\n    }\n    if (capacity !== this.capacity) {\n      throw new Error(`Capacity mismatch. Data requires a world with a capacity of ${capacity}.`);\n    }\n    this.componentManager.setBuffer(buffer);\n    this.refresh();\n    return this;\n  }\n\n  /** Runs various world maintenance functions */\n  refresh(): World {\n    this.queryManager.refreshQueries();\n    this.archetypeManager.refreshArchetypes(this.queryManager.queryMap);\n    this.componentManager.refreshComponents();\n    return this;\n  }\n\n  removeComponentsFromEntity(...components: Component<any>[]): (entity: Entity) => World {\n    const remover = this.componentManager.removeComponentsFromEntity(components);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return (entity: Entity) => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, remover(entity)); /** @todo probably don't want to do this each loop */\n      return self;\n    };\n  }\n\n  /** Export various bits of data about the world */\n  save(): WorldData {\n    return Object.freeze({\n      buffer: this.componentManager.getBuffer(),\n      capacity: this.capacity,\n      version: this.version,\n    });\n  }\n}\n"],"names":["FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","$_CHANGED","Symbol","$_OWNERS","LOG_2","isUint32","n","isNaN","isPositiveInt","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","includes","test","isObject","Array","isArray","_validateSchemaEntry","name","value","TAC","_validateProps","isValidSchema","schema","undefined","entries","every","_","byteSum","total","BYTES_PER_ELEMENT","Component","isTag","maxEntities","size","constructor","spec","SyntaxError","this","values","reduce","Number","NaN","calculateSchemaSize","_validateQueryArrays","component","Query","all","any","none","Set","System","system","query","init","world","components","getQueryComponents","entities","args","getQueryEntities","Bitfield","Uint32Array","species","static","a","b","bitfield","res","val","getSetBitCount","key","objs","obj","id","i","indexOf","bit","super","Math","ceil","clone","result","set","cloneWithToggle","sources","forEach","source","toggle","getPosition","index","position","isOn","Archetype","candidateCache","entered","exited","isDirty","fromObjects","Map","toString","isEmpty","addEntity","entity","add","isCandidate","cached","get","status","checkCandidacy","refresh","clear","removeEntity","delete","map","inst","join","ArchetypeManager","archetypeMap","entityArchetypes","rootArchetype","capacity","getArchetype","resetArchetype","refreshArchetypes","queries","archetype","archetypes","has","setArchetype","Error","updateArchetype","previousArchetype","nextArchetype","storageProxy","storage","changed","entityId","keys","defineProperty","getEntity","setEntity","refreshComponentInstance","instance","BitPool","nextAvailable","fill","residents","getSetBitCountInBitfield","vacancies","acquire","getLsbIndex","release","idx","sparseFacade","dense","sparse","available","Proxy","_target","_get","_set","deleteProperty","_deleteProperty","ComponentBuffer","ArrayBuffer","buffer","offset","requiredSize","typedArrayConstructor","initialValue","calculateSize","partition","instantiate","TypeError","owners","create","configurable","enumerable","writable","count","assign","createComponentInstance","ComponentManager","componentMap","addComponentsToEntity","instances","getInstances","filter","properties","removeComponentsFromEntity","prop","remove","getBuffer","slice","getInstance","setBuffer","byteLength","view","Uint8Array","refreshComponents","export","_flattenEntered","_flattenEntities","_flattenExited","refreshQuery","QueryManager","entityCache","queryMap","componentManager","getComponentsFromQuery","getQueryInstance","getEnteredFromQuery","arr","push","getEntitiesFromQuery","getExitedFromQuery","registerQuery","getComponentInstances","_allInstances","and","_anyInstances","or","_noneInstances","not","target","intersectBits","createQueryInstance","refreshQueries","World","archetypeManager","queryManager","version","c","validateWorldSpec","adder","self","isValidEntity","createEntity","destroyEntity","getChangedFromComponents","x","getChangedFromQuery","getComponentInstance","getEntityProperties","prev","getQueryEntered","getQueryExited","hasComponent","hasComponents","isEntityActive","load","data","remover","save"],"mappings":"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"}