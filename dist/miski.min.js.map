{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/query/instance.ts","../src/archetype/archetype.ts","../src/component/manager.ts","../src/component/instance.ts","../src/component/buffer.ts","../src/entity.ts","../src/bitfield.ts","../src/world.ts","../src/archetype/manager.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport * as pkg from \"../package.json\";\n\n/** Miski version */\nexport const VERSION: string = pkg.version;\n\n/** Default maximum entities value */\nexport const DEFAULT_MAX_ENTITIES = 1_000_000;\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties\n  \"component\",\n  \"id\",\n  \"isTag\",\n  \"name\",\n  \"schema\",\n  \"size\",\n  // object properties\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** The number 8 - to avoid magic numbers */\nexport const ONE_BYTE = 8;\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"./constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArrayConstructor {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    (typeof str === \"string\" && str.length > 0 && VALID_NAME_PATTERN.test(str) === true) ||\n      !FORBIDDEN_NAMES.includes(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/** An empty function for use in Systems */\nexport function noop(): void {\n  return void 0;\n}\n\n/** */\nexport const pipe =\n  <T, U>(...fns: ((arg: T) => T)[]) =>\n  (value: T) =>\n    fns.reduce((acc, fn) => fn(acc), value) as unknown as U;\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isValidName, TypedArray, TypedArrayConstructor } from \"../utils.js\";\n\n/** The interface available to end users */\nexport type SchemaProps<T> = Record<keyof T, number>;\n\n/** Component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/** Schemas are component storage definitions: e.g., { property: Int8Array } */\nexport type Schema<T> = Record<keyof T, TypedArrayConstructor>;\n\n/** Schema type guard */\nexport function isValidSchema<T>(schema: unknown): schema is Schema<T> {\n  return isObject(schema) && Object.keys(schema).every((name) => isValidName(name));\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  return (total as number) + (value as TypedArray).BYTES_PER_ELEMENT;\n}\n\n/** @returns the size in bytes that a component's storage requires for one entity */\nexport function calculateSchemaSize<T>(schema: Schema<T>): number {\n  return Object.values(schema).reduce(byteSum, 0) as number;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isValidName } from \"../utils.js\";\nimport { World } from \"../world.js\";\nimport { ComponentInstance } from \"./instance.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\n/** { [component name]: component instance } */\nexport type ComponentRecord = Record<string, ComponentInstance<unknown>>;\n\nexport interface ComponentSpec<T> {\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport interface Component<T> {\n  instance: (world: World) => ComponentInstance<T> | undefined;\n  /** `true` if the component has no schema */\n  isTag: boolean;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  size: number;\n}\n\nfunction getInstancer<T>(state: Component<T>) {\n  return function (world: World) {\n    return world.components.get(state) as ComponentInstance<T> | undefined;\n  };\n}\n\n/**\n * Define a new component.\n * @param spec the component's specification.\n * @param spec.name the component's string identifier.\n * @param spec.schema the component's optional schema object.\n * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n */\nexport function createComponent<T>(spec: ComponentSpec<T>): Component<T> {\n  if (!spec) throw new SyntaxError(\"Component creation requires a specification object.\");\n  const { name, schema } = spec;\n  if (!isValidName(name)) throw new SyntaxError(\"Component name is invalid.\");\n  if (schema && !isValidSchema(schema)) throw new SyntaxError(\"Component schema is invalid.\");\n  const component = {\n    isTag: schema ? false : true,\n    name,\n    schema: schema ? Object.freeze({ ...schema }) : null,\n    size: schema ? calculateSchemaSize(schema) : 0,\n  } as Component<T>;\n  component.instance = getInstancer(component);\n  return Object.freeze(component);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { Entity } from \"../entity.js\";\nimport { World } from \"../world.js\";\nimport { createQueryInstance } from \"./instance.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Readonly<Component<unknown>[]>;\n}\n\n/** Queries are groupings of archetypes */\nexport interface Query {\n  /** AND - Gather entities as long as they have all these components */\n  all: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any: Readonly<Component<unknown>[]>;\n  /**\n   * Get the result of the query for a given world\n   * @returns a tuple of Entities and Components which match the Query criteria\n   */\n  getResult: (world: World) => [Entity[], ComponentRecord];\n  /** NOT - Gather entities as long as they don't have these components */\n  none: Readonly<Component<unknown>[]>;\n}\n\n/**\n * Create a new Query\n * @param spec The Query's specification object\n * @param spec.all\n * @param spec.any\n * @param spec.none\n */\nexport function createQuery(spec: QuerySpec): Readonly<Query> {\n  if (!spec) throw new SyntaxError(\"createQuery: specification object is required.\");\n  const { all = [], any = [], none = [] } = spec;\n  if (![...all, ...any, ...none].every((component) => Object.prototype.hasOwnProperty.call(component, \"name\"))) {\n    throw new SyntaxError(\"Query specification object is invalid.\");\n  }\n  const query = {\n    all: Object.freeze([...all]),\n    any: Object.freeze([...any]),\n    none: Object.freeze([...none]),\n  } as Query;\n  query.getResult = function (world: World): [Entity[], ComponentRecord] {\n    const { components, bitfieldFactory, queries } = world;\n    let instance = queries.get(query);\n    if (!instance) {\n      instance = createQueryInstance({ components, bitfieldFactory, query });\n      queries.set(query, instance);\n    }\n    return [instance.getEntities(), instance.getComponents()];\n  };\n  return Object.freeze(query);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Query } from \"./query.js\";\n\nexport interface QueryInstanceSpec {\n  components: Map<Component<unknown>, ComponentInstance<unknown>>;\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Readonly<Bitfield>;\n  query: Query;\n}\n\nexport interface QueryInstance {\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  archetypeCache: Map<Archetype, boolean>;\n  /** The components matched by the and/or bitfields */\n  components: Readonly<ComponentRecord>;\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield> | undefined;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield> | undefined;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield> | undefined;\n  getComponents: () => ComponentRecord;\n  getEntities: () => Entity[];\n  refresh: (archetypes: Archetype[]) => void;\n}\n\nexport interface QueryInstanceConstructorSpec {\n  /** The components matched by the and/or bitfields */\n  components: Readonly<ComponentRecord>;\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield> | undefined;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield> | undefined;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield> | undefined;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): Readonly<QueryInstance> {\n  const { components, bitfieldFactory, query } = spec;\n\n  /** */\n  const all: ComponentRecord = {};\n  /** */\n  const any: ComponentRecord = {};\n  /** */\n  const none: ComponentRecord = {};\n\n  /** A bitfield for the AND match criteria */\n  let and: Readonly<Bitfield> | undefined;\n  /** A bitfield for the OR match criteria */\n  let or: Readonly<Bitfield> | undefined;\n  /** A bitfield for the NOT match criteria */\n  let not: Readonly<Bitfield> | undefined;\n\n  if (query.all.length) {\n    const instances = query.all.reduce((arr, component) => {\n      const inst = components.get(component);\n      if (!inst) throw new Error(`Component ${component.name} not found.`);\n      all[component.name] = inst;\n      arr.push(inst);\n      return arr;\n    }, [] as ComponentInstance<unknown>[]);\n    and = bitfieldFactory(instances);\n  }\n\n  if (query.any.length) {\n    const instances = query.any.reduce((arr, component) => {\n      const inst = components.get(component);\n      if (!inst) throw new Error(`Component ${component.name} not found.`);\n      any[component.name] = inst;\n      arr.push(inst);\n      return arr;\n    }, [] as ComponentInstance<unknown>[]);\n    or = bitfieldFactory(instances);\n  }\n\n  if (query.none.length) {\n    const instances = query.none.reduce((arr, component) => {\n      const inst = components.get(component);\n      if (!inst) throw new Error(`Component ${component.name} not found.`);\n      none[component.name] = inst;\n      arr.push(inst);\n      return arr;\n    }, [] as ComponentInstance<unknown>[]);\n    not = bitfieldFactory(instances);\n  }\n\n  /** The components matched by the and/or bitfields */\n  const _components = Object.freeze({ ...any, ...all });\n\n  const instance = {\n    and,\n    archetypeCache: new Map(),\n    archetypes: new Set(),\n    components: _components,\n    not,\n    or,\n  } as QueryInstance;\n\n  const getComponents = (): ComponentRecord => _components;\n\n  /** @todo cache entities per archetype and add a dirty flag to archetypes - only update entities from dirty archetypes */\n  const getEntities = (): Entity[] =>\n    [...new Set([...instance.archetypes].flatMap((archetype) => [...archetype.entities]))] as Entity[];\n\n  const refresh = (archetypes: Archetype[]) => {\n    archetypes.forEach((archetype) => {\n      const cached = instance.archetypeCache.get(archetype);\n      if (cached === true) {\n        instance.archetypes.add(archetype);\n      } else if (cached === false) {\n        instance.archetypes.delete(archetype);\n      } else {\n        if (archetype.isCandidate(instance)) {\n          instance.archetypes.add(archetype);\n          instance.archetypeCache.set(archetype, true);\n        } else {\n          instance.archetypes.delete(archetype);\n          instance.archetypeCache.set(archetype, false);\n        }\n      }\n    });\n  };\n\n  return Object.freeze(Object.assign(instance, { getComponents, getEntities, refresh }));\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * Archetypes are unique groupings of Entities by Components\n * An archetype must have:\n *  - A unique ID\n *  - A Set of Entity inhabitants\n *  - A way of knowing which Components are represented (Bitfield)\n *  - A way of checking if a QueryInstance matches the Archetype's Components\n */\n\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { QueryInstance } from \"../query/instance.js\";\n\nexport interface ArchetypeSpec {\n  /** Optional */\n  id?: string;\n  /** The Bitfield */\n  bitfield: Bitfield;\n}\n\nexport interface Archetype {\n  /** Set of Entities which inhabit this Archetype */\n  entities: Set<Entity>;\n  /** The Archetype's unique ID */\n  id: string;\n  /** The Archetype's Component Bitfield */\n  bitfield: Bitfield;\n  /** Add an entity to the inhabitants list */\n  addEntity: (entity: Entity) => Archetype;\n  /** @returns an array of Entities which inhabit this Archetype */\n  getEntities: () => Entity[];\n  /** @returns `true` if the Entity inhabits this Archetype */\n  hasEntity: (entity: Entity) => boolean;\n  /** Remove an entity from the inhabitants list */\n  removeEntity: (entity: Entity) => Archetype;\n  /** @returns a clone on this archetype */\n  cloneWithToggle: <T>(component: ComponentInstance<T>) => Archetype;\n  /** Get the ID of an archetype based on this with a toggled component */\n  cloneInStep: <T>(component: ComponentInstance<T>) => [string, () => Archetype];\n  /** @returns `true` if the query criteria match this archetype */\n  isCandidate: (spec: QueryInstance) => boolean;\n}\n\nfunction validateSpec(spec: ArchetypeSpec): Required<ArchetypeSpec> {\n  if (!spec) throw new SyntaxError(\"Archetype: specification object required.\");\n  const { bitfield, id } = spec;\n  if (!bitfield) throw new SyntaxError(\"Archetype: spec.bitfield is required.\");\n  return { bitfield, id: id || bitfield.toString() };\n}\n\nfunction entityFns(state: Archetype) {\n  const { entities } = state;\n  return {\n    /** Add an entity to the inhabitants list */\n    addEntity: function (entity: Entity): Archetype {\n      entities.add(entity);\n      return state;\n    },\n    /** @returns an array of Entities which inhabit this Archetype */\n    getEntities: function (): Entity[] {\n      return [...entities];\n    },\n    /** @returns `true` if the Entity inhabits this Archetype */\n    hasEntity: function (entity: Entity): boolean {\n      return entities.has(entity);\n    },\n    /** Remove an entity from the inhabitants list */\n    removeEntity: function (entity: Entity): Archetype {\n      entities.delete(entity);\n      return state;\n    },\n  };\n}\n\nfunction cloner(state: Archetype) {\n  const { bitfield } = state;\n  const cache: Map<ComponentInstance<unknown>, Archetype> = new Map();\n  return {\n    /** @returns a clone on this archetype */\n    cloneWithToggle: function <T>(component: ComponentInstance<T>): Archetype {\n      if (cache.has(component)) return cache.get(component)!;\n      const { id } = component;\n      const bitfieldCopy = bitfield.copy().toggle(id);\n      const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldCopy.toString() });\n      cache.set(component, clone);\n      return clone;\n    },\n    cloneInStep: function <T>(component: ComponentInstance<T>): [string, () => Archetype] {\n      if (cache.has(component)) {\n        const cached = cache.get(component)!;\n        return [cached.id, () => cached];\n      } else {\n        const { id } = component;\n        const bitfieldCopy = bitfield.copy().toggle(id);\n        return [\n          bitfieldCopy.toString(),\n          function () {\n            const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldCopy.toString() });\n            cache.set(component, clone);\n            return clone;\n          },\n        ];\n      }\n    },\n  };\n}\n\nfunction candidateChecker(state: Archetype) {\n  const { bitfield } = state;\n  const _bitfield = bitfield.array;\n  const _empty: number[] = [];\n  const cache: Map<QueryInstance, boolean> = new Map();\n  return {\n    /** @returns `true` if the query criteria match this archetype */\n    isCandidate: function (query: QueryInstance): boolean {\n      if (cache.has(query)) return cache.get(query) || false;\n      const { and, or, not } = query;\n      const _not = not?.array ?? _empty;\n      const _and = and?.array ?? _empty;\n      const _or = or?.array ?? _empty;\n      function checkStatus(target: number, i: number): boolean {\n        // is ?? 0 right here??\n        const _n = _not[i] ?? 0;\n        const _a = _and[i] ?? 0;\n        const _o = _or[i] ?? 0;\n        if ((_n & target) !== 0) return false;\n        if ((_a & target) !== _a) return false;\n        if ((_o & target) > 0) return false;\n        return true;\n      }\n      const status = _bitfield.every(checkStatus);\n      cache.set(query, status);\n      return status;\n    },\n  };\n}\n\n/** Archetypes are unique groupings of entities by components */\nexport function createArchetype(spec: ArchetypeSpec): Archetype {\n  const { id, bitfield } = validateSpec(spec);\n  const entities: Set<Entity> = new Set();\n  const data = { entities, id, bitfield } as Archetype;\n  const { addEntity, getEntities, removeEntity } = entityFns(data);\n  const { cloneWithToggle, cloneInStep } = cloner(data);\n  const { isCandidate } = candidateChecker(data);\n  const result = Object.assign(data, {\n    addEntity,\n    getEntities,\n    removeEntity,\n    cloneInStep,\n    cloneWithToggle,\n    isCandidate,\n  });\n  return Object.freeze(result);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Entity } from \"../entity.js\";\nimport { ComponentBufferPartitioner, createComponentBuffer, createComponentBufferPartitioner } from \"./buffer.js\";\nimport { Component, ComponentRecord } from \"./component.js\";\nimport { ComponentInstance, createComponentInstance } from \"./instance.js\";\nimport { SchemaProps } from \"./schema.js\";\n\nexport interface ComponentManager {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>) => boolean;\n  entityHasComponent: <T>(component: Component<T>, entity: Entity) => boolean;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n}\n\nexport interface ComponentManagerSpec {\n  components: Component<unknown>[];\n  entityCapacity: number;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\n/**\n * Create component instances for the world\n * @param spec The function's specification object\n * @param spec.components An array of components to instantiate\n * @param spec.capacity The associated world's component buffer partitioner function\n * @returns an object whose keys are component names, and whose values are component instances\n */\nfunction instantiateComponents(spec: {\n  components: Component<unknown>[];\n  partitioner: ComponentBufferPartitioner;\n}): ComponentRecord {\n  const { components, partitioner } = spec;\n  const reducer = <T>(obj: ComponentRecord, component: Component<T>, id: number) => {\n    const { name } = component;\n    if (name in obj) throw new Error(`ComponentInstance with name \"${name}\" already exists.`);\n    const storage = partitioner(component);\n    obj[name] = createComponentInstance({ component, id, storage });\n    return obj;\n  };\n  return [...new Set(components)].reduce(reducer, {});\n}\n\n/**\n * Create a new ComponentManager object\n * @param spec\n * @param spec.capacity\n * @param spec.components\n */\nexport function createComponentManager(spec: ComponentManagerSpec): Readonly<ComponentManager> {\n  const { components, entityCapacity, getEntityArchetype, updateArchetype } = spec;\n\n  /** { component_name: ComponentInstance } */\n  const instances = (() => {\n    const buffer = createComponentBuffer({ entityCapacity, components });\n    const partitioner = createComponentBufferPartitioner({ buffer, entityCapacity });\n    return instantiateComponents({ components, partitioner });\n  })();\n\n  /** <Component, ComponentInstance> */\n  const componentMap: Map<Component<unknown>, ComponentInstance<unknown>> = new Map();\n  Object.values(instances).forEach(<T>(instance: ComponentInstance<T>) => {\n    componentMap.set(instance.component, instance);\n  });\n\n  function getComponentInstance<T>(component: Component<T> | string): ComponentInstance<T> | undefined {\n    if (typeof component === \"string\") {\n      return instances[component] as ComponentInstance<T> | undefined;\n    } else {\n      return componentMap.get(component) as ComponentInstance<T> | undefined;\n    }\n  }\n\n  return Object.freeze({\n    componentMap,\n\n    addComponentToEntity<T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>): boolean {\n      const inst = getComponentInstance(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      if (props) {\n        Object.entries(props).forEach(([key, value]) => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          inst[key][entity] = value;\n        });\n      }\n      return true;\n    },\n\n    entityHasComponent<T>(component: Component<T>, entity: Entity): boolean {\n      const inst = getComponentInstance(component);\n      if (!inst) return false;\n      const arch = getEntityArchetype(entity);\n      if (!arch) return false;\n      const { bitfield } = arch;\n      return bitfield.isOn(inst.id);\n    },\n\n    removeComponentFromEntity<T>(component: Component<T>, entity: Entity): boolean {\n      const inst = getComponentInstance(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      return true;\n    },\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isUint32, TypedArray } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentInstanceSpec<T> {\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport interface ComponentInstance<T> extends Component<T> {\n  /** The instance's parent component */\n  component: Component<T>;\n  /** The instance's identifier */\n  id: number;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T> & Record<keyof T, TypedArray>> {\n  const { component, id, storage } = spec;\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n  const instance = Object.create(component, {\n    component: {\n      value: component,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n  return Object.freeze(Object.assign(instance, storage));\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ONE_BYTE } from \"../constants.js\";\nimport { TypedArray, TypedArrayConstructor } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentBufferSpec {\n  components: Component<unknown>[];\n  entityCapacity: number;\n}\n\nexport interface ComponentBufferPartitionerSpec {\n  buffer: ArrayBuffer;\n  entityCapacity: number;\n}\n\n/** <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray } */\nexport type ComponentBufferPartitioner = <T>(component: Component<T>) => SchemaStorage<T> | undefined;\n\n/** Calculate the total required storage space for all component schemas */\nfunction getComponentSize(entityCapacity: number, components: Component<unknown>[]) {\n  function componentSum<T>(total: number, component: Component<T>): number {\n    const { size = 0 } = component;\n    if (!size || size <= 0) return total;\n    return total + size * entityCapacity;\n  }\n  return components.reduce(componentSum, 0);\n}\n\n/**\n * Create a properly sized ArrayBuffer to hold all a world's component's data.\n * @param spec The component buffer's specification object\n * @param spec.entityCapacity The world's entity capacity\n * @param spec.components The components which the buffer will contain\n */\nexport function createComponentBuffer(spec: ComponentBufferSpec): ArrayBuffer {\n  const { entityCapacity, components } = spec;\n  const totalSize = getComponentSize(entityCapacity, components);\n  return new ArrayBuffer(ONE_BYTE * Math.ceil(totalSize / ONE_BYTE));\n}\n\n/**\n * Creates a function which allows for the creation of component storage partitions.\n * @param spec the partitioner's specification object\n * @param spec.buffer the buffer to partition\n * @param spec.entityCapacity the world's entity capacity\n * @returns <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray };\n */\nexport function createComponentBufferPartitioner(spec: ComponentBufferPartitionerSpec): ComponentBufferPartitioner {\n  const { buffer, entityCapacity } = spec;\n  let bufferOffset = 0;\n  let full = false;\n\n  return function partitionComponentBuffer<T>(component: Component<T>): SchemaStorage<T> | undefined {\n    if (full === true) throw new Error(\"ArrayBuffer is full!\");\n    const { schema, size = 0 } = component;\n    if (!size || size <= 0) return; // bail early if component is a tag\n    if (bufferOffset + size * entityCapacity > buffer.byteLength) {\n      throw new Error(\"Component will not fit inside the buffer!\");\n    }\n\n    let componentOffset = 0;\n    function partition(res: Record<keyof T, TypedArray>, [key, TypedArray]: [keyof T, TypedArrayConstructor]) {\n      res[key] = new TypedArray(buffer, bufferOffset + componentOffset, entityCapacity);\n      componentOffset += TypedArray.BYTES_PER_ELEMENT * entityCapacity;\n      return res;\n    }\n\n    const data = Object.entries(schema as Record<keyof T, TypedArrayConstructor>) as [keyof T, TypedArrayConstructor][];\n    const storage = data.reduce(partition, {} as Record<keyof T, TypedArray>);\n\n    bufferOffset += componentOffset;\n    if (bufferOffset > buffer.byteLength) full = true;\n\n    return storage;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { isUint32 } from \"./utils.js\";\n\n/** Entities are indexes of an EntityArray */\nexport type Entity = number;\n\nexport interface EntityManagerSpec {\n  availableEntities: Entity[];\n  entityArchetypes: Archetype[];\n  entityCapacity: number;\n}\n\nexport interface EntityManager {\n  createEntity: () => Entity | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  hasEntity: (entity: Entity) => boolean;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n}\n\n/**\n *\n * @param capacity\n * @returns\n */\nfunction entityValidator(capacity: number): (entity: Entity) => entity is Entity {\n  /** @return `true` if the given entity is valid for the given capacity */\n  return function isValidEntity(entity: number): entity is Entity {\n    if (!isUint32(entity) || entity > capacity) return false;\n    return true;\n  };\n}\n\n/** Manages the creation, destruction and recycling of entities */\nexport function createEntityManager(spec: EntityManagerSpec): Readonly<EntityManager> {\n  if (!spec) throw new SyntaxError(\"EntityManager creation requires a spec object.\");\n  const { availableEntities, entityArchetypes, entityCapacity } = spec;\n  const isValidEntity = entityValidator(entityCapacity);\n\n  return Object.freeze({\n    /** @returns the next available Entity or `undefined` if no Entity is available */\n    createEntity(): Entity | undefined {\n      return availableEntities.pop();\n    },\n\n    /**\n     * Remove and recycle an Entity\n     * @returns `true` if there was an archetype change\n     */\n    destroyEntity(entity: Entity): boolean {\n      if (isValidEntity(entity) && entityArchetypes[entity] != undefined) {\n        const a = entityArchetypes[entity];\n        if (a) a.removeEntity(entity);\n        availableEntities.push(entity);\n        delete entityArchetypes[entity];\n        return true;\n      } else {\n        delete entityArchetypes[entity]; // just in case\n        return false;\n      }\n    },\n\n    /** @returns the Entity's Archetype or undefined if Entity is not alive */\n    getEntityArchetype(entity: Entity): Archetype | undefined {\n      return entityArchetypes[entity];\n    },\n\n    /** @return `true` if the Entity !== undefined */\n    hasEntity(entity: Entity): boolean {\n      return isValidEntity(entity) && entityArchetypes[entity] !== undefined;\n    },\n\n    /** @returns `true` if the Archetype was changed successfully */\n    setEntityArchetype(entity: Entity, archetype: Archetype): boolean {\n      if (isValidEntity(entity)) {\n        entityArchetypes[entity] = archetype;\n        return true;\n      }\n      return false;\n    },\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\nimport { isTypedArray, isUint32 } from \"./utils.js\";\n\nexport interface BitfieldSpec {\n  /** The number of bits/flags required */\n  capacity: number;\n  /** Optional pre-created bitfield array (avoids new array generation) */\n  array?: Uint32Array;\n}\n\nexport interface Bitfield {\n  /** The size of the bitfield */\n  capacity: number;\n  /** The underlying bit array */\n  array: Uint32Array;\n  /**\n   * Set all bits to 0\n   * @returns `true` if the bitfield array was cleared successfully\n   */\n  clear: () => Bitfield;\n  /** @returns a new Bitfield based on this Bitfield */\n  copy: () => Bitfield;\n  /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n  isOn: (bit: number) => boolean;\n  /**\n   * Set a bit 'off' (e.g., falsy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  off: (bit: number) => Bitfield;\n  /**\n   * Set a bit 'on' (e.g., truthy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  on: (bit: number) => Bitfield;\n  /**\n   * Toggle a bit in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  toggle: (bit: number) => Bitfield;\n  /** @returns the bitfield array as a string */\n  toString: () => string;\n}\n\n/** Curried bitfield factory function */\nexport function bitfieldCloner(bitfield: Bitfield) {\n  return function () {\n    return bitfield.copy().clear();\n  };\n}\n\n/**\n * Create a new Bitfield\n * @param spec The Bitfield's specification object\n * @param spec.capacity The number of bits/flags\n * @param spec.array Optional pre-created bitfield array (avoids new array generation)\n */\nexport function bitfield(spec: BitfieldSpec): Bitfield {\n  const { capacity, array } = validateSpec(spec);\n  const state = { capacity, array } as Bitfield;\n  const bitToIdx = getBitIndex(capacity);\n  // @todo parallelize?\n  const { clear } = clearer(state);\n  const { copy } = copier(state);\n  const { isOn } = onChecker(state, bitToIdx);\n  const { off } = offer(state, bitToIdx);\n  const { on } = onner(state, bitToIdx);\n  const { toggle } = toggler(state, bitToIdx);\n  const { toString } = stringifier(state);\n  return Object.freeze(Object.assign(state, { clear, copy, isOn, off, on, toggle, toString }));\n}\n\n/** Validates and returns a BitfieldSpec object */\nfunction validateSpec(spec: BitfieldSpec): Required<BitfieldSpec> {\n  if (!spec) throw new SyntaxError(\"Bitfield: a specification object is required.\");\n  const { capacity, array } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"Bitfield: spec.capacity is invalid.\");\n  if (array) {\n    if (!isTypedArray(array)) throw new TypeError(\"Bitfield: spec.array is invalid.\");\n    if (array.length !== (capacity + 31) >>> 5) throw new SyntaxError(\"Bitfield: spec.array is wrong size.\");\n  }\n  return { capacity, array: array || new Uint32Array((capacity + 31) >>> 5) };\n}\n\n/** Check if bit is valid and convert to array index */\nfunction getBitIndex(capacity: number): (bit: number) => number {\n  return function bitToIdx(bit: number): number {\n    if (bit == undefined || isNaN(bit) || bit < 0 || bit > capacity) return -1;\n    return bit >>> 5;\n  };\n}\n\nfunction clearer(state: Bitfield) {\n  const { array } = state;\n  return {\n    /**\n     * Set all bits to 0\n     * @returns `true` if the bitfield array was cleared successfully\n     */\n    clear: function (): Bitfield {\n      array.fill(0);\n      return state;\n    },\n  };\n}\n\nfunction copier(state: Bitfield) {\n  const { capacity, array } = state;\n  return {\n    /** @returns a new Bitfield based on this Bitfield */\n    copy: function (): Bitfield {\n      return bitfield({ capacity, array: array.slice() });\n    },\n  };\n}\n\nfunction offer(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'off' (e.g., falsy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    off: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] &= ~(1 << (bit - i * 32));\n      return state;\n    },\n  };\n}\n\nfunction onner(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'on' (e.g., truthy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    on: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] |= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n\nfunction onChecker(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n    isOn: function (bit: number): boolean {\n      const i = bitToIdx(bit);\n      if (i === -1) return false;\n      const cell = array[i];\n      if (!cell) return false;\n      return Boolean(cell & (1 << (bit - i * 32)));\n    },\n  };\n}\n\nfunction stringifier(state: Bitfield) {\n  const { array } = state;\n  return {\n    /** @returns the bitfield array as a string */\n    toString: function (): string {\n      return array.toString();\n    },\n  };\n}\n\nfunction toggler(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Toggle a bit in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    toggle: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] ^= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { createArchetypeManager } from \"./archetype/manager.js\";\nimport { Component } from \"./component/component.js\";\nimport { ComponentInstance } from \"./component/instance.js\";\nimport { createComponentManager } from \"./component/manager.js\";\nimport { DEFAULT_MAX_ENTITIES, VERSION } from \"./constants.js\";\nimport { Entity } from \"./entity.js\";\nimport { createEntityManager } from \"./entity.js\";\nimport { Bitfield, bitfield, bitfieldCloner } from \"./bitfield.js\";\nimport { QueryInstance } from \"./query/instance.js\";\nimport { Query } from \"./query/query.js\";\nimport { isUint32 } from \"./utils.js\";\nimport { SchemaProps } from \"./component/schema.js\";\n\nexport interface WorldSpec {\n  /** Components to instantiate in the world  */\n  components: Component<unknown>[];\n  /** The maximum number of entities allowed in the world */\n  entityCapacity: number;\n}\n\nexport interface WorldProto {\n  version: string;\n}\n\nexport interface WorldData extends WorldProto {\n  archetypes: Map<string, Archetype>;\n  availableEntities: Entity[];\n  components: Map<Component<unknown>, ComponentInstance<unknown>>;\n  emptyBitfield: Bitfield;\n  entityArchetypes: Archetype[];\n  entityCapacity: number;\n  bitfieldFactory: (components?: ComponentInstance<unknown>[]) => Bitfield;\n  queries: Map<Query, QueryInstance>;\n}\n\nexport interface World extends WorldData {\n  createEntity: () => number | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: number) => Archetype | undefined;\n  hasEntity: (entity: number) => boolean;\n  addComponentToEntity: <T>(component: Component<T>, entity: number, props?: SchemaProps<T> | undefined) => boolean;\n  entityHasComponent: <T>(component: Component<T>, entity: number) => boolean;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: number) => boolean;\n  refreshWorld: () => void;\n}\n\n/** World.prototype - Miski version data etc. */\nexport const WORLD_PROTO: WorldProto = Object.freeze({\n  version: VERSION,\n});\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec) throw new SyntaxError(\"World creation requires a specification object.\");\n  const { components = [], entityCapacity = DEFAULT_MAX_ENTITIES } = spec;\n  if (!isUint32(entityCapacity)) throw new SyntaxError(\"World creation: spec.entityCapacity invalid.\");\n  if (!components.length) throw new SyntaxError(\"World creation: spec.components invalid.\");\n  return { components, entityCapacity };\n}\n\nfunction addBitfieldFactory({ capacity }: { capacity: number }) {\n  const emptyBitfield = bitfield({ capacity });\n  const bitfieldFactory = bitfieldCloner(emptyBitfield);\n  return { emptyBitfield, bitfieldFactory };\n}\n\nfunction addAvailableEntityArray({ entityCapacity }: { entityCapacity: number }) {\n  // @todo would this be better as a generator?\n  const availableEntities: Entity[] = ((length: number) => {\n    const total = length - 1;\n    return Array.from({ length }, (_, i) => total - i);\n  })(entityCapacity);\n  return { availableEntities };\n}\n\nfunction addArchetypeArray({ entityCapacity }: { entityCapacity: number }) {\n  const entityArchetypes: Archetype[] = [];\n  entityArchetypes.length = entityCapacity; // @note V8 hack, quicker/smaller than new Array(capacity)\n  return { entityArchetypes };\n}\n\nexport function createWorld(spec: WorldSpec): Readonly<World> {\n  const { components, entityCapacity } = validateWorldSpec(spec);\n  const { availableEntities } = addAvailableEntityArray({ entityCapacity });\n  const { entityArchetypes } = addArchetypeArray({ entityCapacity });\n  const { emptyBitfield, bitfieldFactory } = addBitfieldFactory({ capacity: components.length });\n\n  const { createEntity, destroyEntity, getEntityArchetype, hasEntity, setEntityArchetype } = createEntityManager({\n    availableEntities,\n    entityArchetypes,\n    entityCapacity,\n  });\n\n  const { archetypeMap, updateArchetype } = createArchetypeManager({\n    bitfieldFactory,\n    getEntityArchetype,\n    setEntityArchetype,\n  });\n\n  const { componentMap, addComponentToEntity, entityHasComponent, removeComponentFromEntity } = createComponentManager({\n    components,\n    entityCapacity,\n    getEntityArchetype,\n    updateArchetype,\n  });\n\n  const queries: Map<Query, QueryInstance> = new Map();\n\n  const world: WorldData = Object.assign(Object.create(WORLD_PROTO), {\n    entityCapacity,\n    availableEntities,\n    entityArchetypes,\n    archetypes: archetypeMap,\n    components: componentMap,\n    queries,\n    emptyBitfield,\n    bitfieldFactory,\n  }) as WorldData;\n\n  function refreshWorld() {\n    const archetypes = [...archetypeMap.values()];\n    const refresh = (instance: QueryInstance) => instance.refresh(archetypes);\n    queries.forEach(refresh);\n  }\n  refreshWorld();\n\n  return Object.freeze(\n    Object.assign(Object.create(world), {\n      createEntity,\n      destroyEntity,\n      getEntityArchetype,\n      hasEntity,\n      addComponentToEntity,\n      entityHasComponent,\n      removeComponentFromEntity,\n      refreshWorld,\n    }) as World,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Archetype, createArchetype } from \"./archetype.js\";\n\nexport interface ArchetypeManagerSpec {\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Bitfield;\n  getEntityArchetype: (entity: number) => Archetype | undefined;\n  setEntityArchetype: (entity: number, archetype: Archetype) => boolean;\n}\n\nexport interface ArchetypeManager {\n  archetypeMap: Map<string, Archetype>;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\nexport function createArchetypeManager(spec: ArchetypeManagerSpec): ArchetypeManager {\n  const { bitfieldFactory, getEntityArchetype, setEntityArchetype } = spec;\n  const componentCache: Map<ComponentInstance<unknown>, Archetype> = new Map(); // wrong!!\n  const archetypeMap: Map<string, Archetype> = new Map();\n\n  return {\n    archetypeMap,\n\n    /**\n     * Update an entity's archetype\n     * @param entity the entity to update\n     * @param component the component to toggle\n     * @returns the entity's new archetype\n     */\n    updateArchetype<T>(entity: Entity, component: ComponentInstance<T>): Archetype {\n      const previousArchetype = getEntityArchetype(entity);\n      let nextArchetype: Archetype | undefined;\n      if (previousArchetype) {\n        previousArchetype.removeEntity(entity);\n        const [id, factory] = previousArchetype.cloneInStep(component);\n        if (archetypeMap.has(id)) {\n          nextArchetype = archetypeMap.get(id)!;\n        } else {\n          nextArchetype = factory();\n          archetypeMap.set(id, nextArchetype);\n        }\n      } else {\n        if (componentCache.has(component)) {\n          nextArchetype = componentCache.get(component) as Archetype;\n        } else {\n          nextArchetype = createArchetype({ bitfield: bitfieldFactory([component]) });\n          componentCache.set(component, nextArchetype);\n          archetypeMap.set(nextArchetype.id, nextArchetype);\n        }\n      }\n      nextArchetype.addEntity(entity);\n      setEntityArchetype(entity, nextArchetype);\n      return nextArchetype;\n    },\n  };\n}\n"],"names":["DEFAULT_MAX_ENTITIES","FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","isUint32","n","isNaN","isValidName","str","Boolean","length","test","includes","isObject","object","Array","isArray","byteSum","total","value","BYTES_PER_ELEMENT","calculateSchemaSize","schema","values","reduce","createComponent","spec","SyntaxError","name","keys","every","isValidSchema","component","isTag","size","state","instance","world","components","get","createQuery","all","any","none","prototype","hasOwnProperty","call","query","getResult","bitfieldFactory","queries","and","or","not","arr","inst","Error","push","_components","archetypeCache","Map","archetypes","Set","assign","getComponents","getEntities","flatMap","archetype","entities","refresh","forEach","cached","add","delete","isCandidate","set","createQueryInstance","createArchetype","id","bitfield","toString","validateSpec","data","addEntity","removeEntity","entity","hasEntity","has","entityFns","cloneWithToggle","cloneInStep","cache","bitfieldCopy","copy","toggle","clone","cloner","_bitfield","array","_empty","_not","_and","_or","status","target","i","_n","_a","_o","candidateChecker","result","instantiateComponents","partitioner","obj","storage","TypeError","create","configurable","enumerable","writable","createComponentInstance","createComponentManager","entityCapacity","getEntityArchetype","updateArchetype","instances","buffer","bufferOffset","full","byteLength","componentOffset","entries","res","key","TypedArray","createComponentBufferPartitioner","totalSize","getComponentSize","ArrayBuffer","Math","ceil","createComponentBuffer","componentMap","getComponentInstance","[object Object]","props","arch","isOn","createEntityManager","availableEntities","entityArchetypes","isValidEntity","capacity","createEntity","pop","undefined","a","setEntityArchetype","isView","DataView","Uint32Array","bitToIdx","bit","getBitIndex","clear","fill","clearer","slice","copier","cell","onChecker","off","offer","on","onner","toggler","stringifier","WORLD_PROTO","version","createWorld","validateWorldSpec","from","_","addAvailableEntityArray","addArchetypeArray","emptyBitfield","bitfieldCloner","addBitfieldFactory","destroyEntity","archetypeMap","componentCache","previousArchetype","nextArchetype","factory","createArchetypeManager","addComponentToEntity","entityHasComponent","removeComponentFromEntity","refreshWorld"],"mappings":"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"}