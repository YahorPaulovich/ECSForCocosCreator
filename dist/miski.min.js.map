{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/archetype/archetype.ts","../src/component/manager.ts","../src/component/instance.ts","../src/component/buffer.ts","../src/entity.ts","../src/bitfield.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts","../src/archetype/manager.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport * as pkg from \"../package.json\";\n\n/** Miski version */\nexport const VERSION: string = pkg.version;\n\n/** Default maximum entities value */\nexport const DEFAULT_MAX_ENTITIES = 1_000_000;\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties\n  \"component\",\n  \"id\",\n  \"isTag\",\n  \"name\",\n  \"schema\",\n  \"size\",\n  // object properties\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** The number 8 - to avoid magic numbers */\nexport const ONE_BYTE = 8;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"./constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArrayConstructor {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    (typeof str === \"string\" && str.length > 0 && VALID_NAME_PATTERN.test(str) === true) ||\n      !FORBIDDEN_NAMES.includes(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/** An empty function for use in Systems */\nexport function noop(): void {\n  return void 0;\n}\n\n/** */\nexport const pipe =\n  <T, U>(...fns: ((arg: T) => T)[]) =>\n  (value: T) =>\n    fns.reduce((acc, fn) => fn(acc), value) as unknown as U;\n\n/** @author https://stackoverflow.com/a/67605309 */\nexport type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never;\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isValidName, TypedArray, TypedArrayConstructor } from \"../utils.js\";\n\n/** The interface available to end users */\nexport type SchemaProps<T> = Record<keyof T, number>;\n\n/** Component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n * Values in the array are initialised to 0 by default.\n * To set your own default value: `{ property: [Int8Array, default value] }`.\n */\nexport type Schema<T> = Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Schema type guard */\nexport function isValidSchema<T>(schema: unknown): schema is Schema<T> {\n  return isObject(schema) && Object.keys(schema).every((name) => isValidName(name));\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/** @returns the size in bytes that a component's storage requires for one entity */\nexport function calculateSchemaSize<T>(schema: Schema<T>): number {\n  return Object.values(schema).reduce(byteSum, 0) as number;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isValidName } from \"../utils.js\";\nimport { ComponentInstance } from \"./instance.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\n/** { [component name]: component instance } */\nexport type ComponentRecord = Record<string, ComponentInstance<unknown>>;\n\nexport interface ComponentSpec<T> {\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport interface Component<T> {\n  /** `true` if the component has no schema */\n  isTag: boolean;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  size: number;\n}\n\n/**\n * Define a new component.\n * @param spec the component's specification.\n * @param spec.name the component's string identifier.\n * @param spec.schema the component's optional schema object.\n * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n */\nexport function createComponent<T extends Schema<T>>(spec: ComponentSpec<T>): Component<T> {\n  if (!spec) throw new SyntaxError(\"Component creation requires a specification object.\");\n  const { name, schema } = spec;\n  if (!isValidName(name)) throw new SyntaxError(\"Component name is invalid.\");\n  if (schema && !isValidSchema(schema)) throw new SyntaxError(\"Component schema is invalid.\");\n  return Object.freeze({\n    isTag: schema ? false : true,\n    name,\n    schema: schema ? Object.freeze({ ...schema }) : null,\n    size: schema ? calculateSchemaSize(schema) : 0,\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Readonly<Component<unknown>[]>;\n}\n\n/** Queries are groupings of archetypes */\nexport interface Query {\n  /** AND - Gather entities as long as they have all these components */\n  all: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none: Readonly<Component<unknown>[]>;\n}\n\n/**\n * Create a new Query\n * @param spec The Query's specification object\n * @param spec.all\n * @param spec.any\n * @param spec.none\n */\nexport function createQuery(spec: QuerySpec): Readonly<Query> {\n  if (!spec) throw new SyntaxError(\"createQuery: specification object is required.\");\n  const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n  if (![...all, ...any, ...none].every((component) => Object.prototype.hasOwnProperty.call(component, \"name\"))) {\n    throw new SyntaxError(\"Query specification object is invalid.\");\n  }\n  return Object.freeze({\n    all: Object.freeze([...all]),\n    any: Object.freeze([...any]),\n    none: Object.freeze([...none]),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ParametersExceptFirst } from \"./utils.js\";\nimport { World } from \"./world.js\";\n\n/** A multi-arity function where the first parameter is always the World object */\nexport type System<T extends (world: World, ...args: any[]) => ReturnType<T>, U extends ParametersExceptFirst<T>> = (\n  world: World,\n  ...args: U\n) => ReturnType<T>;\n\n/**\n * Creates a new curried System function\n * @param callback the System function to be called\n * @returns a curried function (world) => (...args) => result;\n *\n * @example\n * const world = {} as World;\n * const log = (world: World, value: string) => console.log(value);\n * const logSystem = createSystem(log);\n * const logSystemInstance = logSystem(world);\n * logSystemInstance(\"hello, world!\"); // hello, world!\n */\nexport function createSystem<\n  T extends (world: World, ...args: any[]) => ReturnType<T>,\n  U extends ParametersExceptFirst<T>,\n>(callback: System<T, U>) {\n  return function (world: World) {\n    return function (...args: U): ReturnType<T> {\n      return callback(world, ...args);\n    };\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * Archetypes are unique groupings of Entities by Components\n * An archetype must have:\n *  - A unique ID\n *  - A Set of Entity inhabitants\n *  - A way of knowing which Components are represented (Bitfield)\n *  - A way of checking if a QueryInstance matches the Archetype's Components\n */\n\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { QueryData } from \"../query/instance.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\n\nexport interface ArchetypeSpec {\n  /** Optional */\n  id?: string;\n  /** The Bitfield */\n  bitfield: Bitfield;\n}\n\nexport interface Archetype {\n  /** Set of Entities which inhabit this Archetype */\n  entities: Set<Entity>;\n  /** The Archetype's unique ID */\n  id: string;\n  /** The Archetype's Component Bitfield */\n  bitfield: Bitfield;\n  /** Add an entity to the inhabitants list */\n  addEntity: (entity: Entity) => Archetype;\n  /** @returns an iterator of Entities which inhabit this Archetype */\n  getEntities: () => IterableIterator<Entity>;\n  /** @returns `true` if the Entity inhabits this Archetype */\n  hasEntity: (entity: Entity) => boolean;\n  /** Remove an entity from the inhabitants list */\n  removeEntity: (entity: Entity) => Archetype;\n  /** @returns a clone on this archetype */\n  cloneWithToggle: <T>(component: ComponentInstance<T>) => Archetype;\n  /** Get the ID of an archetype based on this with a toggled component */\n  cloneInStep: <T>(component: ComponentInstance<T>) => [string, () => Archetype];\n  /** @returns `true` if the query criteria match this archetype */\n  isCandidate: (query: QueryData) => boolean;\n}\n\nfunction validateSpec(spec: ArchetypeSpec): Required<ArchetypeSpec> {\n  if (!spec) throw new SyntaxError(\"Archetype: specification object required.\");\n  const { bitfield, id } = spec;\n  if (!bitfield) throw new SyntaxError(\"Archetype: spec.bitfield is required.\");\n  return { bitfield, id: id || bitfield.toString() };\n}\n\nfunction entityFns(state: Archetype) {\n  const { entities } = state;\n  return {\n    /** Add an entity to the inhabitants list */\n    addEntity: function (entity: Entity): Archetype {\n      entities.add(entity);\n      return state;\n    },\n    /** @returns an array of Entities which inhabit this Archetype */\n    getEntities: function (): IterableIterator<Entity> {\n      return entities.values();\n    },\n    /** @returns `true` if the Entity inhabits this Archetype */\n    hasEntity: function (entity: Entity): boolean {\n      return entities.has(entity);\n    },\n    /** Remove an entity from the inhabitants list */\n    removeEntity: function (entity: Entity): Archetype {\n      entities.delete(entity);\n      return state;\n    },\n  };\n}\n\nfunction cloner(state: Archetype) {\n  const { bitfield } = state;\n  const cache: Map<ComponentInstance<unknown>, Archetype> = new Map();\n  return {\n    /** @returns a clone on this archetype */\n    cloneWithToggle: function <T>(component: ComponentInstance<T>): Archetype {\n      if (cache.has(component)) return cache.get(component)!;\n      const { id } = component;\n      const bitfieldCopy = bitfield.copy().toggle(id);\n      const clone = createArchetype({ bitfield: bitfieldCopy });\n      cache.set(component, clone);\n      return clone;\n    },\n    cloneInStep: function <T>(component: ComponentInstance<T>): [string, () => Archetype] {\n      if (cache.has(component)) {\n        const cached = cache.get(component)!;\n        return [cached.id, () => cached];\n      } else {\n        const { id } = component;\n        const bitfieldCopy = bitfield.copy().toggle(id);\n        const bitfieldId = bitfieldCopy.toString();\n        return [\n          bitfieldId,\n          function () {\n            const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldId });\n            cache.set(component, clone);\n            return clone;\n          },\n        ];\n      }\n    },\n  };\n}\n\nfunction candidateChecker(state: Archetype) {\n  const { bitfield } = state;\n  const _bitfield = bitfield.array;\n  const cache: Map<QueryData, boolean> = new Map();\n  return {\n    /** @returns `true` if the query criteria match this archetype */\n    isCandidate: function (query: QueryData): boolean {\n      if (cache.has(query)) return cache.get(query) || false;\n      const { and, or, not } = query;\n      const _not = not?.array ?? EMPTY_ARRAY;\n      const _and = and?.array ?? EMPTY_ARRAY;\n      const _or = or?.array ?? EMPTY_ARRAY;\n      function checkStatus(target: number, i: number): boolean {\n        // is ?? 0 right here??\n        const _n = _not[i] ?? 0;\n        const _a = _and[i] ?? 0;\n        const _o = _or[i] ?? 0;\n        if ((_n & target) !== 0) return false;\n        if ((_a & target) !== _a) return false;\n        if ((_o & target) > 0) return false;\n        return true;\n      }\n      const status = _bitfield.every(checkStatus);\n      cache.set(query, status);\n      return status;\n    },\n  };\n}\n\n/** Archetypes are unique groupings of entities by components */\nexport function createArchetype(spec: ArchetypeSpec): Archetype {\n  const { id, bitfield } = validateSpec(spec);\n  const entities: Set<Entity> = new Set();\n  const data = { entities, id, bitfield } as Archetype;\n  const { addEntity, getEntities, removeEntity } = entityFns(data);\n  const { cloneWithToggle, cloneInStep } = cloner(data);\n  const { isCandidate } = candidateChecker(data);\n  const result = Object.assign(data, {\n    addEntity,\n    getEntities,\n    removeEntity,\n    cloneInStep,\n    cloneWithToggle,\n    isCandidate,\n  });\n  return Object.freeze(result);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Entity } from \"../entity.js\";\nimport { ComponentBufferPartitioner, createComponentBuffer, createComponentBufferPartitioner } from \"./buffer.js\";\nimport { Component, ComponentRecord } from \"./component.js\";\nimport { ComponentInstance, createComponentInstance } from \"./instance.js\";\nimport { SchemaProps } from \"./schema.js\";\n\nexport interface ComponentManager {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>) => boolean;\n  entityHasComponent: <T>(entity: Entity, component: Component<T>) => boolean;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n}\n\nexport interface ComponentManagerSpec {\n  components: Component<unknown>[];\n  capacity: number;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\n/**\n * Create component instances for the world\n * @param spec The function's specification object\n * @param spec.components An array of components to instantiate\n * @param spec.capacity The associated world's component buffer partitioner function\n * @returns an object whose keys are component names, and whose values are component instances\n */\nfunction instantiateComponents(spec: {\n  components: Component<unknown>[];\n  partitioner: ComponentBufferPartitioner;\n}): ComponentRecord {\n  const { components, partitioner } = spec;\n  const reducer = <T>(obj: ComponentRecord, component: Component<T>, id: number) => {\n    const { name } = component;\n    if (name in obj) throw new Error(`ComponentInstance with name \"${name}\" already exists.`);\n    const storage = partitioner(component);\n    obj[name] = createComponentInstance({ component, id, storage });\n    return obj;\n  };\n  return [...new Set(components)].reduce(reducer, {});\n}\n\n/**\n * Create a new ComponentManager object\n * @param spec\n * @param spec.capacity\n * @param spec.components\n */\nexport function createComponentManager(spec: ComponentManagerSpec): Readonly<ComponentManager> {\n  const { components, capacity, getEntityArchetype, updateArchetype } = spec;\n\n  const buffer = createComponentBuffer({ capacity, components });\n  const partitioner = createComponentBufferPartitioner({ buffer, capacity });\n\n  /** { component_name: ComponentInstance } */\n  const instances = instantiateComponents({ components, partitioner });\n\n  /** <Component, ComponentInstance> */\n  const componentMap: Map<Component<unknown>, ComponentInstance<unknown>> = new Map();\n  Object.values(instances).forEach(<T>(instance: ComponentInstance<T>) => {\n    componentMap.set(Object.getPrototypeOf(instance) as Component<T>, instance);\n  });\n\n  return Object.freeze({\n    componentMap,\n\n    addComponentToEntity<T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>): boolean {\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      // set any default initial properties\n      if (component.schema) {\n        Object.entries(component.schema).forEach(([key, value]) => {\n          if (Array.isArray(value)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n            inst[key][entity] = value[1] ?? 0;\n          }\n        });\n      }\n      // set any custom initial properties\n      if (props) {\n        Object.entries(props).forEach(([key, value]) => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          inst[key][entity] = value;\n        });\n      }\n      return true;\n    },\n\n    entityHasComponent<T>(entity: Entity, component: Component<T>): boolean {\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      const arch = getEntityArchetype(entity);\n      if (!arch) return false;\n      const { bitfield } = arch;\n      return bitfield.isOn(inst.id);\n    },\n\n    removeComponentFromEntity<T>(component: Component<T>, entity: Entity): boolean {\n      const inst = componentMap.get(component);\n      if (!inst) return false;\n      updateArchetype(entity, inst);\n      return true;\n    },\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isUint32, TypedArray } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentInstanceSpec<T> {\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport interface ComponentInstance<T> extends Component<T> {\n  /** The instance's identifier */\n  id: number;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T> & Record<keyof T, TypedArray>> {\n  const { component, id, storage } = spec;\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n  const instance = Object.create(component, {\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n  return Object.freeze(Object.assign(instance, storage));\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ONE_BYTE } from \"../constants.js\";\nimport { TypedArrayConstructor } from \"../utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\nexport interface ComponentBufferSpec {\n  components: Component<unknown>[];\n  capacity: number;\n}\n\nexport interface ComponentBufferPartitionerSpec {\n  buffer: ArrayBuffer;\n  capacity: number;\n}\n\n/** <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray } */\nexport type ComponentBufferPartitioner = <T>(component: Component<T>) => SchemaStorage<T> | undefined;\n\n/** Calculate the total required storage space for all component schemas */\nfunction getComponentSize(capacity: number, components: Component<unknown>[]) {\n  function componentSum<T>(total: number, component: Component<T>): number {\n    const { size = 0 } = component;\n    if (!size || size <= 0) return total;\n    return total + size * capacity;\n  }\n  return components.reduce(componentSum, 0);\n}\n\n/**\n * Create a properly sized ArrayBuffer to hold all a world's component's data.\n * @param spec The component buffer's specification object\n * @param spec.capacity The world's entity capacity\n * @param spec.components The components which the buffer will contain\n */\nexport function createComponentBuffer(spec: ComponentBufferSpec): ArrayBuffer {\n  const { capacity, components } = spec;\n  const totalSize = getComponentSize(capacity, components);\n  return new ArrayBuffer(ONE_BYTE * Math.ceil(totalSize / ONE_BYTE));\n}\n\n/**\n * Creates a function which allows for the creation of component storage partitions.\n * @param spec the partitioner's specification object\n * @param spec.buffer the buffer to partition\n * @param spec.capacity the world's entity capacity\n * @returns <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray };\n */\nexport function createComponentBufferPartitioner(spec: ComponentBufferPartitionerSpec): ComponentBufferPartitioner {\n  const { buffer, capacity } = spec;\n  let bufferOffset = 0;\n  let full = false;\n\n  return function partitionComponentBuffer<T>(component: Component<T>): SchemaStorage<T> | undefined {\n    if (full === true) throw new Error(\"ArrayBuffer is full!\");\n    const { schema, size = 0 } = component;\n    if (!size || size <= 0) return; // bail early if component is a tag\n    if (bufferOffset + size * capacity > buffer.byteLength) {\n      throw new Error(\"Component will not fit inside the buffer!\");\n    }\n\n    let componentOffset = 0;\n    function partition(\n      res: SchemaStorage<T>,\n      [key, value]: [keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]],\n    ) {\n      let typedArray = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) {\n        const [arrayConstructor, defaultValue] = value;\n        typedArray = arrayConstructor;\n        initialValue = defaultValue;\n      }\n      res[key] = new typedArray(buffer, bufferOffset + componentOffset, capacity);\n      if (initialValue !== 0) res[key].fill(initialValue as never);\n      componentOffset += typedArray.BYTES_PER_ELEMENT * capacity;\n      return res;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const data = Object.entries(schema!) as [keyof T, TypedArrayConstructor][];\n    const storage = data.reduce(partition, {} as SchemaStorage<T>);\n\n    bufferOffset += componentOffset;\n    if (bufferOffset > buffer.byteLength) full = true;\n\n    return storage;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { isUint32 } from \"./utils.js\";\n\n/** Entities are indexes of an EntityArray */\nexport type Entity = number;\n\nexport interface EntityManagerSpec {\n  capacity: number;\n}\n\nexport interface EntityManager {\n  createEntity: () => Entity | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  getVacancyCount: () => number;\n  hasEntity: (entity: Entity) => boolean;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n}\n\nfunction createEntityArchetypeArray(capacity: number) {\n  const entityArchetypes: Archetype[] = [];\n  entityArchetypes.length = capacity; // @note V8 hack, quicker/smaller than new Array(capacity)\n  return entityArchetypes;\n}\n\nfunction createAvailableEntityArray(capacity: number): Entity[] {\n  // @todo would this be better as a generator?\n  const total = capacity - 1;\n  return Array.from({ length: capacity }, (_, i) => total - i);\n}\n\n/**\n *\n * @param capacity\n * @returns\n */\nfunction entityValidator(capacity: number): (entity: Entity) => entity is Entity {\n  /** @return `true` if the given entity is valid for the given capacity */\n  return function isValidEntity(entity: number): entity is Entity {\n    if (!isUint32(entity) || entity > capacity) return false;\n    return true;\n  };\n}\n\n/** Manages the creation, destruction and recycling of entities */\nexport function createEntityManager(spec: EntityManagerSpec): Readonly<EntityManager> {\n  if (!spec) throw new SyntaxError(\"EntityManager creation requires a spec object.\");\n  const { capacity } = spec;\n\n  const entityArchetypes = createEntityArchetypeArray(capacity);\n  const availableEntities = createAvailableEntityArray(capacity);\n  const isValidEntity = entityValidator(capacity);\n\n  return Object.freeze({\n    /** @returns the next available Entity or `undefined` if no Entity is available */\n    createEntity(): Entity | undefined {\n      return availableEntities.pop();\n    },\n\n    /**\n     * Remove and recycle an Entity\n     * @returns `true` if there was an archetype change\n     */\n    destroyEntity(entity: Entity): boolean {\n      const archetype = entityArchetypes[entity];\n      if (isValidEntity(entity) && archetype !== undefined) {\n        archetype.removeEntity(entity);\n        delete entityArchetypes[entity];\n        availableEntities.push(entity);\n        return true;\n      }\n      return false;\n    },\n\n    /** @returns the Entity's Archetype or undefined if Entity is not alive */\n    getEntityArchetype(entity: Entity): Archetype | undefined {\n      return entityArchetypes[entity];\n    },\n\n    /** @returns the number of available entities */\n    getVacancyCount() {\n      return availableEntities.length;\n    },\n\n    /** @return `true` if the Entity !== undefined */\n    hasEntity(entity: Entity): boolean {\n      return isValidEntity(entity) && entityArchetypes[entity] !== undefined;\n    },\n\n    /** @returns `true` if the Archetype was changed successfully */\n    setEntityArchetype(entity: Entity, archetype: Archetype): boolean {\n      if (isValidEntity(entity)) {\n        entityArchetypes[entity] = archetype;\n        return true;\n      }\n      return false;\n    },\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\nimport { isTypedArray, isUint32 } from \"./utils.js\";\n\nexport interface BitfieldSpec {\n  /** The number of bits/flags required */\n  capacity: number;\n  /** Optional pre-created bitfield array (avoids new array generation) */\n  array?: Uint32Array;\n}\n\nexport interface Bitfield {\n  /** The size of the bitfield */\n  capacity: number;\n  /** The underlying bit array */\n  array: Uint32Array;\n  /**\n   * Set all bits to 0\n   * @returns `true` if the bitfield array was cleared successfully\n   */\n  clear: () => Bitfield;\n  /** @returns a new Bitfield based on this Bitfield */\n  copy: () => Bitfield;\n  /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n  isOn: (bit: number) => boolean;\n  /**\n   * Set a bit 'off' (e.g., falsy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  off: (bit: number) => Bitfield;\n  /**\n   * Set a bit 'on' (e.g., truthy) in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  on: (bit: number) => Bitfield;\n  /**\n   * Toggle a bit in the Bitfield\n   * @returns `true` if the bit was manipulated successfully\n   */\n  toggle: (bit: number) => Bitfield;\n  /** @returns the bitfield array as a string */\n  toString: () => string;\n}\n\n/** Curried bitfield factory function */\nexport function bitfieldCloner(bitfield: Bitfield) {\n  return function () {\n    return bitfield.copy().clear();\n  };\n}\n\n/**\n * Create a new Bitfield\n * @param spec The Bitfield's specification object\n * @param spec.capacity The number of bits/flags\n * @param spec.array Optional pre-created bitfield array (avoids new array generation)\n */\nexport function bitfield(spec: BitfieldSpec): Bitfield {\n  const { capacity, array } = validateSpec(spec);\n  const state = { capacity, array } as Bitfield;\n  const bitToIdx = getBitIndex(capacity);\n  // @todo parallelize?\n  const { clear } = clearer(state);\n  const { copy } = copier(state);\n  const { isOn } = onChecker(state, bitToIdx);\n  const { off } = offer(state, bitToIdx);\n  const { on } = onner(state, bitToIdx);\n  const { toggle } = toggler(state, bitToIdx);\n  const { toString } = stringifier(state);\n  return Object.freeze(Object.assign(state, { clear, copy, isOn, off, on, toggle, toString }));\n}\n\n/** Validates and returns a BitfieldSpec object */\nfunction validateSpec(spec: BitfieldSpec): Required<BitfieldSpec> {\n  if (!spec) throw new SyntaxError(\"Bitfield: a specification object is required.\");\n  const { capacity, array } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"Bitfield: spec.capacity is invalid.\");\n  if (array) {\n    if (!isTypedArray(array)) throw new TypeError(\"Bitfield: spec.array is invalid.\");\n    if (array.length !== (capacity + 31) >>> 5) throw new SyntaxError(\"Bitfield: spec.array is wrong size.\");\n  }\n  return { capacity, array: array || new Uint32Array((capacity + 31) >>> 5) };\n}\n\n/** Check if bit is valid and convert to array index */\nfunction getBitIndex(capacity: number): (bit: number) => number {\n  return function bitToIdx(bit: number): number {\n    if (bit == undefined || isNaN(bit) || bit < 0 || bit > capacity) return -1;\n    return bit >>> 5;\n  };\n}\n\nfunction clearer(state: Bitfield) {\n  const { array } = state;\n  return {\n    /**\n     * Set all bits to 0\n     * @returns `true` if the bitfield array was cleared successfully\n     */\n    clear: function (): Bitfield {\n      array.fill(0);\n      return state;\n    },\n  };\n}\n\nfunction copier(state: Bitfield) {\n  const { capacity, array } = state;\n  return {\n    /** @returns a new Bitfield based on this Bitfield */\n    copy: function (): Bitfield {\n      return bitfield({ capacity, array: array.slice() });\n    },\n  };\n}\n\nfunction offer(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'off' (e.g., falsy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    off: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] &= ~(1 << (bit - i * 32));\n      return state;\n    },\n  };\n}\n\nfunction onner(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Set a bit 'on' (e.g., truthy) in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    on: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] |= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n\nfunction onChecker(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /** @returns `true` if a given bit is 'on' (e.g., truthy) in the Bitfield */\n    isOn: function (bit: number): boolean {\n      const i = bitToIdx(bit);\n      if (i === -1) return false;\n      const cell = array[i];\n      if (!cell) return false;\n      return Boolean(cell & (1 << (bit - i * 32)));\n    },\n  };\n}\n\nfunction stringifier(state: Bitfield) {\n  const { array } = state;\n  return {\n    /** @returns the bitfield array as a string */\n    toString: function (): string {\n      return array.toString();\n    },\n  };\n}\n\nfunction toggler(state: Bitfield, bitToIdx: (bit: number) => number) {\n  const { array } = state;\n  return {\n    /**\n     * Toggle a bit in the Bitfield\n     * @returns `true` if the bit was manipulated successfully\n     */\n    toggle: function (bit: number): Bitfield {\n      const i = bitToIdx(bit);\n      if (i === -1) return state;\n      array[i] ^= 1 << (bit - i * 32);\n      return state;\n    },\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield, Component, ComponentInstance, ComponentRecord, Query, QueryInstance } from \"..\";\nimport { Entity } from \"../entity\";\nimport { createQueryInstance } from \"./instance\";\n\nexport interface QueryManagerSpec {\n  bitfieldFactory: () => Bitfield;\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n}\n\nexport interface QueryManager {\n  queryMap: Map<Query, QueryInstance>;\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  getQueryResult: (query: Query) => [Entity[], ComponentRecord];\n}\n\nexport function createQueryManager(spec: QueryManagerSpec): QueryManager {\n  const { bitfieldFactory, componentMap } = spec;\n\n  const queryMap: Map<Query, QueryInstance> = new Map();\n\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  function getQueryResult(query: Query): [Entity[], ComponentRecord] {\n    let instance = queryMap.get(query);\n    if (!instance) {\n      instance = createQueryInstance({ bitfieldFactory, componentMap, query });\n      queryMap.set(query, instance);\n    }\n    return [instance.getEntities(), instance.getComponents()];\n  }\n\n  return {\n    queryMap,\n    getQueryResult,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Query } from \"./query.js\";\n\nexport interface QueryInstanceSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Readonly<Bitfield>;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  getComponents: () => ComponentRecord;\n  getEntities: () => Entity[];\n  refresh: (archetypes: Archetype[]) => void;\n}\n\nexport interface QueryData {\n  /** A bitfield for the AND match criteria */\n  and?: Readonly<Bitfield>;\n  /** A bitfield for the OR match criteria */\n  or?: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not?: Readonly<Bitfield>;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): Readonly<QueryInstance> {\n  const { componentMap, bitfieldFactory, query } = spec;\n\n  const archetypes: Set<Archetype> = new Set();\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<unknown>> = {};\n\n  const fields: QueryData = {};\n\n  const getComponentInstances = (arr: ComponentInstance<unknown>[], component: Component<unknown>) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr.push(inst);\n    return arr;\n  };\n\n  const mapCompo = <T>(component: ComponentInstance<T>) => {\n    components[component.name] = component;\n  };\n\n  if (query.all.length) {\n    const instances = query.all.reduce(getComponentInstances, []);\n    instances.forEach(mapCompo);\n    fields.and = bitfieldFactory(instances);\n  }\n\n  if (query.any.length) {\n    const instances = query.any.reduce(getComponentInstances, []);\n    instances.forEach(mapCompo);\n    fields.or = bitfieldFactory(instances);\n  }\n\n  if (query.none.length) {\n    const instances = query.none.reduce(getComponentInstances, []);\n    fields.not = bitfieldFactory(instances);\n  }\n\n  // Lock component object\n  Object.freeze(components);\n\n  const getComponents = (): ComponentRecord => components;\n\n  /** @todo cache entities per archetype and add a dirty flag to archetypes - only update entities from dirty archetypes */\n  const getEntities = (): Entity[] => [...archetypes].flatMap((archetype) => [...archetype.entities]);\n\n  const refresher = (archetype: Archetype) => {\n    if (archetype.isCandidate(fields)) {\n      archetypes.add(archetype);\n    }\n  };\n\n  const refresh = (archetypes: Archetype[]) => archetypes.forEach(refresher);\n\n  return Object.freeze(Object.assign(Object.create(query), { getComponents, getEntities, refresh }) as QueryInstance);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { createArchetypeManager } from \"./archetype/manager.js\";\nimport { Component, ComponentRecord } from \"./component/component.js\";\nimport { createComponentManager } from \"./component/manager.js\";\nimport { DEFAULT_MAX_ENTITIES, VERSION } from \"./constants.js\";\nimport { Entity } from \"./entity.js\";\nimport { createEntityManager } from \"./entity.js\";\nimport { bitfield, bitfieldCloner } from \"./bitfield.js\";\nimport { QueryInstance } from \"./query/instance.js\";\nimport { Query } from \"./query/query.js\";\nimport { isUint32 } from \"./utils.js\";\nimport { SchemaProps } from \"./component/schema.js\";\nimport { createQueryManager } from \"./query/manager.js\";\n\nexport interface WorldSpec {\n  /** Components to instantiate in the world  */\n  components: Component<unknown>[];\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n}\n\nexport interface WorldProto {\n  readonly version: string;\n}\n\nexport interface World extends WorldProto {\n  readonly capacity: number;\n  createEntity: () => number | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: number) => Archetype | undefined;\n  getQueryResult: (query: Query) => [Entity[], ComponentRecord];\n  getVacancyCount: () => number;\n  hasEntity: (entity: number) => boolean;\n  addComponentToEntity: <T>(component: Component<T>, entity: number, props?: SchemaProps<T> | undefined) => boolean;\n  entityHasComponent: <T>(component: Component<T>, entity: number) => boolean;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: number) => boolean;\n  refresh: () => void;\n}\n\n/** World.prototype - Miski version data etc. */\nexport const WORLD_PROTO: WorldProto = Object.freeze({\n  version: VERSION,\n});\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec) throw new SyntaxError(\"World creation requires a specification object.\");\n  const { components, capacity = DEFAULT_MAX_ENTITIES } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"World creation: spec.capacity invalid.\");\n  if (!components.length) throw new SyntaxError(\"World creation: spec.components invalid.\");\n  return { components, capacity };\n}\n\nfunction createBitfieldFactory(capacity: number) {\n  const emptyBitfield = bitfield({ capacity });\n  const bitfieldFactory = bitfieldCloner(emptyBitfield);\n  return bitfieldFactory;\n}\n\nexport function createWorld(spec: WorldSpec): Readonly<World> {\n  const { components, capacity } = validateWorldSpec(spec);\n  const bitfieldFactory = createBitfieldFactory(components.length);\n\n  const { createEntity, destroyEntity, getEntityArchetype, getVacancyCount, hasEntity, setEntityArchetype } =\n    createEntityManager({ capacity });\n\n  const { archetypeMap, updateArchetype } = createArchetypeManager({\n    bitfieldFactory,\n    getEntityArchetype,\n    setEntityArchetype,\n  });\n\n  const { componentMap, addComponentToEntity, entityHasComponent, removeComponentFromEntity } = createComponentManager({\n    components,\n    capacity,\n    getEntityArchetype,\n    updateArchetype,\n  });\n\n  const { queryMap, getQueryResult } = createQueryManager({ bitfieldFactory, componentMap });\n\n  function refresh() {\n    const archetypes = [...archetypeMap.values()];\n    const refreshQueries = (instance: QueryInstance) => instance.refresh(archetypes);\n    queryMap.forEach(refreshQueries);\n  }\n  refresh();\n\n  return Object.freeze(\n    Object.assign(Object.create(WORLD_PROTO), {\n      capacity,\n      addComponentToEntity,\n      createEntity,\n      destroyEntity,\n      entityHasComponent,\n      getEntityArchetype,\n      getQueryResult,\n      getVacancyCount,\n      hasEntity,\n      refresh,\n      removeComponentFromEntity,\n    }) as World,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Archetype, createArchetype } from \"./archetype.js\";\n\nexport interface ArchetypeManagerSpec {\n  bitfieldFactory: (components?: ComponentInstance<unknown>[] | undefined) => Bitfield;\n  getEntityArchetype: (entity: number) => Archetype | undefined;\n  setEntityArchetype: (entity: number, archetype: Archetype) => boolean;\n}\n\nexport interface ArchetypeManager {\n  archetypeMap: Map<string, Archetype>;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\nexport function createArchetypeManager(spec: ArchetypeManagerSpec): ArchetypeManager {\n  const { bitfieldFactory, getEntityArchetype, setEntityArchetype } = spec;\n  const archetypeMap: Map<string, Archetype> = new Map();\n\n  return {\n    archetypeMap,\n\n    /**\n     * Update an entity's archetype\n     * @param entity the entity to update\n     * @param component the component to toggle\n     * @returns the entity's new archetype\n     */\n    updateArchetype<T>(entity: Entity, component: ComponentInstance<T>): Archetype {\n      const previousArchetype = getEntityArchetype(entity);\n      let nextArchetype: Archetype | undefined;\n      if (previousArchetype) {\n        previousArchetype.removeEntity(entity);\n        const [id, factory] = previousArchetype.cloneInStep(component);\n        if (archetypeMap.has(id)) {\n          nextArchetype = archetypeMap.get(id)!;\n        } else {\n          nextArchetype = factory();\n          archetypeMap.set(id, nextArchetype);\n        }\n      } else {\n        /** @todo explore archetype graph - https://ajmmertens.medium.com/building-an-ecs-2-archetypes-and-vectorization-fe21690805f9 */\n        nextArchetype = createArchetype({ bitfield: bitfieldFactory([component]) });\n        archetypeMap.set(nextArchetype.id, nextArchetype);\n      }\n      nextArchetype.addEntity(entity);\n      setEntityArchetype(entity, nextArchetype);\n      return nextArchetype;\n    },\n  };\n}\n"],"names":["DEFAULT_MAX_ENTITIES","FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","isUint32","n","isNaN","isValidName","str","Boolean","length","test","includes","isObject","object","Array","isArray","byteSum","total","value","BYTES_PER_ELEMENT","calculateSchemaSize","schema","values","reduce","createComponent","spec","SyntaxError","name","keys","every","isValidSchema","isTag","size","createQuery","all","any","none","component","prototype","hasOwnProperty","call","createSystem","callback","world","args","createArchetype","id","bitfield","toString","validateSpec","data","entities","Set","addEntity","getEntities","removeEntity","state","entity","add","hasEntity","has","delete","entityFns","cloneWithToggle","cloneInStep","cache","Map","get","clone","copy","toggle","set","cached","bitfieldCopy","bitfieldId","cloner","isCandidate","_bitfield","array","query","and","or","not","_not","_and","_or","status","target","i","_n","_a","_o","candidateChecker","result","assign","instantiateComponents","components","partitioner","obj","Error","storage","TypeError","instance","create","configurable","enumerable","writable","createComponentInstance","createComponentManager","capacity","getEntityArchetype","updateArchetype","buffer","totalSize","getComponentSize","ArrayBuffer","Math","ceil","createComponentBuffer","bufferOffset","full","byteLength","componentOffset","entries","res","key","typedArray","initialValue","arrayConstructor","defaultValue","fill","createComponentBufferPartitioner","instances","componentMap","forEach","getPrototypeOf","addComponentToEntity","props","inst","entityHasComponent","arch","isOn","removeComponentFromEntity","createEntityManager","entityArchetypes","createEntityArchetypeArray","availableEntities","from","_","createAvailableEntityArray","isValidEntity","entityValidator","createEntity","pop","destroyEntity","archetype","undefined","push","getVacancyCount","setEntityArchetype","isView","DataView","Uint32Array","bitToIdx","bit","getBitIndex","clear","clearer","slice","copier","cell","onChecker","off","offer","on","onner","toggler","stringifier","createQueryManager","bitfieldFactory","queryMap","getQueryResult","archetypes","fields","getComponentInstances","arr","mapCompo","refresher","getComponents","flatMap","refresh","createQueryInstance","WORLD_PROTO","version","createWorld","validateWorldSpec","bitfieldCloner","createBitfieldFactory","archetypeMap","previousArchetype","nextArchetype","factory","createArchetypeManager"],"mappings":"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"}