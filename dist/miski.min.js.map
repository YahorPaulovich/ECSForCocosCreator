{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/archetype/archetype.ts","../src/utils/sparse-facade.ts","../src/component/manager.ts","../src/component/instance.ts","../src/component/buffer.ts","../src/entity.ts","../src/query/instance.ts","../src/query/manager.ts","../src/world.ts","../src/bitfield.ts","../src/archetype/manager.ts","../src/serialize.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport * as pkg from \"../package.json\";\n\n/** Miski version */\nexport const VERSION: string = pkg.version;\n\n/** Default maximum entities value */\nexport const DEFAULT_MAX_ENTITIES = 1_000_000;\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties\n  \"component\",\n  \"id\",\n  \"isTag\",\n  \"name\",\n  \"schema\",\n  \"size\",\n  // object properties\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** The number 8 - to avoid magic numbers */\nexport const ONE_BYTE = 8;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n\n/** A symbol for use where returning undefined from an array etc. is desirable */\nexport const EMPTY_SYMBOL = Symbol(\"EMPTY\");\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, MAX_UINT32, VALID_NAME_PATTERN } from \"../constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    (typeof str === \"string\" && str.length > 0 && VALID_NAME_PATTERN.test(str) === true) ||\n      !FORBIDDEN_NAMES.includes(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/** An empty function for use in Systems */\nexport function noop(): void {\n  return void 0;\n}\n\n/** @author https://stackoverflow.com/a/67605309 */\nexport type ParametersExceptFirst<F> = F extends (arg0: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n\nexport function createAvailabilityArray(capacity: number): number[] {\n  const total = capacity - 1;\n  return Array.from({ length: capacity }, (_, i) => total - i);\n}\n\nexport function sortAscending(a: number, b: number): number {\n  return b - a;\n}\n\nexport function hasOwnProperty<K extends PropertyKey>(key: K) {\n  return function <U>(obj: U): obj is U & Record<K, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n}\n\nexport function filterEntries<K extends PropertyKey>(keys: K[]) {\n  return function <T extends Record<K, unknown>>(obj: T) {\n    const reducer = (curr: Record<K, T[K]>, key: K): Record<K, T[K]> => {\n      if (hasOwnProperty(key)(obj)) curr[key] = obj[key];\n      return curr;\n    };\n    return keys.reduce(reducer, {} as Record<K, T[K]>);\n  };\n}\n\nexport function getProperty<K extends PropertyKey>(key: K) {\n  return function <U extends Record<K, unknown>>(obj: U): U[K] {\n    return obj[key];\n  };\n}\n\nexport function getOwnProperty<K extends PropertyKey>(key: K) {\n  const hasKey = hasOwnProperty(key);\n  return function <U extends Record<K, unknown>>(obj: U): U[K] | undefined {\n    return hasKey(obj) ? obj[key] : undefined;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isTypedArrayConstructor, isValidName, TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\n/** The interface available to end users */\nexport type SchemaProps<T> = Record<keyof T, number>;\n\n/** Component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n * Values in the array are initialised to 0 by default.\n * To set your own default value: `{ property: [Int8Array, default value] }`.\n */\nexport type Schema<T> = Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Schema type guard */\nexport function isValidSchema<T>(schema: unknown): schema is Schema<T> {\n  const _validateProps = (value: TypedArrayConstructor | [TypedArrayConstructor, number]) => {\n    if (Array.isArray(value)) {\n      const [a, b] = value;\n      if (!isNaN(b) && isTypedArrayConstructor(a)) return true;\n    } else {\n      return isTypedArrayConstructor(value);\n    }\n    return false;\n  };\n  const _validate = ([name, value]: [string, unknown]) => {\n    return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n  };\n  return isObject(schema) && Object.entries(schema).every(_validate);\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/** @returns the size in bytes that a component's storage requires for one entity */\nexport function calculateSchemaSize<T>(schema: Schema<T>): number {\n  return Object.values(schema).reduce(byteSum, 0) as number;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isUint32, isValidName } from \"../utils/utils.js\";\nimport { ComponentInstance } from \"./instance.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\n/** { [component name]: component instance } */\nexport type ComponentRecord = Record<string, ComponentInstance<unknown>>;\n\nexport interface ComponentSpec<T> {\n  /**\n   * The maximum number of entities able to equip this component per world.\n   *\n   * Defaults to all entities.\n   *\n   * __Warning__: use this only where memory consumption is a concern, performance will be worse.\n   */\n  maxEntities?: number;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport interface Component<T> {\n  /** The maximum number of entities able to equip this component per world. */\n  maxEntities: number | null;\n  /** `true` if the component has no schema */\n  isTag: boolean;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  size: number;\n}\n\n/**\n * Define a new component.\n * @param spec the component's specification.\n * @param spec.name the component's string identifier.\n * @param spec.schema the component's optional schema object.\n * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n */\nexport function createComponent<T extends Schema<T>>(spec: ComponentSpec<T>): Component<T> {\n  if (!spec) throw new SyntaxError(\"Component creation requires a specification object.\");\n  const { maxEntities, name, schema } = spec;\n  if (maxEntities && (!isUint32(maxEntities) || maxEntities === 0)) {\n    throw new SyntaxError(\"Component maxEntities must be a Uint32.\");\n  }\n  if (!isValidName(name)) throw new SyntaxError(\"Component name is invalid.\");\n  if (schema && !isValidSchema(schema)) throw new SyntaxError(\"Component schema is invalid.\");\n  return Object.freeze({\n    maxEntities: maxEntities ?? null,\n    isTag: Boolean(schema),\n    name,\n    schema: schema ? Object.freeze({ ...schema }) : null,\n    size: schema ? calculateSchemaSize(schema) : 0,\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Readonly<Component<unknown>[]>;\n}\n\n/** Queries are groupings of archetypes */\nexport interface Query {\n  /** AND - Gather entities as long as they have all these components */\n  all: Readonly<Component<unknown>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any: Readonly<Component<unknown>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  none: Readonly<Component<unknown>[]>;\n}\n\nexport function isValidQuery(object: unknown): object is Query {\n  if (\n    !Array.isArray((object as Query).all) ||\n    !Array.isArray((object as Query).any) ||\n    !Array.isArray((object as Query).none)\n  ) {\n    return false;\n  }\n  const { any, all, none } = object as Query;\n  const _validateComponent = <T>(component: Component<T>) => Object.prototype.hasOwnProperty.call(component, \"name\");\n  return [...all, ...any, ...none].every(_validateComponent);\n}\n\n/**\n * Create a new Query\n * @param spec The Query's specification object\n * @param spec.all AND - Gather entities as long as they have all these components\n * @param spec.any OR - Gather entities as long as they have 0...* of these components\n * @param spec.none NOT - Gather entities as long as they don't have these components\n * @returns a valid Query object\n */\nexport function createQuery(spec: QuerySpec): Readonly<Query> {\n  if (!spec) throw new SyntaxError(\"createQuery: specification object is required.\");\n  const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n  if (![...all, ...any, ...none].every((component) => Object.prototype.hasOwnProperty.call(component, \"name\"))) {\n    throw new SyntaxError(\"Query specification object is invalid.\");\n  }\n  return Object.freeze({\n    all: Object.freeze([...all]),\n    any: Object.freeze([...any]),\n    none: Object.freeze([...none]),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ComponentRecord } from \"./component/component.js\";\nimport { Entity } from \"./entity.js\";\nimport { Query } from \"./query/query.js\";\nimport { ParametersExceptFirst } from \"./utils/utils.js\";\nimport { World } from \"./world.js\";\n\n/** A multi-arity function where the first parameter is always the World object */\nexport type System<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirst<T>,\n> = (components: ComponentRecord, entities: Entity[], ...args: U) => ReturnType<T>;\n\n/**\n * Creates a new curried System function\n * @param callback the System function to be called\n * @returns a curried function (world) => (...args) => result;\n *\n * @example\n * const logQuery = createQuery({ all: [loggable]});\n * const log = (components: Record<string, ComponentInstance>, entities: Entity[], value: string) => console.log(value);\n * const logSystem = createSystem(log, logQuery);\n * const logSystemInstance = logSystem(world);\n * logSystemInstance(\"hello, world!\"); // hello, world!\n */\nexport function createSystem<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirst<T>,\n>(callback: System<T, U>, ...queries: Query[]) {\n  return function (world: World) {\n    // getQueryResult is much faster than getQueryResults for single query systems\n    const [getEntities, components] =\n      queries.length === 1 ? world.getQueryResult(queries[0]!) : world.getQueryResults(...queries);\n    return function (...args: U): ReturnType<T> {\n      return callback(components, getEntities(), ...args);\n    };\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { QueryInstance } from \"../query/instance.js\";\n\ninterface ArchetypeSpec {\n  /** The Bitfield */\n  bitfield: Bitfield;\n  /** Optional */\n  id?: string;\n}\n\nexport interface Archetype {\n  /** The Archetype's Component Bitfield */\n  bitfield: Bitfield;\n  /** */\n  candidateCache: Map<QueryInstance, boolean>;\n  /** */\n  cloneCache: Map<ComponentInstance<unknown>, Archetype>;\n  /** Entities which have entered this archetype since last refresh */\n  entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  exited: Set<Entity>;\n  /** The Archetype's unique ID */\n  id: string;\n  /** `true` if an entity has entered or left since last refresh */\n  isDirty: boolean;\n}\n\n/** Add an entity to an archetype's inhabitants list */\nexport function addEntityToArchetype(entity: Entity): (archetype: Archetype) => Archetype {\n  return function (archetype: Archetype): Archetype {\n    const { entities, entered } = archetype;\n    entities.add(entity);\n    entered.add(entity);\n    archetype.isDirty = true;\n    return archetype;\n  };\n}\n\n/** @returns an array of Entities which inhabit this Archetype */\nexport function getEntitiesFromArchetype(archetype: Archetype): IterableIterator<Entity> {\n  const { entities } = archetype;\n  return entities.values();\n}\n\n/** @returns `true` if the Entity inhabits this Archetype */\nexport function isEntityInArchetype(entity: Entity): (archetype: Archetype) => boolean {\n  return function (archetype: Archetype): boolean {\n    const { entities } = archetype;\n    return entities.has(entity);\n  };\n}\n\n/** Remove an entity from the inhabitants list */\nexport function removeEntityFromArchetype(entity: Entity): (archetype: Archetype) => Archetype {\n  return function (archetype: Archetype): Archetype {\n    const { entities, exited } = archetype;\n    entities.delete(entity);\n    exited.add(entity);\n    archetype.isDirty = true;\n    return archetype;\n  };\n}\n\nfunction validateSpec(spec: ArchetypeSpec): Required<ArchetypeSpec> {\n  if (!spec) throw new SyntaxError(\"Archetype: specification object required.\");\n  const { bitfield, id } = spec;\n  if (!bitfield) throw new SyntaxError(\"Archetype: spec.bitfield is required.\");\n  return { bitfield, id: id || bitfield.toString() };\n}\n\n/** Archetypes are unique groupings of entities by components */\nexport function createArchetype(spec: ArchetypeSpec): Archetype {\n  const { bitfield, id } = validateSpec(spec);\n\n  const candidateCache: Map<QueryInstance, boolean> = new Map();\n  const cloneCache: Map<ComponentInstance<unknown>, Archetype> = new Map();\n  const entered: Set<Entity> = new Set();\n  const entities: Set<Entity> = new Set();\n  const exited: Set<Entity> = new Set();\n\n  return {\n    isDirty: true,\n    bitfield,\n    candidateCache,\n    cloneCache,\n    entered,\n    entities,\n    exited,\n    id,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { EMPTY_SYMBOL } from \"../constants\";\nimport { Entity } from \"../entity\";\nimport { createAvailabilityArray, TypedArray } from \"./utils\";\n\n/**\n * @param dense the typed array to apply the facade to\n * @returns A proxy to the dense array\n */\nexport function sparseFacade<T extends TypedArray>(dense: T): T {\n  /** Map<Entity, Dense Array Index> */\n  const sparse: Map<Entity, number> = new Map();\n\n  /** Array of available indexes in dense */\n  const available = createAvailabilityArray(dense.length);\n\n  /** @returns the entity's value from the dense array or undefined if non-existant */\n  const getter = (entity: Entity) => dense[sparse.get(entity) ?? (EMPTY_SYMBOL as unknown as number)];\n\n  /** @returns `false` if dense array is full, `true` if value set successfully */\n  const set = (entity: Entity, value: T[0]): boolean => {\n    const idx = sparse.get(entity) ?? available.pop();\n    if (idx === undefined) return false;\n    dense[idx] = value;\n    sparse.set(entity, idx);\n    return true;\n  };\n\n  /** @returns `false` if the entity isn't already stored, `true` if deleted successfully */\n  const remove = (entity: Entity): boolean => {\n    const idx = sparse.get(entity);\n    if (idx === undefined) return false;\n    dense[idx] = 0;\n    sparse.delete(entity);\n    available.push(idx);\n    return true;\n  };\n\n  return new Proxy(dense, {\n    get: (_target: T, key: string | symbol) => getter(key as unknown as Entity),\n    set: (_target: T, key: string | symbol, value: T[0]) => set(key as unknown as Entity, value),\n    deleteProperty: (_target: T, key: string | symbol) => remove(key as unknown as Entity),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Entity } from \"../entity.js\";\nimport { ComponentBufferPartitioner, createComponentBuffer, createComponentBufferPartitioner } from \"./buffer.js\";\nimport { Component, ComponentRecord } from \"./component.js\";\nimport { ComponentInstance, createComponentInstance } from \"./instance.js\";\nimport { SchemaProps } from \"./schema.js\";\n\nexport interface ComponentManager {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>) => boolean;\n  entityHasComponent: <T>(entity: Entity, component: Component<T>) => boolean;\n  getBuffer: () => ArrayBuffer;\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n}\n\ninterface ComponentManagerSpec {\n  capacity: number;\n  components: Component<unknown>[];\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  isBitOn: (bit: number, bitfield: Bitfield) => boolean;\n  isValidEntity: (entity: Entity) => entity is Entity;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\n/**\n * Create component instances for the world\n * @param spec The function's specification object\n * @param spec.components An array of components to instantiate\n * @param spec.capacity The associated world's component buffer partitioner function\n * @returns an object whose keys are component names, and whose values are component instances\n */\nfunction instantiateComponents(spec: {\n  components: Component<unknown>[];\n  partitioner: ComponentBufferPartitioner;\n}): ComponentRecord {\n  const { components, partitioner } = spec;\n  const reducer = <T>(obj: ComponentRecord, component: Component<T>, id: number) => {\n    const { name } = component;\n    if (Object.prototype.hasOwnProperty.call(obj, name))\n      throw new Error(`ComponentInstance with name \"${name}\" already exists.`);\n    const storage = partitioner(component);\n    obj[name] = createComponentInstance({ component, id, storage });\n    return obj;\n  };\n  return [...new Set(components)].reduce(reducer, {});\n}\n\nexport function createComponentManager(spec: ComponentManagerSpec): ComponentManager {\n  const { capacity, components, getEntityArchetype, isBitOn, isValidEntity, updateArchetype } = spec;\n\n  const buffer = createComponentBuffer({ capacity, components });\n  const partitioner = createComponentBufferPartitioner({ buffer, capacity });\n\n  /** { component_name: ComponentInstance } */\n  const instances = instantiateComponents({ components, partitioner });\n\n  /** <Component, ComponentInstance> */\n  const componentMap: Map<Component<unknown>, ComponentInstance<unknown>> = new Map();\n  Object.values(instances).forEach(<T>(instance: ComponentInstance<T>) => {\n    componentMap.set(Object.getPrototypeOf(instance) as Component<T>, instance);\n  });\n\n  const getBuffer = (): ArrayBuffer => buffer.slice(0);\n\n  const setBuffer = (source: ArrayBuffer): ArrayBuffer => {\n    if (source.byteLength !== buffer.byteLength) {\n      throw new Error(\"setBuffer - byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(buffer);\n    target.set(view);\n    return buffer.slice(0);\n  };\n\n  const addComponentToEntity = <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T>): boolean => {\n    if (!isValidEntity(entity)) return false;\n    const inst = componentMap.get(component);\n    if (!inst) return false;\n\n    const archetype = getEntityArchetype(entity);\n    if (archetype && isBitOn(inst.id, archetype.bitfield)) return true;\n\n    const { maxEntities } = component;\n    if (maxEntities && inst.count >= maxEntities) return false;\n    inst.count = inst.count + 1;\n\n    updateArchetype(entity, inst);\n\n    // set any default initial properties\n    if (component.schema) {\n      Object.entries(component.schema).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment\n          inst[key][entity] = value[1] ?? 0;\n        }\n      });\n    }\n\n    // set any custom initial properties\n    if (props) {\n      Object.entries(props).forEach(([key, value]) => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        inst[key][entity] = value;\n      });\n    }\n\n    return true;\n  };\n\n  const entityHasComponent = <T>(entity: Entity, component: Component<T>): boolean => {\n    const inst = componentMap.get(component);\n    if (!inst) return false;\n    const arch = getEntityArchetype(entity);\n    if (!arch) return false;\n    const { bitfield } = arch;\n    const { id } = inst;\n    return isBitOn(id, bitfield);\n  };\n\n  const removeComponentFromEntity = <T>(component: Component<T>, entity: Entity): boolean => {\n    if (!isValidEntity(entity)) return false;\n    const inst = componentMap.get(component);\n    if (!inst) return false;\n\n    // make sure facade storage is freed for those that need it\n    const { maxEntities, schema } = component;\n    if (maxEntities && schema) {\n      Object.keys(schema).forEach((key) => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        delete inst[key][entity];\n      });\n    }\n\n    updateArchetype(entity, inst);\n    inst.count = inst.count - 1;\n    return true;\n  };\n\n  return {\n    componentMap,\n\n    addComponentToEntity,\n    entityHasComponent,\n    getBuffer,\n    removeComponentFromEntity,\n    setBuffer,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isUint32, TypedArray } from \"../utils/utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\ninterface ComponentInstanceSpec<T> {\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport interface ComponentInstance<T> extends Component<T> {\n  /** The number of entities which have this component instance */\n  count: number;\n  /** The instance's identifier */\n  id: number;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T> & Record<keyof T, TypedArray>> {\n  const { component, id, storage } = spec;\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n\n  /** number of entities which have this component instance */\n  let entityCount = 0;\n\n  const instance = Object.create(component, {\n    count: {\n      get() {\n        return entityCount;\n      },\n      set(value: number) {\n        entityCount = value;\n      },\n      configurable: false,\n      enumerable: true,\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n  return Object.freeze(Object.assign(instance, storage));\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ONE_BYTE } from \"../constants.js\";\nimport { sparseFacade } from \"../utils/sparse-facade.js\";\nimport { TypedArrayConstructor } from \"../utils/utils.js\";\nimport { Component } from \"./component.js\";\nimport { SchemaStorage } from \"./schema.js\";\n\ninterface ComponentBufferSpec {\n  capacity: number;\n  components: Component<unknown>[];\n}\n\ninterface ComponentBufferPartitionerSpec {\n  buffer: ArrayBuffer;\n  capacity: number;\n}\n\n/** <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray } */\nexport type ComponentBufferPartitioner = <T>(component: Component<T>) => SchemaStorage<T> | undefined;\n\n/** Calculate the total required storage space for all component schemas */\nfunction getComponentSize(capacity: number, components: Component<unknown>[]) {\n  function componentSum<T>(total: number, component: Component<T>): number {\n    const { size = 0 } = component;\n    if (!size || size <= 0) return total;\n    return total + size * capacity;\n  }\n  return components.reduce(componentSum, 0);\n}\n\n/**\n * Create a properly sized ArrayBuffer to hold all a world's component's data.\n * @param spec The component buffer's specification object\n * @param spec.capacity The world's entity capacity\n * @param spec.components The components which the buffer will contain\n */\nexport function createComponentBuffer(spec: ComponentBufferSpec): ArrayBuffer {\n  const { capacity, components } = spec;\n  const totalSize = getComponentSize(capacity, components);\n  return new ArrayBuffer(ONE_BYTE * Math.ceil(totalSize / ONE_BYTE));\n}\n\n/**\n * Creates a function which allows for the creation of component storage partitions.\n * @param spec the partitioner's specification object\n * @param spec.buffer the buffer to partition\n * @param spec.capacity the world's entity capacity\n * @returns <T>(c: Component<T>) => { [schema_key: keyof T]: TypedArray };\n */\nexport function createComponentBufferPartitioner(spec: ComponentBufferPartitionerSpec): ComponentBufferPartitioner {\n  const { buffer, capacity } = spec;\n  let bufferOffset = 0;\n  let full = false;\n\n  return function partitionComponentBuffer<T>(component: Component<T>): SchemaStorage<T> | undefined {\n    if (full === true) throw new Error(\"ArrayBuffer is full!\");\n    const { maxEntities, schema, size = 0 } = component;\n    if (!size || size <= 0) return; // bail early if component is a tag\n    const requiredSize = maxEntities ?? capacity;\n\n    if (bufferOffset + size * requiredSize > buffer.byteLength) {\n      throw new Error(\"Component will not fit inside the buffer!\");\n    }\n\n    let componentOffset = 0;\n    function partition(\n      res: SchemaStorage<T>,\n      [key, value]: [keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]],\n    ) {\n      let typedArray = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) {\n        [typedArray, initialValue] = value;\n      }\n      const dense = new typedArray(buffer, bufferOffset + componentOffset, requiredSize);\n      res[key] = maxEntities === null ? dense : sparseFacade(dense);\n      if (initialValue !== 0) res[key].fill(initialValue as never);\n      componentOffset += typedArray.BYTES_PER_ELEMENT * requiredSize;\n      return res;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const data = Object.entries(schema!) as [keyof T, TypedArrayConstructor][];\n    const storage = data.reduce(partition, {} as SchemaStorage<T>);\n\n    bufferOffset += componentOffset;\n    if (bufferOffset > buffer.byteLength) full = true;\n\n    return storage;\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype, removeEntityFromArchetype } from \"./archetype/archetype.js\";\nimport { createAvailabilityArray, isUint32, Opaque } from \"./utils/utils.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\ninterface EntityManagerSpec {\n  capacity: number;\n}\n\ninterface EntityManager {\n  createEntity: () => Entity | undefined;\n  destroyEntity: (entity: Entity) => boolean;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  getVacancyCount: () => number;\n  hasEntity: (entity: Entity) => boolean;\n  isValidEntity: (entity: Entity) => entity is Entity;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n}\n\nfunction createEntityArchetypeArray(capacity: number) {\n  const entityArchetypes: Archetype[] = [];\n  entityArchetypes.length = capacity; // @note V8 hack, quicker/smaller than new Array(capacity)\n  return entityArchetypes;\n}\n\nfunction entityValidator(capacity: number): (entity: Entity) => entity is Entity {\n  /** @return `true` if the given entity is valid for the given capacity */\n  return function isValidEntity(entity: Entity): entity is Entity {\n    return isUint32(entity) && entity <= capacity;\n  };\n}\n\n/** Manages the creation, destruction and recycling of entities */\nexport function createEntityManager(spec: EntityManagerSpec): EntityManager {\n  const { capacity } = spec;\n\n  const entityArchetypes = createEntityArchetypeArray(capacity);\n  const availableEntities = createAvailabilityArray(capacity);\n  const isValidEntity = entityValidator(capacity);\n\n  return {\n    /** @returns the next available Entity or `undefined` if no Entity is available */\n    createEntity(): Entity | undefined {\n      return availableEntities.pop() as Entity | undefined;\n    },\n\n    /**\n     * Remove and recycle an Entity\n     * @returns `true` if there was an archetype change\n     */\n    destroyEntity(entity: Entity): boolean {\n      if (!isValidEntity(entity)) return false;\n      const archetype = entityArchetypes[entity];\n      if (archetype !== undefined) {\n        removeEntityFromArchetype(entity)(archetype);\n        delete entityArchetypes[entity];\n        availableEntities.push(entity);\n        return true;\n      }\n      return false;\n    },\n\n    /** @returns the Entity's Archetype or undefined if Entity is not alive */\n    getEntityArchetype(entity: Entity): Archetype | undefined {\n      return entityArchetypes[entity];\n    },\n\n    /** @returns the number of available entities */\n    getVacancyCount() {\n      return availableEntities.length;\n    },\n\n    /** @return `true` if the Entity !== undefined */\n    hasEntity(entity: Entity): boolean {\n      return isValidEntity(entity) && entityArchetypes[entity] !== undefined;\n    },\n\n    isValidEntity,\n\n    /** @returns `true` if the Archetype was changed successfully */\n    setEntityArchetype(entity: Entity, archetype: Archetype): boolean {\n      if (isValidEntity(entity)) {\n        entityArchetypes[entity] = archetype;\n        return true;\n      }\n      return false;\n    },\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Component } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { Query } from \"./query.js\";\n\ninterface QueryInstanceSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  createBitfieldFromIds: (components: ComponentInstance<unknown>[]) => Bitfield;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield>;\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  components: Record<string, ComponentInstance<unknown>>;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield>;\n}\n\nfunction flattenEntities(this: Entity[], { entities }: Archetype) {\n  this.push(...entities);\n}\n\n/**\n *\n * @param query\n * @returns\n * @todo cache entities per archetype and add a dirty flag to archetypes - only update entities from dirty archetypes\n */\nexport function getEntitiesFromQuery(query: QueryInstance): Entity[] {\n  const res: Entity[] = [];\n  query.archetypes.forEach(flattenEntities, res);\n  return res;\n}\n\n/**\n *\n * @param query\n * @returns\n */\nexport function getEnteredFromQuery(query: QueryInstance): Entity[] {\n  return [...query.archetypes].flatMap((archetype) => [...archetype.entered]);\n}\n\n/**\n *\n * @param query\n * @returns\n */\nexport function getExitedFromQuery(query: QueryInstance): Entity[] {\n  return [...query.archetypes].flatMap((archetype) => [...archetype.exited]);\n}\n\n/**\n *\n * @param world\n * @param query\n * @returns\n */\nexport function createQueryInstance(spec: QueryInstanceSpec): QueryInstance {\n  const { createBitfieldFromIds, componentMap, query } = spec;\n  const { all, any, none } = query;\n\n  /** */\n  const getComponentInstances = <T>(arr: ComponentInstance<unknown>[], component: Component<T>, idx: number) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr[idx] = inst as ComponentInstance<T>;\n    return arr;\n  };\n\n  /** */\n  const _allInstances = all.reduce(getComponentInstances, new Array(all.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const and = createBitfieldFromIds(_allInstances);\n\n  /** */\n  const _anyInstances = any.reduce(getComponentInstances, new Array(any.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const or = createBitfieldFromIds(_anyInstances);\n\n  /** */\n  const _noneInstances = none.reduce(getComponentInstances, new Array(none.length) as ComponentInstance<unknown>[]);\n\n  /** */\n  const not = createBitfieldFromIds(_noneInstances);\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<unknown>> = [..._allInstances, ..._anyInstances].reduce(\n    (components, component) => {\n      components[component.name] = component;\n      return components;\n    },\n    {} as Record<string, ComponentInstance<unknown>>,\n  );\n  Object.freeze(components);\n\n  /** */\n  const archetypes: Set<Archetype> = new Set();\n\n  return Object.freeze(\n    Object.assign(Object.create(query), {\n      archetypes,\n      and,\n      components,\n      not,\n      or,\n    }) as QueryInstance,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"../archetype/archetype.js\";\nimport { Bitfield } from \"../bitfield.js\";\nimport { Component, ComponentRecord } from \"../component/component.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport {\n  createQueryInstance,\n  QueryInstance,\n  getEnteredFromQuery,\n  getEntitiesFromQuery,\n  getExitedFromQuery,\n} from \"./instance.js\";\nimport { isValidQuery, Query } from \"./query.js\";\n\ninterface QueryManagerSpec {\n  componentMap: Map<Component<unknown>, ComponentInstance<unknown>>;\n  createBitfieldFromIds: (components: ComponentInstance<unknown>[]) => Bitfield;\n  isArchetypeCandidate: (query: QueryInstance) => (archetype: Archetype) => boolean;\n}\n\nexport interface QueryManager {\n  queryMap: Map<Query, QueryInstance>;\n  /** Entities which have entered this query since last refresh */\n  getQueryEntered: (query: Query) => Entity[];\n  /** Entities which have exited this query since last refresh */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  getQueryResult: (query: Query) => [() => Entity[], ComponentRecord];\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  getQueryResults: (...queries: Query[]) => [() => Entity[], ComponentRecord];\n  /** Run Query maintenance */\n  refreshQuery: (archetypes: Archetype[]) => (query: QueryInstance) => QueryInstance;\n}\n\nexport function createQueryManager(spec: QueryManagerSpec): QueryManager {\n  const { createBitfieldFromIds, componentMap, isArchetypeCandidate } = spec;\n\n  /** */\n  const queryMap: Map<Query, QueryInstance> = new Map();\n\n  /** */\n  function refreshQuery(archetypes: Archetype[]): (query: QueryInstance) => QueryInstance {\n    return function (query: QueryInstance): QueryInstance {\n      const isCandidate = isArchetypeCandidate(query);\n      const candidates = archetypes.filter(isCandidate);\n      const add = query.archetypes.add.bind(query.archetypes);\n      [...candidates].forEach(add);\n      return query;\n    };\n  }\n\n  /** */\n  function registerQuery(query: Query): QueryInstance {\n    if (!isValidQuery(query)) throw new Error(\"Object is not a valid query.\");\n    const instance = createQueryInstance({ createBitfieldFromIds, componentMap, query });\n    queryMap.set(query, instance);\n    return instance;\n  }\n\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  function getQueryResult(query: Query): [() => Entity[], ComponentRecord] {\n    const instance = queryMap.get(query) ?? registerQuery(query);\n    return [() => getEntitiesFromQuery(instance), instance.components];\n  }\n\n  /** @returns a tuple of Entities and Components which match the Query criteria */\n  function getQueryResults(...queries: Query[]): [() => Entity[], ComponentRecord] {\n    const components = {};\n\n    const instances = queries.reduce((res, query) => {\n      const instance = queryMap.get(query) ?? registerQuery(query);\n      Object.assign(components, instance.components);\n      res.push(instance);\n      return res;\n    }, [] as QueryInstance[]);\n\n    const getEntities = () => {\n      return instances.flatMap(getEntitiesFromQuery);\n    };\n\n    return [getEntities, Object.freeze(components)];\n  }\n\n  /** Entities which have entered this query since last refresh */\n  function getQueryEntered(query: Query): Entity[] {\n    const instance = queryMap.get(query) ?? registerQuery(query);\n    return getEnteredFromQuery(instance);\n  }\n\n  /** Entities which have exited this query since last refresh */\n  function getQueryExited(query: Query): Entity[] {\n    const instance = queryMap.get(query) ?? registerQuery(query);\n    return getExitedFromQuery(instance);\n  }\n\n  return {\n    queryMap,\n    getQueryEntered,\n    getQueryExited,\n    getQueryResult,\n    getQueryResults,\n    refreshQuery,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype/archetype.js\";\nimport { createArchetypeManager } from \"./archetype/manager.js\";\nimport { bitfieldFactory } from \"./bitfield.js\";\nimport { Component, ComponentRecord } from \"./component/component.js\";\nimport { createComponentManager } from \"./component/manager.js\";\nimport { SchemaProps } from \"./component/schema.js\";\nimport { DEFAULT_MAX_ENTITIES, VERSION } from \"./constants.js\";\nimport { createEntityManager, Entity } from \"./entity.js\";\nimport { createQueryManager } from \"./query/manager.js\";\nimport { Query } from \"./query/query.js\";\nimport { createSerializationManager, MiskiData } from \"./serialize.js\";\nimport { isUint32 } from \"./utils/utils.js\";\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world  */\n  components: Component<unknown>[];\n}\n\ninterface WorldProto {\n  /** The Miski version used to create this World */\n  readonly version: string;\n}\n\nexport interface World extends WorldProto {\n  /** The maximum number of entities allowed in the world */\n  readonly capacity: number;\n  /**\n   * Add a component to an entity.\n   * @param component the component to add.\n   * @param entity the entity to add the component to.\n   * @param props optional initial component values to set for the entity.\n   * @returns `true` if the component was added successfully.\n   */\n  addComponentToEntity: <T>(component: Component<T>, entity: Entity, props?: SchemaProps<T> | undefined) => boolean;\n  /**\n   * Create a new entity for use in the world.\n   * @returns the entity or `undefined` if no entities were available.\n   */\n  createEntity: () => Entity | undefined;\n  /**\n   * Destroy a given entity.\n   * @returns `true` if the entity was successfully destroyed.\n   */\n  destroyEntity: (entity: Entity) => boolean;\n  /**\n   * Check if an entity has a given component.\n   * @param entity the entity to check.\n   * @param component the component to check for.\n   * @returns `true` if the entity has the component.\n   */\n  entityHasComponent: <T>(entity: Entity, component: Component<T>) => boolean;\n  /**\n   * Get a given entity's archetype.\n   * @param entity the entity to expose.\n   * @returns the Archetype object or `undefined` if no archetype found.\n   */\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  /** @returns an array of entities which have entered a query's archetypes since last world.refresh() */\n  getQueryEntered: (query: Query) => Entity[];\n  /** @returns an array of entities which have left a query's archetypes since last world.refresh() */\n  getQueryExited: (query: Query) => Entity[];\n  /** @returns a tuple of entities and components which match the query's criteria */\n  getQueryResult: (query: Query) => [() => Entity[], ComponentRecord];\n  /** @returns a tuple of entities and components which match the query's criteria */\n  getQueryResults: (...queries: Query[]) => [() => Entity[], ComponentRecord];\n  /** @returns the number of available entities in the world. */\n  getVacancyCount: () => number;\n  /** @returns `true` if the entity is valid and !== undefined */\n  hasEntity: (entity: Entity) => boolean;\n  /**\n   * Load data into the world.\n   * @param data the MiskiData object to load\n   * @returns `true` if all the data was successfully loaded into the world.\n   */\n  load: (data: MiskiData) => boolean;\n  /**\n   * Purge various caches throughout the world.\n   * Should not be necessary but useful if memory footprint is creeping.\n   */\n  purgeCaches: () => void;\n  /**\n   * Run various maintenance functions in the world.\n   * Recommended once per frame.\n   */\n  refresh: () => void;\n  /**\n   * Remove a component from an entity.\n   * @param component the component to remove.\n   * @param entity the entity to remove the component from.\n   * @returns `true` if the component was removed successfully.\n   */\n  removeComponentFromEntity: <T>(component: Component<T>, entity: Entity) => boolean;\n  /** Serialize various aspects of the world's data */\n  save: () => Readonly<MiskiData>;\n}\n\n/** World.prototype - Miski version data etc. */\nconst WORLD_PROTO: Readonly<WorldProto> = Object.freeze({\n  version: VERSION,\n});\n\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  if (!spec) throw new SyntaxError(\"World creation requires a specification object.\");\n  const { capacity = DEFAULT_MAX_ENTITIES, components } = spec;\n  if (!isUint32(capacity)) throw new SyntaxError(\"World creation: spec.capacity invalid.\");\n  if (!components.length) throw new SyntaxError(\"World creation: spec.components invalid.\");\n  return { capacity, components };\n}\n\nexport function createWorld(spec: WorldSpec): Readonly<World> {\n  const { capacity, components } = validateWorldSpec(spec);\n\n  const { EMPTY_BITFIELD, createBitfieldFromIds, isBitOn, toggleBit } = bitfieldFactory(components.length);\n\n  const {\n    createEntity,\n    destroyEntity,\n    getEntityArchetype,\n    getVacancyCount,\n    hasEntity,\n    isValidEntity,\n    setEntityArchetype,\n  } = createEntityManager({ capacity });\n\n  const { archetypeMap, isArchetypeCandidate, purgeArchetypeCaches, refreshArchetype, updateArchetype } =\n    createArchetypeManager({\n      EMPTY_BITFIELD,\n      getEntityArchetype,\n      setEntityArchetype,\n      toggleBit,\n    });\n\n  const { componentMap, addComponentToEntity, entityHasComponent, getBuffer, removeComponentFromEntity, setBuffer } =\n    createComponentManager({\n      capacity,\n      components,\n      getEntityArchetype,\n      isBitOn,\n      isValidEntity,\n      updateArchetype,\n    });\n\n  const { queryMap, getQueryEntered, getQueryExited, getQueryResult, getQueryResults, refreshQuery } =\n    createQueryManager({\n      createBitfieldFromIds,\n      componentMap,\n      isArchetypeCandidate,\n    });\n\n  const { load, save } = createSerializationManager({ getBuffer, setBuffer, version: VERSION });\n\n  function purgeCaches() {\n    [...archetypeMap.values()].forEach(purgeArchetypeCaches);\n  }\n  purgeCaches();\n\n  function refresh() {\n    const archetypes = [...archetypeMap.values()];\n    const queryRefresher = refreshQuery(archetypes);\n    queryMap.forEach(queryRefresher);\n    archetypes.forEach(refreshArchetype);\n  }\n  refresh();\n\n  return Object.freeze(\n    Object.assign(Object.create(WORLD_PROTO), {\n      capacity,\n      addComponentToEntity,\n      createEntity,\n      destroyEntity,\n      entityHasComponent,\n      getEntityArchetype,\n      getQueryEntered,\n      getQueryExited,\n      getQueryResult,\n      getQueryResults,\n      getVacancyCount,\n      hasEntity,\n      load,\n      purgeCaches,\n      refresh,\n      removeComponentFromEntity,\n      save,\n    }) as World,\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\nimport { isUint32, Opaque } from \"./utils/utils.js\";\n\n/** A Bitfield is just a Uint32Array */\nexport type Bitfield = Opaque<Uint32Array, \"Bitfield\">;\n\n/** @param capacity The required number of bits in the bitfield */\nexport function bitfieldFactory(capacity: number) {\n  if (!isUint32(capacity)) throw new SyntaxError(\"Bitfield capacity is invalid.\");\n\n  /** The array length to accommodate the required capacity */\n  const size = (capacity + 31) >>> 5;\n\n  /** An empty bitfield for use in cloning etc. */\n  const EMPTY_BITFIELD = new Uint32Array(size) as Bitfield;\n\n  /** Check if bit is valid and convert to array index */\n  const getIndex = (bit: number): number => {\n    if (isNaN(bit) || bit < 0 || bit > capacity) return -1;\n    return bit >>> 5;\n  };\n\n  /**\n   * Create a new bitfield\n   * @param objs array of { id: number } type objects to pre-populate the bitfield with\n   */\n  const createBitfieldFromIds = <T extends { id: number }>(objs: T[]): Bitfield => {\n    return objs.reduce((bitfield, { id }) => {\n      const i = getIndex(id);\n      if (i === -1) throw new SyntaxError(`Bitfield: bit ${id} does not exist in this world.`);\n      bitfield[i] &= ~(1 << (id - i * 32));\n      return bitfield;\n    }, new Uint32Array(size) as Bitfield);\n  };\n\n  /** @returns `true` if a given bit is 'on' (i.e., truthy) in the Bitfield */\n  const isBitOn = (bit: number, bitfield: Bitfield): boolean => {\n    const i = getIndex(bit);\n    if (i === -1) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this world.`);\n    const cell = bitfield[i];\n    if (cell === undefined) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this bitfield.`);\n    return Boolean(cell & (1 << (bit - i * 32)));\n  };\n\n  /**\n   * Toggle a bit in the Bitfield\n   * @return the resulting state of the bit\n   */\n  const toggleBit = (bit: number, bitfield: Bitfield): Bitfield => {\n    const i = getIndex(bit);\n    if (i === -1) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this world.`);\n    if (bitfield[i] === undefined) throw new SyntaxError(`Bitfield: bit ${bit} does not exist in this bitfield.`);\n    bitfield[i] ^= 1 << (bit - i * 32);\n    return bitfield;\n  };\n\n  return {\n    EMPTY_BITFIELD,\n    createBitfieldFromIds,\n    isBitOn,\n    toggleBit,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../bitfield.js\";\nimport { ComponentInstance } from \"../component/instance.js\";\nimport { Entity } from \"../entity.js\";\nimport { QueryInstance } from \"../query/instance.js\";\nimport { addEntityToArchetype, Archetype, createArchetype, removeEntityFromArchetype } from \"./archetype.js\";\n\ninterface ArchetypeManagerSpec {\n  EMPTY_BITFIELD: Bitfield;\n  getEntityArchetype: (entity: Entity) => Archetype | undefined;\n  setEntityArchetype: (entity: Entity, archetype: Archetype) => boolean;\n  toggleBit: (bit: number, bitfield: Bitfield) => Bitfield;\n}\n\ninterface ArchetypeManager {\n  archetypeMap: Map<string, Archetype>;\n  isArchetypeCandidate: (query: QueryInstance) => (archetype: Archetype) => boolean;\n  refreshArchetype: (archetype: Archetype) => Archetype;\n  purgeArchetypeCaches: (archetype: Archetype) => Archetype;\n  updateArchetype: <T>(entity: Entity, component: ComponentInstance<T>) => Archetype;\n}\n\nexport function createArchetypeManager(spec: ArchetypeManagerSpec): ArchetypeManager {\n  const { EMPTY_BITFIELD, getEntityArchetype, setEntityArchetype, toggleBit } = spec;\n\n  /** An empty archetype for use in cloning etc. */\n  const EMPTY_ARCHETYPE = createArchetype({ bitfield: EMPTY_BITFIELD });\n\n  /** */\n  const archetypeMap: Map<string, Archetype> = new Map();\n\n  const cloneArchetypeWithToggle = <T>(\n    archetype: Archetype,\n    component: ComponentInstance<T>,\n  ): [string, () => Archetype] => {\n    const { bitfield, cloneCache } = archetype;\n    const cached = cloneCache.get(component);\n    if (cached) return [cached.id, () => cached];\n    const { id } = component;\n    const bitfieldCopy = bitfield.slice() as Bitfield;\n    toggleBit(id, bitfieldCopy);\n    const bitfieldId = bitfieldCopy.toString();\n    return [\n      bitfieldId,\n      () => {\n        const clone = createArchetype({ bitfield: bitfieldCopy, id: bitfieldId });\n        cloneCache.set(component, clone);\n        return clone;\n      },\n    ];\n  };\n\n  /** @returns `true` if the query criteria match this archetype */\n  const isArchetypeCandidate = (query: QueryInstance): ((archetype: Archetype) => boolean) => {\n    return function (archetype: Archetype): boolean {\n      const { bitfield, candidateCache } = archetype;\n      if (candidateCache.has(query)) return candidateCache.get(query) || false;\n      const { and = EMPTY_BITFIELD, or = EMPTY_BITFIELD, not = EMPTY_BITFIELD } = query;\n      const checkStatus = (target: number, i: number): boolean => {\n        const _and = and[i]!;\n        return (not[i]! & target) === 0 && (_and & target) === _and && (or[i]! & target) <= 0;\n      };\n      const status = bitfield.every(checkStatus);\n      candidateCache.set(query, status);\n      return status;\n    };\n  };\n\n  /** */\n  const refreshArchetype = (archetype: Archetype): Archetype => {\n    const { entered, exited } = archetype;\n    entered.clear();\n    exited.clear();\n    archetype.isDirty = false;\n    return archetype;\n  };\n\n  /** */\n  const purgeArchetypeCaches = (archetype: Archetype): Archetype => {\n    const { candidateCache, cloneCache } = archetype;\n    candidateCache.clear();\n    cloneCache.clear();\n    return archetype;\n  };\n\n  /**\n   * Update an entity's archetype\n   * @param entity the entity to update\n   * @param component the component to toggle\n   * @returns the entity's new archetype\n   */\n  const updateArchetype = <T>(entity: Entity, component: ComponentInstance<T>): Archetype => {\n    const previousArchetype = getEntityArchetype(entity);\n    let nextArchetype: Archetype | undefined;\n    if (previousArchetype) {\n      removeEntityFromArchetype(entity)(previousArchetype);\n      const [id, factory] = cloneArchetypeWithToggle(previousArchetype, component);\n      if (archetypeMap.has(id)) {\n        nextArchetype = archetypeMap.get(id)!;\n      } else {\n        nextArchetype = factory();\n        archetypeMap.set(id, nextArchetype);\n      }\n    } else {\n      const [id, factory] = cloneArchetypeWithToggle(EMPTY_ARCHETYPE, component);\n      if (archetypeMap.has(id)) {\n        nextArchetype = archetypeMap.get(id)!;\n      } else {\n        nextArchetype = factory();\n        archetypeMap.set(id, nextArchetype);\n      }\n    }\n    addEntityToArchetype(entity)(nextArchetype);\n    setEntityArchetype(entity, nextArchetype);\n    return nextArchetype;\n  };\n\n  return {\n    archetypeMap,\n    isArchetypeCandidate,\n    purgeArchetypeCaches,\n    refreshArchetype,\n    updateArchetype,\n  };\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\ninterface SerializationManagerSpec {\n  getBuffer: () => ArrayBuffer;\n  setBuffer: (source: ArrayBuffer) => ArrayBuffer;\n  version: string;\n}\n\nexport interface MiskiData {\n  componentBuffer: ArrayBuffer;\n  version: string;\n}\n\nexport interface SerializationManager {\n  load: (data: MiskiData) => boolean;\n  save: () => MiskiData;\n}\n\nexport function createSerializationManager(spec: SerializationManagerSpec): SerializationManager {\n  const { getBuffer, setBuffer, version } = spec;\n\n  function save(): Readonly<MiskiData> {\n    return Object.freeze({\n      componentBuffer: getBuffer(),\n      version,\n    });\n  }\n\n  function load(data: MiskiData): boolean {\n    const { componentBuffer } = data;\n    /** @todo validate! */\n    if (!version.match(data.version)) {\n      console.warn(`Miski version mismatch: Expected ${version}, found ${data.version}.`);\n    }\n    setBuffer(componentBuffer);\n    return true;\n  }\n\n  return {\n    load,\n    save,\n  };\n}\n"],"names":["DEFAULT_MAX_ENTITIES","FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","EMPTY_SYMBOL","Symbol","isUint32","n","isNaN","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","test","includes","isObject","Array","isArray","createAvailabilityArray","capacity","total","from","_","i","isValidSchema","schema","entries","every","name","value","a","b","_validateProps","byteSum","BYTES_PER_ELEMENT","calculateSchemaSize","values","reduce","createComponent","spec","SyntaxError","maxEntities","isTag","size","createQuery","all","any","none","component","createSystem","callback","queries","world","getEntities","components","getQueryResult","getQueryResults","args","removeEntityFromArchetype","entity","archetype","entities","exited","delete","add","isDirty","createArchetype","bitfield","id","toString","validateSpec","candidateCache","Map","cloneCache","entered","Set","sparseFacade","dense","sparse","available","Proxy","get","_target","key","getter","set","idx","pop","undefined","deleteProperty","push","remove","instantiateComponents","partitioner","obj","Error","storage","TypeError","entityCount","instance","create","count","configurable","enumerable","writable","assign","createComponentInstance","createComponentManager","getEntityArchetype","isBitOn","isValidEntity","updateArchetype","buffer","totalSize","getComponentSize","ArrayBuffer","Math","ceil","createComponentBuffer","bufferOffset","full","requiredSize","byteLength","componentOffset","res","typedArray","initialValue","fill","createComponentBufferPartitioner","instances","componentMap","forEach","getPrototypeOf","addComponentToEntity","props","inst","entityHasComponent","arch","getBuffer","slice","removeComponentFromEntity","keys","setBuffer","source","view","Uint8Array","createEntityManager","entityArchetypes","createEntityArchetypeArray","availableEntities","entityValidator","createEntity","destroyEntity","getVacancyCount","hasEntity","setEntityArchetype","flattenEntities","this","getEntitiesFromQuery","query","archetypes","createQueryManager","createBitfieldFromIds","isArchetypeCandidate","queryMap","registerQuery","isValidQuery","getComponentInstances","arr","_allInstances","and","_anyInstances","or","not","createQueryInstance","getQueryEntered","flatMap","getEnteredFromQuery","getQueryExited","getExitedFromQuery","refreshQuery","isCandidate","candidates","filter","bind","WORLD_PROTO","version","createWorld","validateWorldSpec","EMPTY_BITFIELD","toggleBit","Uint32Array","getIndex","bit","objs","cell","bitfieldFactory","archetypeMap","purgeArchetypeCaches","refreshArchetype","EMPTY_ARCHETYPE","cloneArchetypeWithToggle","cached","bitfieldCopy","bitfieldId","clone","has","status","target","_and","clear","previousArchetype","nextArchetype","factory","addEntityToArchetype","createArchetypeManager","load","save","data","componentBuffer","match","console","warn","createSerializationManager","purgeCaches","refresh","queryRefresher"],"mappings":"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"}