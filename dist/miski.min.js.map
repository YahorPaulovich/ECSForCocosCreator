{"version":3,"file":"miski.min.js","sources":["../src/constants.ts","../src/utils/utils.ts","../src/component/schema.ts","../src/component/component.ts","../src/query/query.ts","../src/system.ts","../src/utils/bitfield.ts","../src/archetype/archetype.ts","../src/archetype/manager.ts","../src/component/proxy.ts","../src/component/instance.ts","../src/utils/bitpool.ts","../src/utils/sparse-facade.ts","../src/component/buffer.ts","../src/component/manager.ts","../src/query/manager.ts","../src/query/instance.ts","../src/world.ts"],"sourcesContent":["/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/** Miski version */\nexport const VERSION = \"__VERSION__\"; // __VERSION__ is replaced by rollup\n\n/** Maximum 32-bit integer (2^32 - 1) */\nexport const MAX_UINT32 = 4_294_967_295;\n\n/** An array of strings that cannot be used for component or schema property names */\nexport const FORBIDDEN_NAMES = Object.freeze([\n  // component properties:\n  \"changed\",\n  \"component\",\n  \"count\",\n  \"eid\",\n  \"entity\",\n  \"id\",\n  \"isTag\",\n  \"maxEntities\",\n  \"name\",\n  \"owners\",\n  \"proxy\",\n  \"schema\",\n  \"size\",\n  // object properties:\n  \"constructor\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"prototype\",\n  \"toLocaleString\",\n  \"toString\",\n  \"valueOf\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupGetter__\",\n  \"__proto__\",\n]);\n\n/** Valid string name characters */\nexport const VALID_NAME_PATTERN = /^(?![0-9])[a-zA-Z0-9$_]+$/;\n\n/** A frozen empty array to avoid multiple object creation at certain points */\nexport const EMPTY_ARRAY = Object.freeze([]);\n\n/** Symbol for use as a key for the `changed` flag getter and setter */\nexport const $_CHANGED = Symbol(\"changed\");\n\n/** Symbol for use as a key for the `owners` flag getter and setter */\nexport const $_OWNERS = Symbol(\"owners\");\n\n/** Lookup table for powers of 2 */\nexport const LOG_2: Record<number, number> = Object.freeze({\n  1: 0,\n  2: 1,\n  4: 2,\n  8: 3,\n  16: 4,\n  32: 5,\n  64: 6,\n  128: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11,\n  4096: 12,\n  8192: 13,\n  16384: 14,\n  32768: 15,\n  65536: 16,\n  131072: 17,\n  262144: 18,\n  524288: 19,\n  1048576: 20,\n  2097152: 21,\n  4194304: 22,\n  8388608: 23,\n  16777216: 24,\n  33554432: 25,\n  67108864: 26,\n  134217728: 27,\n  268435456: 28,\n  536870912: 29,\n  1073741824: 30,\n  2147483648: 31,\n});\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { FORBIDDEN_NAMES, LOG_2, MAX_UINT32, VALID_NAME_PATTERN } from \"../constants.js\";\n\n/** @returns `true` if n is a number, >= 0, <= 2^32 - 1 */\nexport function isUint32(n: number): n is number {\n  return !isNaN(n) && n >= 0 && n <= MAX_UINT32;\n}\n\n/** @returns true if `n` is a Uint32 > 0 */\nexport function isPositiveInt(n: number) {\n  return isUint32(n) && n > 0;\n}\n\n/** All the various kinds of typed arrays */\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/** All the various kinds of typed array constructors */\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\n/** Test if an object is a typed array and not a dataview */\nexport function isTypedArray(object: unknown): object is TypedArray {\n  return Boolean(ArrayBuffer.isView(object) && !(object instanceof DataView));\n}\n\n/** Test if an object is a typed array constructor (e.g., `Uint8Array`) */\nexport function isTypedArrayConstructor(object: unknown): object is TypedArrayConstructor {\n  return Boolean(typeof object === \"function\" && Object.prototype.hasOwnProperty.call(object, \"BYTES_PER_ELEMENT\"));\n}\n\n/** @returns `true` if the given string is an valid name / label */\nexport function isValidName(str: string): boolean {\n  return Boolean(\n    typeof str === \"string\" &&\n      str.length > 0 &&\n      FORBIDDEN_NAMES.includes(str) === false &&\n      VALID_NAME_PATTERN.test(str),\n  );\n}\n\n/** Test if an object is a valid Record  */\nexport function isObject(object: unknown): object is Record<string, unknown> {\n  return Boolean(typeof object === \"object\" && !Array.isArray(object));\n}\n\n/**\n * The parameters of a function omitting the first two parameters\n * @author https://stackoverflow.com/a/67605309\n */\nexport type ParametersExceptFirstTwo<F> = F extends (arg0: any, arg1: any, ...rest: infer R) => any ? R : never;\n\n/**\n * Opaque typing allows for nominal types\n * @example\n * type Entity = number;\n * const a: Entity = 1; // a = number;\n * type Entity = Opaque<number, \"Entity\">;\n * const b: Entity = 1 // b = Entity;\n */\nexport type Opaque<T, K> = T & { _TYPE: K };\n\n/** Creates a function that will round a number up to a given multiple */\nexport function roundUpToMultipleOf(f: number): (n: number) => number {\n  return (n: number) => Math.ceil(n / f) * f;\n}\n\n/** @returns the input rounded up to the closest multiple of 4 */\nexport const multipleOf4 = roundUpToMultipleOf(4);\n\n/** @returns the input rounded up to the closest multiple of 8 */\nexport const multipleOf8 = roundUpToMultipleOf(8);\n\n/** @returns the intersection of two bits */\nexport function intersectBits(a = 0, b = 0): number {\n  return a & b;\n}\n\n/** @returns the index of the least significant bit or -1 if error */\nexport function getLsbIndex(value: number): number {\n  if (value === 2147483648) return 31;\n  return LOG_2[value & -value] ?? -1;\n}\n\n/** Round a number up to the closest power of 2 */\nexport function roundUpToPwr2(n: number): number {\n  let p = 2;\n  while ((n >>= 1)) p <<= 1;\n  return p;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isObject, isTypedArrayConstructor, isValidName } from \"../utils/utils.js\";\nimport type { TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\n/** Individual entity's component properties */\nexport type SchemaProps<T> = Record<keyof T, number | bigint | undefined>;\n\n/** Internal component data storage */\nexport type SchemaStorage<T> = Record<keyof T, TypedArray>;\n\n/**\n * Schemas are component storage definitions:\n *\n * Schemas use TypedArray objects and so can only store a single number per property per entity.\n *\n * For example, `{ property: Int8Array }`;\n *\n * Values in TypedArrays are initialised to 0 by default.\n *\n * To set an initial value: `{ property: [Int8Array, defaultValue] }`.\n *\n * Set to `null` to define a tag component.\n */\nexport type Schema<T> = null | Record<keyof T, TypedArrayConstructor | [TypedArrayConstructor, number]>;\n\n/** Validates the properties of a schema entry */\nfunction _validateProps(value: TypedArrayConstructor | [TypedArrayConstructor, number]): boolean {\n  if (Array.isArray(value)) {\n    // if this is an array, the user wants to set an initial value\n    const [TAC, n] = value;\n    return !isNaN(n) && isTypedArrayConstructor(TAC);\n  }\n  return isTypedArrayConstructor(value);\n}\n\n/** Validates the names and values of a schema's entries */\nfunction _validateSchemaEntry([name, value]: [string, unknown]): boolean {\n  return isValidName(name) && _validateProps(value as TypedArrayConstructor | [TypedArrayConstructor, number]);\n}\n\n/** Schema type guard */\nexport function isValidSchema<T extends Schema<T>>(schema: unknown): schema is Schema<T> {\n  try {\n    if (schema === undefined) return false;\n    if (schema === null) return true;\n    if (!isObject(schema)) return false;\n    const entries = Object.entries(schema);\n    if (!entries.length) return false;\n    return entries.every(_validateSchemaEntry);\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Utility function to add a typed array's bytes per element to a total\n * @see calculateSchemaSize\n */\nfunction byteSum(total: unknown, value: unknown): number {\n  const size = Array.isArray(value)\n    ? (value[0] as TypedArray).BYTES_PER_ELEMENT\n    : (value as TypedArray).BYTES_PER_ELEMENT;\n  return (total as number) + size;\n}\n\n/**\n * @returns the size in bytes that a component's storage requires for one entity\n *          or NaN if the object is invalid;\n */\nexport function calculateSchemaSize<T extends Schema<T>>(schema: Schema<T>): number {\n  try {\n    if (!isValidSchema(schema)) return Number.NaN;\n    if (schema === null) return 0;\n    /** @todo should this be to multipleOf4? */\n    return Object.values(schema).reduce(byteSum, 0) as number;\n  } catch (_) {\n    return Number.NaN;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { isPositiveInt, isValidName } from \"../utils/utils.js\";\nimport { calculateSchemaSize, isValidSchema, Schema } from \"./schema.js\";\n\nexport interface ComponentSpec<T> {\n  /**\n   * The maximum number of entities able to equip this component per world.\n   *\n   * __Warning__: use this only where memory consumption is a concern, performance will be worse.\n   */\n  maxEntities?: number;\n  /** The component's label */\n  name: string;\n  /** The component's property definitions. Omit to define a tag component. */\n  schema?: Schema<T>;\n}\n\nexport class Component<T extends Schema<T>> {\n  /** `true` if the component has no schema */\n  readonly isTag: boolean;\n  /** The maximum number of entities able to equip this component per world. */\n  readonly maxEntities: number | null;\n  /** The component's label */\n  readonly name: string;\n  /** The component's property definitions or `null` if component is a tag */\n  readonly schema: Readonly<Schema<T>> | null;\n  /** The storage requirements of the schema in bytes for a single entity */\n  readonly size: number;\n\n  /**\n   * Define a new component.\n   * @param spec the component's specification.\n   * @param spec.name the component's string identifier.\n   * @param spec.schema the component's optional schema object.\n   * @returns A valid Component object - a reusable definitions for the creation of ComponentInstances\n   * @throws If the spec is invalid\n   */\n  constructor(spec: ComponentSpec<T>) {\n    if (!spec) throw new SyntaxError(\"A specification object is required.\");\n    const { maxEntities = null, name, schema = null } = spec;\n    if (maxEntities && !isPositiveInt(maxEntities)) throw new SyntaxError(\"spec.maxEntities must be a Uint32 > 0.\");\n    if (!isValidName(name)) throw new SyntaxError(\"spec.name is invalid.\");\n    if (!isValidSchema(schema)) throw new SyntaxError(\"spec.schema is invalid.\");\n    this.isTag = !schema;\n    this.maxEntities = maxEntities ?? null;\n    this.name = name;\n    this.schema = schema ? Object.freeze({ ...schema }) : null;\n    this.size = schema ? calculateSchemaSize(schema) : 0;\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Component } from \"../component/component.js\";\nimport { EMPTY_ARRAY } from \"../constants.js\";\nimport type { Schema } from \"../component/schema.js\";\n\nexport interface QuerySpec {\n  /** AND - Gather entities as long as they have all these components */\n  all?: Component<any>[];\n  /** OR - Gather entities as long as they have 0...* of these components */\n  any?: Component<any>[];\n  /** NOT - Gather entities as long as they don't have these components */\n  none?: Component<any>[];\n}\n\nfunction _validateQueryArrays<T extends Schema<T>>(component: Component<T>) {\n  return component instanceof Component;\n}\n\nexport class Query {\n  /** AND - Gather entities as long as they have all these components */\n  readonly all: Readonly<Component<any>[]>;\n  /** OR - Gather entities as long as they have 0...* of these components */\n  readonly any: Readonly<Component<any>[]>;\n  /** NOT - Gather entities as long as they don't have these components */\n  readonly none: Readonly<Component<any>[]>;\n\n  /**\n   * Create a new Query\n   *\n   * Queries are groupings of archetypes\n   *\n   * @param spec The Query's specification object\n   * @param spec.all AND - Gather entities as long as they have all these components\n   * @param spec.any OR - Gather entities as long as they have 0...* of these components\n   * @param spec.none NOT - Gather entities as long as they don't have these components\n   * @throws If the spec is invalid\n   */\n  constructor(spec: QuerySpec) {\n    if (!spec) throw new SyntaxError(\"Query specification object is required.\");\n    const { all = EMPTY_ARRAY, any = EMPTY_ARRAY, none = EMPTY_ARRAY } = spec;\n    if (![...all, ...any, ...none].every(_validateQueryArrays)) {\n      throw new SyntaxError(\"Query specification object is invalid.\");\n    }\n    this.all = Object.freeze([...new Set(all)]);\n    this.any = Object.freeze([...new Set(any)]);\n    this.none = Object.freeze([...new Set(none)]);\n    Object.freeze(this);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Query } from \"./query/query.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { ParametersExceptFirstTwo } from \"./utils/utils.js\";\nimport type { Entity, World } from \"./world.js\";\n\n/**\n * A multi-arity function where the first two parameters\n * are the components and entities available to\n * the system respectively.\n */\nexport type SystemCallback<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> = (components: ComponentRecord, entities: Entity[], ...args: U) => ReturnType<T>;\n\nexport interface SystemSpec<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n}\n\nexport class System<\n  T extends (components: ComponentRecord, entities: Entity[], ...args: unknown[]) => ReturnType<T>,\n  U extends ParametersExceptFirstTwo<T>,\n> {\n  /** The core function of the system. Called when this.exec is called. */\n  system: SystemCallback<T, U>;\n  /** The query which will provide the components and entities to the system. */\n  query: Query;\n\n  /**\n   * Creates a new system.\n   *\n   * Systems are the behaviours which affect components.\n   *\n   * @param spec the system's specification object\n   */\n  constructor(spec: SystemSpec<T, U>) {\n    const { system, query } = spec;\n    this.system = system;\n    this.query = query;\n  }\n\n  /**\n   * Initialize the system for a given world\n   * @param world the world to execute the system in\n   * @returns an initialized system function\n   */\n  init(world: World): (...args: U) => ReturnType<T> {\n    const components = world.getQueryComponents(this.query);\n    const entities: Entity[] = [];\n    /**\n     * @param args arguments to pass to the system's callback function\n     * @returns the result of the system's callback function\n     */\n    return (...args: U) => this.system(components, world.getQueryEntities(this.query, entities), ...args);\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\n/**\n * @note\n * `bit >>> 5` is used in place of `Math.floor(bit / 32)`.\n * `(bit - (bit >>> 5) * 32)` is used in place of `bit % 32`.\n */\n\n/** */\nexport class Bitfield extends Uint32Array {\n  /** @returns the number of set bits in a given value */\n  static getSetBitCount(value: number): number {\n    const a = value - ((value >> 1) & 0x55555555);\n    const b = (a & 0x33333333) + ((a >> 2) & 0x33333333);\n    return (((b + (b >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n  }\n\n  /** @returns the number of set bits in a given bitfield */\n  static getSetBitCountInBitfield(bitfield: Bitfield): number {\n    return bitfield.reduce((res, val) => {\n      if (val === 0) return res;\n      return res + Bitfield.getSetBitCount(val);\n    }, 0);\n  }\n\n  /**\n   * Create a new Bitfield from an array of objects\n   * @param size the number of bits in the bitfield\n   * @param key the key of the property to use for the bitfield's indexes\n   * @param objs an array of objects which have the key as an index to a number\n   *\n   * @example\n   *  // Creating 32 bit bitfield from <T extends { id: number }>:\n   *  Bitfield.fromObjects(32, \"id\", [{ id: 0, ... }, ...]);\n   */\n  static fromObjects<T>(size: number, key: keyof T, objs: T[]): Bitfield {\n    return objs.reduce((bitfield, obj) => {\n      bitfield.toggle(obj[key] as number);\n      return bitfield;\n    }, new Bitfield(size));\n  }\n\n  /** @returns the index of a bit in a bitfield */\n  static indexOf(bit: number): number {\n    if (isNaN(bit) || bit < 0) return -1;\n    return bit >>> 5;\n  }\n\n  /**\n   * Creates a new Bitfield\n   * @param size the number of bits in the array\n   */\n  constructor(size: number) {\n    super(Math.ceil(size / 32));\n  }\n\n  /** @returns The amount of bits in the array */\n  get size(): number {\n    return this.length << 5;\n  }\n\n  /** @returns a new Bitfield with identical properties to this Bitfield */\n  clone(): Bitfield {\n    const result = new Bitfield(this.size);\n    result.set(this);\n    return result;\n  }\n\n  /** @returns a new Bitfield based on this one with toggled bits */\n  cloneWithToggle<T>(key: keyof T, sources: T[]): Bitfield {\n    const bitfield = this.clone();\n    // eslint-disable-next-line array-callback-return\n    sources.forEach((source) => bitfield.toggle(source[key] as number));\n    return bitfield;\n  }\n\n  /** @returns the index and position of a bit in the bitfield */\n  getPosition(bit: number): { index: number; position: number } {\n    const index = Bitfield.indexOf(bit);\n    return {\n      index,\n      position: bit - (index << 5),\n    };\n  }\n\n  /** @returns `true` if a given bit is set in the Bitfield or null on error */\n  isSet(bit: number): boolean | null {\n    const i = Bitfield.indexOf(bit);\n    if (i === -1 || this[i] === undefined) return null;\n    return !!(this[i]! & (1 << (bit - i * 32)));\n  }\n\n  /**\n   * Toggle a bit in the Bitfield\n   * @return the resulting state of the bit or null if error\n   */\n  toggle(bit: number): boolean | null {\n    const i = Bitfield.indexOf(bit);\n    if (i === -1) return null;\n    this[i] ^= 1 << (bit - i * 32);\n    return !!(this[i]! & (1 << (bit - i * 32)));\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\n\nexport class Archetype {\n  /** The Archetype's Component Bitfield */\n  readonly bitfield: Bitfield;\n  /** QueryInstances and their candidacy status*/\n  readonly candidateCache: Map<QueryInstance, boolean>;\n  /** The components associated with this archetype */\n  readonly components: ComponentInstance<any>[];\n  /** Entities which have entered this archetype since last refresh */\n  readonly entered: Set<Entity>;\n  /** Set of Entities which inhabit this Archetype */\n  readonly entities: Set<Entity>;\n  /** Entities which have exited this archetype since last refresh */\n  readonly exited: Set<Entity>;\n  /** `true` if the object is in a dirty state */\n  isDirty: boolean;\n\n  constructor(size: number, components: ComponentInstance<any>[], bitfield?: Bitfield) {\n    this.bitfield = bitfield ?? Bitfield.fromObjects(size, \"id\", components);\n    this.candidateCache = new Map();\n    this.components = components;\n    this.entered = new Set();\n    this.entities = new Set();\n    this.exited = new Set();\n    this.isDirty = true;\n  }\n\n  /** The Archetype's unique identifier */\n  get id(): string {\n    return this.bitfield.toString();\n  }\n\n  /** `true` if this Archetype has no entities associated with it */\n  get isEmpty(): boolean {\n    return this.entities.size === 0;\n  }\n\n  /** Add an Entity to the Archetype */\n  addEntity(entity: Entity): Archetype {\n    this.entities.add(entity);\n    this.entered.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Create a new Archetype from this Archetype */\n  clone(): Archetype {\n    return new Archetype(this.bitfield.length, this.components, this.bitfield.clone());\n  }\n\n  /**\n   * Test this Archetype matches a given QueryInstance\n   * @param query The QueryInstance to test\n   * @returns `true` if the QueryInstance is a match\n   */\n  isCandidate(query: QueryInstance): boolean {\n    const cached = this.candidateCache.get(query);\n    if (cached !== undefined) return cached;\n    const status = this.bitfield.every(query.checkCandidacy);\n    this.candidateCache.set(query, status);\n    return status;\n  }\n\n  /** Clear entered/exited entities and set `isDirty` to `false` */\n  refresh(): Archetype {\n    this.entered.clear();\n    this.exited.clear();\n    this.isDirty = false;\n    return this;\n  }\n\n  /** Remove an Entity from the Archetype */\n  removeEntity(entity: Entity): Archetype {\n    this.entities.delete(entity);\n    this.exited.add(entity);\n    this.isDirty = true;\n    return this;\n  }\n\n  /** Serialize the Archetype to a string */\n  toString(): string {\n    return `\n{\n  bitfield: ${this.bitfield.toString()},\n  components: ${this.components.map((inst) => inst.id).join(\",\")},\n  entities: ${[...this.entities.values()].join(\",\")},\n},\n    `;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Archetype } from \"./archetype.js\";\nimport type { Query } from \"../query/query.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"../query/instance.js\";\n\nexport interface ArchetypeManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nexport class ArchetypeManager {\n  /** Map<Archetype.id, Archetype> */\n  archetypeMap: Map<string, Archetype> = new Map();\n  /** Archetype's indexed by Entity */\n  entityArchetypes: Archetype[];\n  /** The root/empty archetype */\n  rootArchetype: Archetype;\n\n  constructor(spec: ArchetypeManagerSpec) {\n    const { capacity, components } = spec;\n    this.rootArchetype = new Archetype(components.length, []);\n    this.archetypeMap = new Map();\n    this.archetypeMap.set(this.rootArchetype.id, this.rootArchetype);\n    this.entityArchetypes = Array.from({ length: capacity }, (_, i) => this.rootArchetype.addEntity(i as Entity));\n  }\n\n  /** @returns an entity's archetype or undefined if not found */\n  getArchetype(entity: Entity): Archetype | undefined {\n    return this.entityArchetypes[entity];\n  }\n\n  /** Returns an entity to the root archetype */\n  resetArchetype(entity: Entity): ArchetypeManager {\n    if (this.entityArchetypes[entity] === this.rootArchetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = this.rootArchetype.addEntity(entity);\n    return this;\n  }\n\n  /** Performs various archetype maintenance */\n  refreshArchetypes(queries: Map<Query, QueryInstance>): ArchetypeManager {\n    /** @todo double loop isn't ideal */\n    this.archetypeMap.forEach((archetype) => {\n      if (!archetype.isEmpty) {\n        queries.forEach((query) => {\n          if (!query.archetypes.has(archetype) && archetype.isCandidate(query)) {\n            query.isDirty = true;\n            query.archetypes.add(archetype);\n          }\n        });\n      }\n      archetype.refresh();\n    });\n    return this;\n  }\n\n  /** Replace an entity's archetype */\n  setArchetype(entity: Entity, archetype: Archetype): ArchetypeManager {\n    if (!this.archetypeMap.has(archetype.id)) throw new Error(\"Invalid archetype.\");\n    if (this.entityArchetypes[entity] === archetype) return this;\n    this.entityArchetypes[entity]?.removeEntity(entity);\n    this.entityArchetypes[entity] = archetype.addEntity(entity);\n    return this;\n  }\n\n  /**\n   * Update an Entity's archetype\n   * @param entity the entity to update\n   * @param components the components to toggle\n   * @returns The entity's resulting archetype\n   */\n  updateArchetype(entity: Entity, components: ComponentInstance<any>[]): Archetype {\n    /** @todo replace this with a graph */\n    const previousArchetype = this.entityArchetypes[entity]!;\n    previousArchetype.removeEntity(entity);\n    const bitfield = previousArchetype.bitfield.cloneWithToggle(\"id\", components);\n    const id = bitfield.toString();\n    let nextArchetype = this.archetypeMap.get(id);\n    if (!nextArchetype) {\n      nextArchetype = new Archetype(this.rootArchetype.bitfield.size, components, bitfield);\n      this.archetypeMap.set(id, nextArchetype);\n    }\n    this.entityArchetypes[entity] = nextArchetype.addEntity(entity);\n    return nextArchetype;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport type { Entity } from \"../world.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\n/**\n * A storage proxy is a convenience method for setting entity's component\n * properties in a way which is type safe and flips the `changed` property\n * on the entity at the expense of performance vs. direct array access.\n */\nexport type StorageProxy<T extends Schema<T>> = Record<keyof T, number> & {\n  /** @returns the entity the proxy is currently pointed at */\n  getEntity(): Entity;\n  /**\n   * Change the proxy's cursor to a given entity\n   * @param entity The entity to change\n   * @throws If the entity is not a number\n   */\n  setEntity(entity: Entity): Entity;\n};\n\n/**\n * @internal\n * Create a new storage proxy object for a component instance\n * @param storage The component's storage object\n * @param changed The component's changed entity set\n * @returns A new storage proxy object\n * @throws if no storage or changed set are provided\n */\nexport function storageProxy<T extends Schema<T>>(storage: SchemaStorage<T>, changed: Set<Entity>): StorageProxy<T> {\n  if (!storage) throw new SyntaxError(\"Proxy can only be used on components, not tags.\");\n  if (!changed) throw new SyntaxError(\"Proxy requires a changed set.\");\n\n  /** The currently selected entity */\n  let entityId: Entity = 0 as Entity;\n\n  return Object.freeze(\n    // Create a getter and setter for each storage property\n    Object.keys(storage).reduce(\n      (res, key) => {\n        Object.defineProperty(res, key, {\n          get() {\n            return storage[key as keyof T][entityId];\n          },\n          set(value: number) {\n            if (storage[key as keyof T][entityId] !== value) {\n              storage[key as keyof T][entityId] = value;\n              changed.add(entityId);\n            }\n          },\n        });\n        return res;\n      },\n      // allow the user to control which entity the proxy should modify\n      {\n        getEntity(): Entity {\n          return entityId;\n        },\n        setEntity(entity: Entity): Entity {\n          if (isNaN(entity)) throw new TypeError(\"Expected entity to be a number.\");\n          entityId = entity;\n          return entityId;\n        },\n      } as StorageProxy<T>,\n    ),\n  );\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_CHANGED, $_OWNERS } from \"../constants.js\";\nimport { isObject, isPositiveInt, isUint32 } from \"../utils/utils.js\";\nimport { storageProxy } from \"./proxy.js\";\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport type { TypedArray } from \"../utils/utils.js\";\nimport type { StorageProxy } from \"./proxy.js\";\nimport type { Entity } from \"../world.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\n\ninterface ComponentInstanceSpec<T extends Schema<T>> {\n  /** The world's entity capacity */\n  capacity: number;\n  /** The component to instantiate */\n  component: Component<T>;\n  /** The component instance's identifier */\n  id: number;\n  /** The component's TypedArray storage object */\n  storage?: SchemaStorage<T> | undefined;\n}\n\nexport type ComponentInstance<T extends Schema<T>> = Component<T> &\n  Record<keyof T, TypedArray> & {\n    /** @internal */\n    [$_CHANGED]: Set<Entity>;\n    /** @internal */\n    [$_OWNERS]: Bitfield;\n    /** Entities who's properties have been changed via this.proxy since last refresh */\n    changed: IterableIterator<Entity>;\n    /** The number of entities which have this component instance */\n    count: number;\n    /** The instance's identifier */\n    id: number;\n    /** */\n    proxy: StorageProxy<T>;\n  };\n\nexport function refreshComponentInstance<T extends Schema<T>>(instance: ComponentInstance<T>): ComponentInstance<T> {\n  instance[$_CHANGED].clear();\n  return instance;\n}\n\n/**\n * Create a new ComponentInstance.\n * A ComponentInstance is a Component tied to a World with storage\n * @param spec The ComponentInstance's specification object\n * @param spec.component The component to instantiate\n * @param spec.id The component instance's identifier\n * @param spec.storage The component's TypedArray storage object\n */\nexport function createComponentInstance<T extends Schema<T>>(\n  spec: ComponentInstanceSpec<T>,\n): Readonly<ComponentInstance<T>> {\n  const { capacity, component, id, storage } = spec;\n  if (!isPositiveInt(capacity)) throw new SyntaxError(\"Capacity must be integer > 0.\");\n  if (!component) throw new Error(\"Component instantiation requires as component!\");\n  if (!isUint32(id)) throw new SyntaxError(\"Component ID is invalid.\");\n  if (storage && !isObject(storage)) throw new TypeError(\"Component storage is malformed.\");\n\n  const changed: Set<Entity> = new Set();\n  const owners: Bitfield = new Bitfield(capacity);\n\n  const instance = Object.create(component, {\n    [$_CHANGED]: {\n      value: changed,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    [$_OWNERS]: {\n      value: owners,\n      configurable: false,\n      enumerable: false,\n      writable: false,\n    },\n    changed: {\n      get() {\n        return changed.values();\n      },\n    },\n    count: {\n      get() {\n        return Bitfield.getSetBitCountInBitfield(owners);\n      },\n    },\n    id: {\n      value: id,\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    },\n  }) as ComponentInstance<T>;\n\n  if (storage) {\n    // create instance.proxy\n    Object.defineProperty(instance, \"proxy\", {\n      value: storageProxy(storage, changed),\n      configurable: false,\n      enumerable: true,\n      writable: false,\n    });\n\n    // assign raw storage\n    Object.keys(storage).forEach((k) => {\n      Object.defineProperty(instance, k, {\n        value: storage[k as keyof T],\n      });\n    });\n  }\n\n  return Object.freeze(instance);\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"./bitfield.js\";\nimport { getLsbIndex } from \"./utils.js\";\n\nexport class BitPool extends Bitfield {\n  private nextAvailable = 0;\n\n  constructor(size: number) {\n    super(size);\n    this.fill(4294967295);\n  }\n\n  get setCount(): number {\n    return Bitfield.getSetBitCountInBitfield(this);\n  }\n\n  acquire(): number {\n    const { nextAvailable } = this;\n    if (!~nextAvailable) return -1;\n    const index = this[nextAvailable] as number;\n    const position = getLsbIndex(index);\n    this[nextAvailable] &= ~(1 << position);\n    if (this[nextAvailable] === 0) {\n      this.nextAvailable = -1;\n      for (let i = 0; i < this.length; i++) {\n        if (this[i] !== 0) {\n          this.nextAvailable = i;\n          break;\n        }\n      }\n    }\n    return (nextAvailable << 5) + position;\n  }\n\n  release(idx: number): BitPool {\n    const { index, position } = this.getPosition(idx);\n    if (index === -1) return this;\n    this[index] |= 1 << position;\n    this.nextAvailable = index;\n    return this;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { BitPool } from \"./bitpool.js\";\nimport type { TypedArray } from \"./utils.js\";\nimport type { Entity } from \"../world.js\";\n\n/**\n * @param dense the typed array to apply the facade to\n * @returns A proxy to the dense array\n */\nexport function sparseFacade<T extends TypedArray>(dense: T): T {\n  /** Map<Entity, Dense Array Index> */\n  const sparse: Map<Entity, number> = new Map();\n\n  /** Array of available indexes in dense */\n  const available = new BitPool(dense.length);\n\n  /** @returns the entity's value from the dense array or undefined if non-existant */\n  const _get = (entity: Entity) => dense[sparse.get(entity) ?? -1];\n\n  /** @returns `false` if dense array is full, `true` if value set successfully */\n  const _set = (entity: Entity, value: T[0]): boolean => {\n    const idx = sparse.get(entity) ?? available.acquire();\n    if (idx === undefined) return false;\n    dense[idx] = value;\n    sparse.set(entity, idx);\n    return true;\n  };\n\n  /** @returns `false` if the entity isn't already stored, `true` if deleted successfully */\n  const _deleteProperty = (entity: Entity): boolean => {\n    const idx = sparse.get(entity);\n    if (idx === undefined) return false;\n    dense[idx] = 0;\n    sparse.delete(entity);\n    available.release(idx);\n    return true;\n  };\n\n  return new Proxy(dense, {\n    get: (_target: T, key: string | symbol) => _get(key as unknown as Entity),\n    set: (_target: T, key: string | symbol, value: T[0]) => _set(key as unknown as Entity, value),\n    deleteProperty: (_target: T, key: string | symbol) => _deleteProperty(key as unknown as Entity),\n  });\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { sparseFacade } from \"../utils/sparse-facade.js\";\nimport type { Component } from \"./component.js\";\nimport type { Schema, SchemaStorage } from \"./schema.js\";\nimport type { TypedArray, TypedArrayConstructor } from \"../utils/utils.js\";\n\ninterface ComponentBufferSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nexport class ComponentBuffer extends ArrayBuffer {\n  /**\n   * @private\n   * Calculate the total required storage space for all component schemas\n   */\n  private static calculateSize(capacity: number, components: Component<any>[]): number {\n    return components.reduce((total: number, component: Component<any>): number => {\n      const { size } = component;\n      if (!size || size < 0) return total;\n      return total + size * capacity;\n    }, 0);\n  }\n\n  /**\n   * @private\n   * Partitions the ComponentBuffer into individual TypedArrays for each Component\n   */\n  private static partition(buffer: ComponentBuffer, capacity: number, components: Component<any>[]) {\n    let offset = 0;\n    components.forEach(<T extends Schema<T>>(component: Component<T>) => {\n      const { maxEntities, schema } = component;\n      if (!schema) return;\n      const storage = {} as Record<keyof T, TypedArray>;\n      const requiredSize = maxEntities ?? capacity;\n      Object.entries(schema).forEach(([key, value]) => {\n        let typedArrayConstructor = value as TypedArrayConstructor;\n        let initialValue = 0;\n        if (Array.isArray(value)) [typedArrayConstructor, initialValue] = value as [TypedArrayConstructor, number];\n        const dense = new typedArrayConstructor(buffer, offset, requiredSize);\n        storage[key as keyof T] = maxEntities === null ? dense : sparseFacade(dense);\n        storage[key as keyof T].fill(initialValue as never);\n        offset += typedArrayConstructor.BYTES_PER_ELEMENT * requiredSize;\n      });\n      buffer.map.set(component, storage);\n    });\n    return buffer;\n  }\n\n  /** Maximum number of in the world */\n  readonly capacity: number;\n\n  /** Components and their respective TypedArray storage */\n  readonly map: Map<Component<any>, SchemaStorage<any>> = new Map();\n\n  /**\n   * Create a properly sized ArrayBuffer to hold all a world's component's data.\n   * @param spec The component buffer's specification object\n   * @param spec.capacity The world's entity capacity\n   * @param spec.components The components which the buffer will contain\n   */\n  constructor(spec: ComponentBufferSpec) {\n    const { capacity, components } = spec;\n    super(ComponentBuffer.calculateSize(capacity, components));\n    ComponentBuffer.partition(this, capacity, components);\n    this.capacity = capacity;\n  }\n}\n\nexport class DynamicBuffer {\n  /** The underlying storage buffer */\n  buffer: ArrayBuffer;\n\n  /** Maximum number of in the world */\n  readonly capacity: number;\n\n  /** Components and their respective TypedArray storage */\n  readonly map: Map<Component<any>, SchemaStorage<any>>;\n\n  /** The current offset of the buffer */\n  offset: number;\n\n  /**\n   * Component property storage\n   * @param capacity The maximum number of entities in the world\n   */\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.buffer = new ArrayBuffer(capacity);\n    this.map = new Map();\n    this.offset = 0;\n  }\n\n  addComponent<T extends Schema<T>>(component: Component<T>): DynamicBuffer {\n    if (this.map.has(component)) return this;\n\n    const { maxEntities, schema, size } = component;\n    if (!schema) return this;\n\n    // Resize and replace the buffer\n    const requiredSize = maxEntities ?? this.capacity;\n    const buffer = new ArrayBuffer(this.buffer.byteLength + requiredSize * size);\n    new Uint8Array(buffer).set(new Uint8Array(this.buffer));\n    this.buffer = buffer;\n\n    // Create storage for each property\n    const storage = {} as Record<keyof T, TypedArray>;\n    Object.entries(schema).forEach(([key, value]) => {\n      let typedArrayConstructor = value as TypedArrayConstructor;\n      let initialValue = 0;\n      if (Array.isArray(value)) [typedArrayConstructor, initialValue] = value as [TypedArrayConstructor, number];\n      const dense = new typedArrayConstructor(buffer, this.offset, requiredSize);\n      storage[key as keyof T] = maxEntities === null ? dense : sparseFacade(dense);\n      storage[key as keyof T].fill(initialValue as never);\n      this.offset += typedArrayConstructor.BYTES_PER_ELEMENT * requiredSize;\n    });\n\n    this.map.set(component, storage);\n\n    return this;\n  }\n\n  removeComponent<T extends Schema<T>>(component: Component<T>): DynamicBuffer {\n    const storage = this.map.get(component) as SchemaStorage<T>;\n    if (!storage) return this;\n\n    const { maxEntities, size } = component;\n\n    // Get the starting offset position for the component\n    const offset = Object.values(storage).reduce((res: number, arr) => {\n      const { byteOffset } = arr as TypedArray;\n      return Math.min(res, byteOffset);\n    }, Number.POSITIVE_INFINITY);\n\n    // Resize and replace the buffer\n    const requiredSize = maxEntities ?? this.capacity;\n    const totalSize = requiredSize * size;\n    const buffer = new ArrayBuffer(this.buffer.byteLength - totalSize);\n    const tmp = new Uint8Array(buffer);\n    tmp.set(new Uint8Array(this.buffer, 0, offset));\n    tmp.set(new Uint8Array(this.buffer, offset + totalSize));\n    this.buffer = buffer;\n\n    // Nudge all remaining components back (maps maintain set order)\n    let after = false;\n    [...this.map.entries()].forEach(([c, s]) => {\n      if (after) {\n        Object.entries(s).forEach(([k, v]) => {\n          const { byteLength, byteOffset } = v;\n          const Ctr = (v.constructor ??\n            (Object.getPrototypeOf(v) as Record<string, unknown>).constructor) as TypedArrayConstructor;\n          const a = new Ctr(buffer, byteOffset - totalSize, byteLength);\n          s[k] = a;\n        });\n      }\n      if (c === component) after = true;\n    });\n\n    return this;\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { $_OWNERS } from \"../constants.js\";\nimport { createComponentInstance, refreshComponentInstance } from \"./instance.js\";\nimport { ComponentBuffer } from \"./buffer.js\";\nimport type { Entity } from \"../world.js\";\nimport type { TypedArrayConstructor } from \"../utils/utils.js\";\nimport type { Component } from \"./component.js\";\nimport type { ComponentInstance } from \"./instance.js\";\nimport type { Schema, SchemaProps } from \"./schema.js\";\n\n/** [component name]: component instance */\nexport type ComponentRecord = Record<string, ComponentInstance<any>>;\n\nexport type ComponentMap = Map<Component<any>, ComponentInstance<any>>;\n\nexport interface ComponentManagerSpec {\n  capacity: number;\n  components: Component<any>[];\n}\n\nfunction instantiate(buffer: ComponentBuffer, capacity: number, components: Component<any>[]) {\n  return components.reduce(<T extends Schema<T>>(res: ComponentMap, component: Component<T>, id: number) => {\n    const instance = createComponentInstance({ capacity, component, id, storage: buffer.map.get(component) });\n    res.set(component, instance);\n    return res;\n  }, new Map() as ComponentMap);\n}\n\n/** @todo better async? */\nfunction add<T extends Schema<T>>(\n  instance: ComponentInstance<T>,\n  entity: number,\n  properties?: Record<string, SchemaProps<unknown>>,\n) {\n  const { maxEntities, name, schema } = instance;\n  if (maxEntities && instance.count >= maxEntities) {\n    throw new Error(`Component \"${name}\".maxEntities reached.`);\n  }\n  if (instance[$_OWNERS].isSet(entity)) return null;\n  instance[$_OWNERS].toggle(entity);\n  // set properties\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, value]) => {\n      instance[key as keyof T][entity] = properties\n        ? (properties[name] as SchemaProps<T>)[key as keyof T] ?? (value as [TypedArrayConstructor, number])[1] ?? 0\n        : (value as [TypedArrayConstructor, number])[1] ?? 0;\n    });\n  }\n  return instance;\n}\n\nexport const addEntity = <T extends Schema<T>>(\n  instance: ComponentInstance<T>,\n  entity: Entity,\n  properties?: Record<string, SchemaProps<T>>,\n) => add(instance, entity, properties);\n\n/** @todo better async? */\nfunction remove(instance: ComponentInstance<any>, entity: Entity) {\n  const { maxEntities, schema } = instance;\n  if (!instance[$_OWNERS].isSet(entity)) return null;\n  instance[$_OWNERS].toggle(entity);\n  if (schema) {\n    /** @todo Object.entries creates an array. */\n    Object.entries(schema).forEach(([key, prop]) => {\n      const storage = instance[key];\n      if (storage) {\n        if (maxEntities) {\n          delete storage[entity];\n        } else {\n          storage[entity] = Array.isArray(prop) ? prop[1] : 0;\n        }\n      }\n    });\n  }\n  return instance;\n}\n\nexport const removeEntity = <T extends Schema<T>>(instance: ComponentInstance<T>, entity: Entity) => {\n  return remove(instance, entity);\n};\n\nexport class ComponentManager {\n  readonly buffer: ComponentBuffer;\n  readonly componentMap: Map<Component<any>, ComponentInstance<any>>;\n\n  constructor(spec: ComponentManagerSpec) {\n    const { capacity, components } = spec;\n    this.buffer = new ComponentBuffer({ capacity, components });\n    this.componentMap = instantiate(this.buffer, capacity, components);\n  }\n\n  addComponentsToEntity(\n    components: Component<any>[],\n  ): (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => ComponentInstance<any>[] {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>) => {\n      return instances\n        .map((instance) => addEntity(instance, entity, properties))\n        .filter(Boolean) as ComponentInstance<any>[];\n    };\n  }\n\n  removeComponentsFromEntity(components: Component<any>[]) {\n    const instances = this.getInstances(components).filter(Boolean) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Some components are not registered in this world!\");\n    return (entity: Entity) => {\n      return instances.map((instance) => removeEntity(instance, entity)).filter(Boolean) as ComponentInstance<any>[];\n    };\n  }\n\n  getBuffer(): ArrayBuffer {\n    return this.buffer.slice(0);\n  }\n\n  getInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentMap.get(component);\n  }\n\n  getInstances(components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    return components.map(this.getInstance, this);\n  }\n\n  setBuffer(source: ArrayBuffer): ComponentManager {\n    if (source.byteLength !== this.buffer.byteLength) {\n      throw new Error(\"setBuffer: byteLength mismatch!\");\n    }\n    const view = new Uint8Array(source);\n    const target = new Uint8Array(this.buffer);\n    target.set(view);\n    return this;\n  }\n\n  refreshComponents(): ComponentManager {\n    this.componentMap.forEach(refreshComponentInstance);\n    return this;\n  }\n\n  export() {\n    return {\n      buffer: this.buffer.slice(0),\n      components: [...this.componentMap.values()],\n    };\n  }\n}\n","import { createQueryInstance } from \"./instance.js\";\nimport { Query } from \"./query.js\";\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { ComponentManager, ComponentRecord } from \"../component/manager.js\";\nimport type { Entity } from \"../world.js\";\nimport type { QueryInstance } from \"./instance.js\";\n\n/** @todo find a nicer way of doing this */\n// NOTE: The following functions are used to avoid flatmap which incurs a GC penalty\n\nfunction _flattenEntered(this: Set<Entity>, { entered }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entered.forEach(this.add, this);\n}\n\nfunction _flattenEntities(this: Set<Entity>, { entities }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  entities.forEach(this.add, this);\n}\n\nfunction _flattenExited(this: Set<Entity>, { exited }: Archetype) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  exited.forEach(this.add, this);\n}\n\nfunction refreshQuery(query: QueryInstance) {\n  query.isDirty = false;\n}\n\nexport interface QueryManagerSpec {\n  componentManager: ComponentManager;\n}\n\nexport class QueryManager {\n  /** The components, and their instances, of a given world */\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  /** Cache for Entities which match each QueryInstance */\n  entityCache: Map<QueryInstance, Set<Entity>>;\n  /** Map of registered Queries and their instances */\n  queryMap: Map<Query, QueryInstance>;\n\n  /**\n   * Creates a new QueryManager\n   *\n   * QueryManagers are responsible for:\n   *  - registering and instantiating queries\n   *  - getting components and entities from query instances\n   *\n   * @param spec the manager's specification object\n   */\n  constructor(spec: QueryManagerSpec) {\n    const { componentManager } = spec;\n    this.componentMap = componentManager.componentMap;\n    this.entityCache = new Map();\n    this.queryMap = new Map();\n  }\n\n  /** @returns the components associated with a query */\n  getComponentsFromQuery(query: Query): ComponentRecord {\n    return this.getQueryInstance(query).components;\n  }\n\n  /** @returns an array of Entities which have entered this query since last refresh */\n  getEnteredFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n    const res: Set<Entity> = new Set(); /** @todo avoid creating new set */\n    this.getQueryInstance(query)?.archetypes.forEach(_flattenEntered, res);\n    arr.push(...res);\n    return arr;\n  }\n\n  /** @returns an array of Entities which match the query */\n  getEntitiesFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n\n    const instance = this.getQueryInstance(query);\n\n    const { archetypes, isDirty } = instance;\n\n    const cached = this.entityCache.get(instance) as Set<Entity>;\n\n    // if new query, do full sweep and create cache set\n    if (!cached) {\n      const res: Set<Entity> = new Set();\n      archetypes.forEach(_flattenEntities, res);\n      this.entityCache.set(instance, res);\n      arr.push(...res);\n      return arr;\n    }\n\n    // if query has new Archetypes, clear cache and do full sweep\n    if (isDirty === true) {\n      cached.clear();\n      archetypes.forEach(_flattenEntities, cached);\n      arr.push(...cached);\n      return arr;\n    }\n\n    // else just update the dirty archetypes\n    archetypes.forEach((archetype) => {\n      if (archetype.isDirty === true) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        archetype.entered.forEach(cached.add, cached);\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        archetype.exited.forEach(cached.delete, cached);\n      }\n    });\n    arr.push(...cached);\n    return arr;\n  }\n\n  /** @returns an array of Entities which have been removed from this query since last refresh */\n  getExitedFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    arr.length = 0;\n    const res: Set<Entity> = new Set(); /** @todo avoid creating new set */\n    this.getQueryInstance(query)?.archetypes.forEach(_flattenExited, res);\n    arr.push(...res);\n    return arr;\n  }\n\n  /** @returns an instantiated Query */\n  getQueryInstance(query: Query): QueryInstance {\n    return this.registerQuery(query);\n  }\n\n  /** Register a Query in the world, producing a QueryInstance */\n  registerQuery(query: Query): QueryInstance {\n    if (!(query instanceof Query)) throw new Error(\"Object is not a valid query.\");\n    const cached = this.queryMap.get(query);\n    if (cached) return cached;\n    const instance = createQueryInstance({ componentMap: this.componentMap, query });\n    this.queryMap.set(query, instance);\n    return instance;\n  }\n\n  /** Perform routine maintenance on each registered query */\n  refreshQueries(): QueryManager {\n    this.queryMap.forEach(refreshQuery);\n    return this;\n  }\n\n  export() {\n    return {\n      queries: [...this.queryMap.values()],\n    };\n  }\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { Bitfield } from \"../utils/bitfield.js\";\nimport { intersectBits } from \"../utils/utils.js\";\nimport type { Archetype } from \"../archetype/archetype.js\";\nimport type { Component } from \"../component/component.js\";\nimport type { ComponentInstance } from \"../component/instance.js\";\nimport type { Query } from \"./query.js\";\nimport type { Schema } from \"../component/schema.js\";\n\ninterface QueryInstanceSpec {\n  componentMap: Map<Component<any>, ComponentInstance<any>>;\n  query: Query;\n}\n\nexport interface QueryInstance extends Query {\n  /** A bitfield for the AND match criteria */\n  and: Readonly<Bitfield>;\n  /** */\n  archetypes: Set<Archetype>;\n  /** */\n  checkCandidacy: (target: number, idx: number) => boolean;\n  /** */\n  components: Record<string, ComponentInstance<any>>;\n  /**\n   * `true` if the object is in a dirty state\n   *\n   * A query becomes dirty when an archetype is added or removed\n   */\n  isDirty: boolean;\n  /** A bitfield for the OR match criteria */\n  or: Readonly<Bitfield>;\n  /** A bitfield for the NOT match criteria */\n  not: Readonly<Bitfield>;\n}\n\nexport function createQueryInstance(spec: QueryInstanceSpec): QueryInstance {\n  const { componentMap, query } = spec;\n  const { all, any, none } = query;\n\n  const getComponentInstances = <T extends Schema<T>>(\n    arr: ComponentInstance<any>[],\n    component: Component<T>,\n    idx: number,\n  ) => {\n    const inst = componentMap.get(component);\n    if (!inst) throw new Error(`Component ${component.name} not found.`);\n    arr[idx] = inst as ComponentInstance<T>;\n    return arr;\n  };\n\n  const length = componentMap.size;\n\n  const _allInstances = all.reduce(getComponentInstances, new Array(all.length) as ComponentInstance<any>[]);\n  const and = Bitfield.fromObjects(length, \"id\", _allInstances);\n\n  const _anyInstances = any.reduce(getComponentInstances, new Array(any.length) as ComponentInstance<any>[]);\n  const or = Bitfield.fromObjects(length, \"id\", _anyInstances);\n\n  const _noneInstances = none.reduce(getComponentInstances, new Array(none.length) as ComponentInstance<any>[]);\n  const not = Bitfield.fromObjects(length, \"id\", _noneInstances);\n\n  /** The components matched by the and/or bitfields */\n  const components: Record<string, ComponentInstance<any>> = [..._allInstances, ..._anyInstances].reduce(\n    (res, component) => {\n      res[component.name] = component;\n      return res;\n    },\n    {} as Record<string, ComponentInstance<any>>,\n  );\n  Object.freeze(components);\n\n  const archetypes: Set<Archetype> = new Set();\n\n  const checkCandidacy = (target: number, idx: number): boolean => {\n    const OR = or[idx] === 0 || intersectBits(target, or[idx]) > 0;\n    if (!OR) return false;\n    const AND = intersectBits(target, and[idx]) === and[idx];\n    if (!AND) return false;\n    return intersectBits(target, not[idx]) === 0;\n  };\n\n  return Object.assign(Object.create(query), {\n    isDirty: true,\n    archetypes,\n    and,\n    checkCandidacy,\n    components,\n    not,\n    or,\n  }) as QueryInstance;\n}\n","/* Copyright 2022 the Miski authors. All rights reserved. MIT license. */\n\nimport { ArchetypeManager } from \"./archetype/manager.js\";\nimport { ComponentManager, removeEntity } from \"./component/manager.js\";\nimport { $_OWNERS, VERSION } from \"./constants.js\";\nimport { QueryManager } from \"./query/manager.js\";\nimport { Query } from \"./query/query.js\";\nimport { BitPool } from \"./utils/bitpool.js\";\nimport { isObject, isPositiveInt, isUint32, Opaque } from \"./utils/utils.js\";\nimport type { Component } from \"./component/component.js\";\nimport type { ComponentInstance } from \"./component/instance.js\";\nimport type { ComponentRecord } from \"./component/manager.js\";\nimport type { Schema, SchemaProps } from \"./component/schema.js\";\n\n/** Entities are indexes of an EntityArray. An Entity is just an integer. */\nexport type Entity = Opaque<number, \"Entity\">;\n\n/** The object returned from `world.save();` */\nexport interface WorldData {\n  /** The world's component storage buffer */\n  buffer: ArrayBuffer;\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** The Miski version of the creating world */\n  version: string;\n}\n\nexport interface WorldSpec {\n  /** The maximum number of entities allowed in the world */\n  capacity: number;\n  /** Components to instantiate in the world */\n  components: Component<any>[];\n}\n\n/**\n * Creates a valid WorldSpec (if possible) from an object\n * @param spec The object to examine\n * @returns A new WorldSpec object\n * @throws On invalid WorldSpec properties\n */\nfunction validateWorldSpec(spec: WorldSpec): Required<WorldSpec> {\n  // check spec exists\n  if (!spec || !isObject(spec)) {\n    throw new SyntaxError(\"World creation requires a specification object.\");\n  }\n  const { capacity, components } = spec;\n  // check capacity\n  if (!isPositiveInt(capacity)) {\n    throw new SyntaxError(\"World: spec.capacity invalid.\");\n  }\n  // check components\n  if (!Array.isArray(components) || !components.every((c) => Object.prototype.hasOwnProperty.call(c, \"name\"))) {\n    throw new TypeError(\"World: spec.components invalid.\");\n  }\n  return { ...spec, components: [...new Set(components)] };\n}\n\nexport class World {\n  private readonly archetypeManager: ArchetypeManager;\n  private readonly componentManager: ComponentManager;\n  private readonly queryManager: QueryManager;\n\n  /** Pool of Entity states */\n  private readonly entities: BitPool;\n\n  /** The maximum number of entities the world can hold */\n  readonly capacity: number;\n\n  /** Miski version */\n  readonly version = VERSION;\n\n  /**\n   * Create a new World object\n   * @param spec An WorldSpec object\n   * @param spec.capacity The maximum number of entities allowed in the world\n   * @param spec.components An array of components to instantiate in the world\n   * @throws If the spec is invalid\n   */\n  constructor(spec: WorldSpec) {\n    const { capacity, components } = validateWorldSpec(spec);\n    this.capacity = capacity;\n    this.entities = new BitPool(capacity);\n    this.archetypeManager = new ArchetypeManager({ capacity, components });\n    this.componentManager = new ComponentManager({ capacity, components });\n    this.queryManager = new QueryManager({ componentManager: this.componentManager });\n    this.refresh();\n    Object.freeze(this);\n  }\n\n  /** @returns the number of active entities */\n  get residents(): number {\n    return this.capacity - (this.entities.setCount - (this.entities.size - this.capacity));\n  }\n\n  /** @returns the number of available entities */\n  get vacancies(): number {\n    return this.capacity - this.residents;\n  }\n\n  /**\n   * Creates a function to add a given set of components to an entity\n   * @param components One or more components to add\n   * @returns A function which takes an entity and optional properties object\n   * @throws if one or more components are not registered in this world\n   */\n  addComponentsToEntity(...components: Component<any>[]) {\n    const cb = this.componentManager.addComponentsToEntity(components);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return (entity: Entity, properties?: Record<string, SchemaProps<unknown>>): World => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, cb(entity, properties));\n      return self;\n    };\n  }\n\n  /** @returns the next available Entity or `undefined` if no Entity is available */\n  createEntity(): Entity | undefined {\n    if (this.residents >= this.capacity) return;\n    const entity = this.entities.acquire() as Entity;\n    if (entity < 0) return;\n    this.archetypeManager.setArchetype(entity, this.archetypeManager.rootArchetype);\n    return entity;\n  }\n\n  /**\n   * Remove and recycle an Entity\n   * @param entity the entity to destroy\n   * @returns the world\n   * @throws if the entity is invalid\n   */\n  destroyEntity(entity: Entity): World {\n    if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n    // eslint-disable-next-line array-callback-return\n    this.archetypeManager.entityArchetypes[entity]?.components.forEach((instance) => removeEntity(instance, entity));\n    this.archetypeManager.resetArchetype(entity);\n    this.entities.release(entity);\n    return this;\n  }\n\n  /**\n   * Get all the changed entities from a set of components\n   * @param components The components to collect changed entities from\n   * @returns An array of entities\n   * @throws if one or more components are not registered in this world\n   */\n  getChangedFromComponents(...components: Component<any>[]): Entity[] {\n    const instances = this.componentManager.getInstances(components).filter((x) => x);\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    return [\n      ...new Set(\n        instances.reduce((res, inst) => {\n          res.push(...inst!.changed);\n          return res;\n        }, [] as Entity[]),\n      ),\n    ];\n  }\n\n  /**\n   * Get all the changed entities from a query\n   * @param query the query to collect changed entities from\n   * @param arr an optional array to be emptied and recycled\n   * @returns an array of entities\n   * @throws if query is invalid\n   */\n  getChangedFromQuery(query: Query, arr: Entity[] = []): Entity[] {\n    const instance = this.queryManager.getQueryInstance(query);\n    arr.length = 0;\n    // eslint-disable-next-line array-callback-return\n    Object.values(instance.components).forEach((inst) => arr.push(...inst.changed));\n    return [...new Set(arr)];\n  }\n\n  /**\n   * Get this world's instance of a component\n   * @param component The component to retrieve the instance of\n   * @returns The component instance or undefined if the component is not registered\n   */\n  getComponentInstance<T extends Schema<T>>(component: Component<T>): ComponentInstance<T> | undefined {\n    return this.componentManager.componentMap.get(component);\n  }\n\n  /**\n   * Get this world's instances of a set of components\n   * @param component The component to retrieve the instance of\n   * @returns An array of component instances or undefined if the component is not registered\n   */\n  getComponentInstances(...components: Component<any>[]): (ComponentInstance<any> | undefined)[] {\n    return this.componentManager.getInstances(components);\n  }\n\n  /**\n   * Get all of the component properties of a given entity\n   * @param entity The entity to retrieve the properties of\n   * @returns An object where keys are component names and properties are the entity's properties\n   */\n  getEntityProperties(entity: Entity): Record<string, SchemaProps<unknown>> {\n    const archetype = this.archetypeManager.getArchetype(entity);\n    if (!archetype) return {};\n    return archetype.components.reduce(\n      <T extends Schema<T>>(res: Record<keyof T, SchemaProps<unknown>>, component: ComponentInstance<T>) => {\n        const { name, schema } = component;\n        res[name as keyof T] = {};\n        if (schema === null) {\n          res[name as keyof T] = true;\n        } else {\n          res[name as keyof T] = Object.keys(schema).reduce((prev, key) => {\n            prev[key as keyof T] = component[key as keyof T][entity];\n            return prev;\n          }, {} as SchemaProps<T>);\n        }\n        return res;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Get all the components positively associated with a query\n   * @param query The query to get the components from\n   * @returns An object where keys are component names and properties are component instances\n   * @throws If the query is invalid\n   */\n  getQueryComponents(query: Query): ComponentRecord {\n    return this.queryManager.getComponentsFromQuery(query);\n  }\n\n  /**\n   * Get all the entities which have entered the query since the last refresh\n   * @param query The query to get the entities from\n   * @param arr An optional array to be emptied and recycled\n   * @returns An array of entities\n   * @throws If the query is invalid\n   */\n  getQueryEntered(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getEnteredFromQuery(query, arr);\n  }\n\n  /**\n   * Get all the entities which match a query\n   * @param query The query to get the entities from\n   * @param arr An optional array to be emptied and recycled\n   * @returns An array of entities\n   * @throws If the query is invalid\n   */\n  getQueryEntities(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getEntitiesFromQuery(query, arr);\n  }\n\n  /**\n   * Get all the entities which have exited the query since the last refresh\n   * @param query The query to get the entities from\n   * @param arr An optional array to be emptied and recycled\n   * @returns An array of entities\n   * @throws If the query is invalid\n   */\n  getQueryExited(query: Query, arr: Entity[] = []): Entity[] {\n    return this.queryManager.getExitedFromQuery(query, arr);\n  }\n\n  /**\n   * Create a function to test entities for a given component\n   * @param component The component to test for\n   * @returns A function which takes an entity and returns\n   *     true if the entity has the component, false if it does not\n   *     or null if the entity does not exist.\n   * @throws if the component is not registered in this world\n   */\n  hasComponent<T extends Schema<T>>(component: Component<T>): (entity: Entity) => boolean | null {\n    const instance = this.componentManager.getInstance(component);\n    if (!instance) throw new Error(\"Component is not registered.\");\n    return (entity: Entity) => instance[$_OWNERS].isSet(entity);\n  }\n\n  /**\n   * Create a function to test entities for a given component\n   * @param components The components to test for\n   * @returns A function which takes an entity and returns an array of\n   *     true if the entity has the component, false if it does not\n   *     or null if the entity does not exist.\n   * @throws if one or more component is not registered in this world\n   */\n  hasComponents(...components: Component<any>[]): (entity: Entity) => (boolean | null)[] {\n    const instances = this.componentManager.getInstances(components).filter((x) => x) as ComponentInstance<any>[];\n    if (instances.length !== components.length) throw new Error(\"Not all components registered!\");\n    return (entity: Entity): (boolean | null)[] => {\n      return instances.map((component) => component[$_OWNERS].isSet(entity));\n    };\n  }\n\n  /**\n   * Test if an entity is active in the world\n   * @return a boolean or null if the entity is invalid\n   *\n   */\n  isEntityActive(entity: Entity): boolean | null {\n    if (!this.isValidEntity(entity)) return null;\n    return this.entities.isSet(entity);\n  }\n\n  /** @return `true` if the given entity is valid for the given capacity */\n  isValidEntity(entity: Entity): entity is Entity {\n    return isUint32(entity) && entity < this.entities.size;\n  }\n\n  /**\n   * Swap the ComponentBuffer of one world with this world\n   * @returns the world\n   * @throws if the capacity or version of the data to load is mismatched\n   */\n  load(data: WorldData): World {\n    const { buffer, capacity, version } = data;\n    if (version !== this.version) {\n      throw new Error(`Version mismatch. Trying to load ${version} data into ${this.version} world.`);\n    }\n    if (capacity !== this.capacity) {\n      throw new Error(`Capacity mismatch. Data requires a world with a capacity of ${capacity}.`);\n    }\n    this.componentManager.setBuffer(buffer);\n    this.refresh();\n    return this;\n  }\n\n  /** Runs various world maintenance functions */\n  refresh(): World {\n    this.queryManager.refreshQueries();\n    this.archetypeManager.refreshArchetypes(this.queryManager.queryMap);\n    this.componentManager.refreshComponents();\n    return this;\n  }\n\n  /**\n   * Creates a function to remove a given set of components from an entity\n   * @param components One or more components to remove\n   * @returns A function which takes an entity\n   * @throws if one or more components are not registered in this world\n   */\n  removeComponentsFromEntity(...components: Component<any>[]): (entity: Entity) => World {\n    const remover = this.componentManager.removeComponentsFromEntity(components);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return (entity: Entity) => {\n      if (!this.isValidEntity(entity)) throw new SyntaxError(`Entity ${entity as number} is not valid!`);\n      this.archetypeManager.updateArchetype(entity, remover(entity));\n      return self;\n    };\n  }\n\n  /** Export various bits of data about the world */\n  save(): WorldData {\n    return Object.freeze({\n      buffer: this.componentManager.getBuffer(),\n      capacity: this.capacity,\n      version: this.version,\n    });\n  }\n}\n"],"names":["FORBIDDEN_NAMES","Object","freeze","VALID_NAME_PATTERN","EMPTY_ARRAY","$_CHANGED","Symbol","$_OWNERS","LOG_2","isUint32","n","isNaN","isPositiveInt","isTypedArrayConstructor","object","Boolean","prototype","hasOwnProperty","call","isValidName","str","length","includes","test","isObject","Array","isArray","intersectBits","a","b","_validateSchemaEntry","name","value","TAC","_validateProps","isValidSchema","schema","undefined","entries","every","_","byteSum","total","BYTES_PER_ELEMENT","Component","isTag","maxEntities","size","constructor","spec","SyntaxError","this","values","reduce","Number","NaN","calculateSchemaSize","_validateQueryArrays","component","Query","all","any","none","Set","System","system","query","init","world","components","getQueryComponents","entities","args","getQueryEntities","Bitfield","Uint32Array","static","bitfield","res","val","getSetBitCount","key","objs","obj","toggle","bit","super","Math","ceil","clone","result","set","cloneWithToggle","sources","forEach","source","getPosition","index","indexOf","position","isSet","i","Archetype","candidateCache","entered","exited","isDirty","fromObjects","Map","id","toString","isEmpty","addEntity","entity","add","isCandidate","cached","get","status","checkCandidacy","refresh","clear","removeEntity","delete","map","inst","join","ArchetypeManager","archetypeMap","entityArchetypes","rootArchetype","capacity","from","getArchetype","resetArchetype","refreshArchetypes","queries","archetype","archetypes","has","setArchetype","Error","updateArchetype","previousArchetype","nextArchetype","storageProxy","storage","changed","entityId","keys","defineProperty","getEntity","setEntity","TypeError","refreshComponentInstance","instance","BitPool","nextAvailable","fill","setCount","getSetBitCountInBitfield","acquire","release","idx","sparseFacade","dense","sparse","available","Proxy","_target","_get","_set","deleteProperty","_deleteProperty","ComponentBuffer","ArrayBuffer","buffer","offset","requiredSize","typedArrayConstructor","initialValue","calculateSize","partition","instantiate","owners","create","configurable","enumerable","writable","count","k","createComponentInstance","properties","prop","remove","ComponentManager","componentMap","addComponentsToEntity","instances","getInstances","filter","removeComponentsFromEntity","getBuffer","slice","getInstance","setBuffer","byteLength","view","Uint8Array","refreshComponents","export","_flattenEntered","_flattenEntities","_flattenExited","refreshQuery","QueryManager","entityCache","queryMap","componentManager","getComponentsFromQuery","getQueryInstance","getEnteredFromQuery","arr","push","getEntitiesFromQuery","getExitedFromQuery","registerQuery","getComponentInstances","_allInstances","and","_anyInstances","or","_noneInstances","not","assign","target","createQueryInstance","refreshQueries","World","archetypeManager","queryManager","version","c","validateWorldSpec","residents","vacancies","cb","self","isValidEntity","createEntity","destroyEntity","getChangedFromComponents","x","getChangedFromQuery","getComponentInstance","getEntityProperties","prev","getQueryEntered","getQueryExited","hasComponent","hasComponents","isEntityActive","load","data","remover","save"],"mappings":"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"}