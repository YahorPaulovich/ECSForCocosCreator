/*! *****************************************************************************
 *
 * miski
 * v0.6.0
 *
 * MIT License
 * 
 * Copyright (C) 2021 Peter Hughes<https://www.phugh.es>, all rights reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
***************************************************************************** */
function getMaxBit(e){return 32*e.length}function setBitOn(e,t){if(!function isValidBit(e,t){return!(t<0||t>getMaxBit(e))}(e,t))throw new SyntaxError(`Bit ${t} does not exist on mask.`);return e[Math.floor(t/32)]|=1<<t%32,e}function getMaskId(e){const t=getMaxBit(e);let n=0;for(let r=0,o=e.length;r<o;r++)n+=(e[r]^t)+r%32;return parseInt(Math.abs(n).toString(8),8)}function createBitmaskFromComponents(e,...t){const n=function createBitmask(e=32){return new Uint32Array(Math.ceil(e/32))}(e.spec.maxComponents||32);if(!t.length)return n;for(let r=0,o=t.length;r<o;r++){const o=t[r];if(o.world.id!==e.id)throw new Error("Components are not from the same world.");setBitOn(n,o.id)}return n}function spliceOne(e,t){const n=e.length;if(!n)return e;for(;t<n;)e[t]=e[t+1],t++;return e.length=e.length-1,e}function isObject(e){return Boolean("object"==typeof e&&!Array.isArray(e))}function systemNoop(e){}const e=/^(?![0-9])[a-zA-Z0-9$_]+$/;function isValidName(n){return"string"==typeof n&&((n=n.trim()).length>0&&e.test(n)&&!t.has(n))}const t=new Set(["entities","id","instances","name","schema","world","constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","prototype","toLocaleString","toString","valueOf","__defineGetter__","__defineSetter__","__lookupGetter__","__lookupGetter__","__proto__"]);function createQuery(e){if(!e)throw new Error("Query spec object required.");const{all:t=[],any:n=[],none:r=[]}=e;if(![...t,...n,...r].every(isValidComponent))throw new Error("Spec arrays must contain only Components.");return{instances:[],all:[...t],any:[...n],none:[...r]}}function isQueryCandidate(e,t){for(let n=0,r=e.and.length;n<r;n++){const r=t.mask[n];if(0!=(e.not[n]&r))return!1;if((e.and[n]&r)!==e.and[n])return!1;if((e.or[n]&r)>0)return!1}return!0}function addArchetypeToQuery(e,t){return-1!==e.archetypes.indexOf(t)||e.archetypes.push(t),e}function removeArchetypeFromQuery(e,t){const n=e.archetypes.indexOf(t);return-1===n||spliceOne(e.archetypes,n),e}function getComponentsFromQuery(e){return e.components}function _getEntities(e){return[...e.entities]}function getEntitiesFromQuery(e){return e.archetypes.flatMap(_getEntities)}var n;!function(e){e[e.EMPTY=-1]="EMPTY",e[e.DESTROYED=-2]="DESTROYED"}(n||(n={}));const r=128,o=1e4,i=Symbol(),a=Symbol();function updateEntityArchetype(e,t,r,o=!1){const{archetypes:i,entities:a}=e;let s=[];const u=a[t];if(void 0===u||u<-1)throw new Error("Entity is not available!");if(u>-1){const n=i.get(u);n&&(s=[...n.components],n.entities.delete(t),0===n.entities.size&&function deleteArchetype(e,t){const{archetypes:n,queries:r}=e,{id:o}=t;if(n.get(o)!==t)throw new Error("Archetype not found in world.");const i=[...r.values()];for(let e=0,n=i.length;e<n;e++)removeArchetypeFromQuery(i[e],t);return n.delete(o),t}(e,n))}if(r)if(!1===o)s.push(r);else{const e=s.indexOf(r);e>-1&&spliceOne(s,e)}if(0===s.length)return a[t]=n.EMPTY,null;const c=function createArchetype(e,...t){const n=createBitmaskFromComponents(e,...t);return{components:new Set(t),entities:new Set,mask:n,id:getMaskId(n)}}(e,...s),{id:l}=c,y=i.get(l);if(void 0===y){const n=[...e.queries.values()];for(let e=0,t=n.length;e<t;e++){const t=n[e];isQueryCandidate(t,c)&&addArchetypeToQuery(t,c)}return a[t]=l,c.entities.add(t),i.set(l,c),c}return a[t]=y.id,y.entities.add(t),y}function isValidSchema(e){if(!e)return!1;if(!isObject(e))return!1;if(Object.hasOwnProperty.call(e,"schema")&&!isObject(e=e.schema))return!1;const t=Object.values(e);return 0!==t.length&&t.every((e=>!0===e[a]))}function resetDataInStore(e,t){const{initial:n,isTypedArray:r,prefill:o}=e;if(t<0||t>e.length)throw new SyntaxError("Entity is out of range.");try{delete e[t]}catch(n){if(!r)throw new Error(n);e[t]=0}return!0===o&&(e[t]=n()),e}function getDataFromStore(e,t){return e[t]}function setDataInStore(e,t,n){if(t<0||t>e.length)throw new SyntaxError("Entity is out of range.");if(!e.guard(n))throw new TypeError("Value is not correct type.");return e[t]=n,e}function defineDataStore(e){const{name:t,initial:n,guard:r,arrayType:o=Array,prefill:i=!1}=e;if(!t||!r)throw new SyntaxError("Invalid datastore spec - mandatory properties missing.");if(!isValidName(t))throw new Error("Invalid name.");const s=n();if(!r(s))throw new TypeError("Initial property is of invalid type. Make sure guard(initial()) returns true.");const u=new o,c=function isTypedArray(e){return Boolean(ArrayBuffer.isView(e)&&!(e instanceof DataView))}(u);if(c&&("number"!=typeof s||isNaN(s)))throw new TypeError(`Initial property for typed array type must be a number. Found ${typeof s}.`);return Object.create(Object.getPrototypeOf(u),{getProp:{value:function(e){return this[e]},enumerable:!0},setProp:{value:function(e,t){if(e<0||e>this.length)throw new SyntaxError("Entity is out of range.");if(!this.guard(t))throw new TypeError("Property is not correct type.");return this[e]=t,this},enumerable:!0},arrayType:{value:o,enumerable:!0},guard:{value:r,enumerable:!0},initial:{value:n,enumerable:!0},isTypedArray:{value:c,enumerable:!0},name:{value:t,enumerable:!0},prefill:{value:i,enumerable:!0},[a]:{value:!0,enumerable:!0}})}function createDataStorage(e,t){const{arrayType:n,initial:r,prefill:o}=t,i=new n(e.spec.maxEntities);return Object.setPrototypeOf(i,t),!0===o&&i.fill(r()),i.world=e,i}function isValidComponent(e){return isObject(e)&&Object.prototype.hasOwnProperty.call(e,i)}function createComponent(e){if(!e)throw new SyntaxError("Component creation requires a specification object.");const{name:t,schema:n}=e;if(!isValidName(t))throw new SyntaxError("Component name is invalid.");if(!isValidSchema(n))throw new SyntaxError("Component schema is invalid.");return{[i]:!0,instances:[],name:t,schema:n}}function registerComponent(e,t){if(!e)throw new SyntaxError("Component registration requires a World object.");if(!t)throw new SyntaxError("Component registration requires a Component object.");const{instances:n,name:r,schema:o}=t,{components:i}=e;if(r in i)throw new Error(`Component with name "${r}" is already registered.`);const a=function indexOf(e,t){for(let n=0,r=e.length;n!=r;n++)if(e[n]===t)return n;return-1}(i,void 0);if(-1===a)throw new Error("Maximum components reached.");const s=Object.create(t,{entities:{value:new Set,enumerable:!0},id:{value:a,configurable:!1,enumerable:!0,writeable:!1},world:{value:e,configurable:!1,enumerable:!0,writeable:!1}}),u=Object.entries(o);for(let t=0,n=u.length;t<n;t++){const[n,r]=u[t];if(!isValidName(n))throw new SyntaxError(`Property name "${String(n)}" is invalid or forbidden.`);Object.defineProperty(s,n,{value:createDataStorage(e,r),configurable:!1,enumerable:!0,writable:!1})}return n.push(s),i[a]=s,s}function unregisterComponent(e){if(!e)throw new SyntaxError("Component instance required.");const{id:t,name:n,world:r}=e,{components:o}=r,i=o[t];if(!i||e!==i)throw new Error(`Component "${n}" does not exist in this world.`);const a=[...i.entities];for(let e=0,t=a.length;e<t;e++)removeComponentFromEntity(i,a[e]);return delete o[t],r}function addComponentToEntity(e,t,n){if(!e)throw new SyntaxError("Component instance required.");if(isNaN(t))throw new SyntaxError("Invalid or undefined entity provided.");const{id:r,name:o,schema:i,world:a}=e,{spec:s,components:u}=a;if(t<0||t>s.maxEntities)throw new Error(`Invalid entity provided: "${t}".`);const c=u[r];if(!c||e!==c)throw new Error(`Component "${o}" does not exist in this world.`);if(c.entities.has(t))throw new Error(`Entity "${t}" already has component "${o}".`);if(n){const e=Object.keys(i);for(let r=0,o=e.length;r<o;r++){const o=e[r];setDataInStore(c[o],t,n[o])}}return c.entities.add(t),updateEntityArchetype(a,t,c,!1),e}function removeComponentFromEntity(e,t){if(!e)throw new SyntaxError("Component instance required.");if(isNaN(t))throw new SyntaxError("Invalid or undefined entity provided.");const{id:n,name:r,schema:o,world:i}=e,{spec:a,components:s}=i;if(t<0||t>a.maxEntities)throw new Error(`Invalid entity provided: "${t}".`);const u=s[n];if(void 0===u||e!==u)throw new Error(`Component "${r}" does not exist in this world.`);if(!u.entities.has(t))throw new Error(`Entity "${t}" does not have component "${r}" to remove.`);const c=Object.keys(o);for(let e=0,n=c.length;e<n;e++){resetDataInStore(u[c[e]],t)}return u.entities.delete(t),updateEntityArchetype(i,t,e,!0),e}function createEntityArray(e){if(isNaN(e))throw new TypeError("Array length must be a number.");const t=new Int16Array(e).fill(n.DESTROYED),r=e-1,o=Array.from({length:e},((e,t)=>r-t));return Object.assign(t,{available:o})}function createEntity(e){if(!e)throw new SyntaxError("Entity creation requires a World object.");const t=e.entities.available.pop();if(void 0!==t)return e.entities[t]=n.EMPTY,updateEntityArchetype(e,t),t}function destroyEntity(e,t){if(!e)throw new SyntaxError("Entity destruction requires a World object.");if(isNaN(t))throw new SyntaxError("Invalid or undefined entity provided.");const{components:r,entities:o,spec:i}=e,{available:a}=o,{maxEntities:s}=i;if(t<0||t>s)throw new Error("Entity is out of range.");if(a.includes(t))return!1;for(let e=0,n=r.length;e<n;e++){const n=r[e];n&&(n.entities.has(t)&&removeComponentFromEntity(n,t))}return updateEntityArchetype(e,t),a.push(t),o[t]=n.DESTROYED,!0}function runPreSystems(e){const{systems:t}=e;for(let e=0,n=t.length;e<n;e++){const n=t[e];n.enabled&&n.pre(getEntitiesFromQuery(n.query))}}function runPostSystems(e,t=1){const{systems:n}=e;for(let e=0,r=n.length;e<r;e++){const r=n[e];r.enabled&&r.post(getEntitiesFromQuery(r.query),getComponentsFromQuery(r.query),t)}}function runUpdateSystems(e,t=0){const{systems:n}=e;for(let e=0,r=n.length;e<r;e++){const r=n[e];r.enabled&&r.update(getEntitiesFromQuery(r.query),getComponentsFromQuery(r.query),t)}}function createSystem(e){const{name:t,pre:n=systemNoop,post:r=systemNoop,update:o=systemNoop}=e;if(!isValidName(t))throw new SyntaxError("System name is invalid.");return{instances:[],name:t,post:r,pre:n,update:o}}function registerSystem(e,t,n){const{systems:r}=e,o=function createQueryInstance(e,t){const{queries:n}=e;if(n.has(t))return n.get(t);const _sameWorld=t=>t.world===e,_getInstance=e=>e.instances.filter(_sameWorld),r=t.all.flatMap(_getInstance),o=t.any.flatMap(_getInstance),i=t.none.flatMap(_getInstance),a=createBitmaskFromComponents(e,...r),s=createBitmaskFromComponents(e,...o),u=createBitmaskFromComponents(e,...i),c={archetypes:[],components:Object.freeze([...r,...o].reduce(((e,t)=>(e[t.name]=t,e)),{})),and:a,or:s,not:u,world:e};n.set(t,c);const l=[...e.archetypes.values()];for(let e=0,t=l.length;e<t;e++){const t=l[e];isQueryCandidate(c,t)&&addArchetypeToQuery(c,t)}return c}(e,n);let i=!1;const a=Object.create(t,{enabled:{get:()=>i,set(e){i=e},configurable:!1,enumerable:!0},query:{value:o,configurable:!1,enumerable:!0,writeable:!1},world:{value:e,configurable:!1,enumerable:!0,writeable:!1}});return t.instances.push(a),r.push(a),a}function unregisterSystem(e){const{world:t}=e,{systems:n}=t,r=n.indexOf(e);return void 0===r||spliceOne(n,r),t}function enableSystem(e){return e.enabled=!0,e}function disableSystem(e){return e.enabled=!1,e}function isSystemEnabled(e){return e.enabled}function numberGuard(e){return"number"==typeof e&&!isNaN(e)}function initToZero(){return 0}const s=defineDataStore({guard:e=>!0,initial:()=>{},name:"any"}),u=defineDataStore({arrayType:Int8Array,guard:numberGuard,initial:initToZero,name:"i8"}),c=defineDataStore({arrayType:Uint8Array,guard:numberGuard,initial:initToZero,name:"ui8"}),l=defineDataStore({arrayType:Uint8ClampedArray,guard:numberGuard,initial:initToZero,name:"ui8c"}),y=defineDataStore({arrayType:Int16Array,guard:numberGuard,initial:initToZero,name:"i16"}),m=defineDataStore({arrayType:Uint16Array,guard:numberGuard,initial:initToZero,name:"ui16"}),d=defineDataStore({arrayType:Int32Array,guard:numberGuard,initial:initToZero,name:"i32"}),f=defineDataStore({arrayType:Uint32Array,guard:numberGuard,initial:initToZero,name:"ui32"}),p=defineDataStore({arrayType:BigInt64Array,guard:numberGuard,initial:initToZero,name:"i64"}),h=defineDataStore({arrayType:BigUint64Array,guard:numberGuard,initial:initToZero,name:"ui64"}),w=defineDataStore({arrayType:Float32Array,guard:numberGuard,initial:initToZero,name:"f32"}),g=defineDataStore({arrayType:Int32Array,guard:numberGuard,initial:initToZero,name:"f64"}),b=defineDataStore({guard:e=>Array.isArray(e),initial:()=>[],name:"array"}),E=defineDataStore({guard:e=>"boolean"==typeof e,initial:()=>!1,name:"boolean"}),S=defineDataStore({guard:e=>"function"==typeof e,initial:()=>()=>{},name:"function"}),v=defineDataStore({guard:numberGuard,initial:initToZero,name:"number"}),T=defineDataStore({guard:e=>isObject(e),initial:()=>({}),name:"object"}),C=defineDataStore({guard:e=>"string"==typeof e,initial:()=>"",name:"string"}),x={maxComponents:r,maxEntities:o};function createWorld(e=x){const{maxComponents:t=r,maxEntities:n=o}=e;return{archetypes:new Map,components:new Array(t),entities:createEntityArray(n),id:`${Date.now().toString(36)}_${Math.random().toString(36).substr(2,9)}`,queries:new Map,spec:Object.freeze({maxComponents:t,maxEntities:n}),systems:[]}}export{addComponentToEntity,s as any,b as array,E as boolean,createComponent,createEntity,createQuery,createSystem,createWorld,defineDataStore,destroyEntity,disableSystem,enableSystem,w as f32,g as f64,S as fnc,getDataFromStore,y as i16,d as i32,p as i64,u as i8,initToZero,isSystemEnabled,isValidComponent,isValidName,isValidSchema,v as number,numberGuard,T as object,registerComponent,registerSystem,removeComponentFromEntity,runPostSystems,runPreSystems,runUpdateSystems,setDataInStore,C as string,m as ui16,f as ui32,h as ui64,c as ui8,l as ui8c,unregisterComponent,unregisterSystem};
//# sourceMappingURL=miski.min.js.map
